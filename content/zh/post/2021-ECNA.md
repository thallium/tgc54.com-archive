---
title: "2021 ECNAåŒºåŸŸèµ›æ€»ç»“ä¸é¢˜è§£"
date: 2022-02-26T21:07:17-05:00
categories: ["æ¯”èµ›é¢˜è§£"]
tags: []
---
å·®ä¸å¤šæœ€åä¸€å¹´äº†ï¼Œæ˜å¹´é˜Ÿå‹ä¼°è®¡å°±éƒ½æ¯•ä¸šäº†ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ‰¾åˆ°å…¶ä»–äººå§ï¼Œæˆ–è€…soloä¹Ÿè¡Œï¼Ÿ
<!--more-->

## æ€»ç»“

ä»Šå¹´ç”±äºç–«æƒ…ä¾ç„¶ä¸èƒ½å»æ¸©èçº¿ä¸‹æ¯”èµ›ï¼Œä½†ç›¸æ¯”å»å¹´ä¸‰äººä¸‰æœºä»Šå¤©å˜æˆäº†æ›´åƒçº¿ä¸‹çš„ä¸‰äººä¸€æœºï¼Œä¸è¿‡æ˜¯åœ¨å„è‡ªå­¦æ ¡æ¯”èµ›ï¼Œä½†ä»¤äººä¸èƒ½ç†è§£æ˜¯çš„å±…ç„¶ä¸€ç‚¹ç›‘æ§æªæ–½éƒ½æ²¡æœ‰ï¼Œå…¨å‡­è‡ªå·±è‡ªè§‰å’Œæ•™ç»ƒç›‘ç£ã€‚ã€‚ã€‚ã€‚å¯ä»¥ç†è§£ä¸ºæ‘†çƒ‚å§ğŸ˜‚ã€‚æˆ‘ä»¬é˜Ÿç®—æ˜¯åšåˆ°äº†éµå¾ªè§„åˆ™ï¼Œé™¤äº†å¤šæ¥äº†ä¸€ä¸ªæ˜¾ç¤ºå™¨ç”¨æ¥çœ‹ä»£ç ï¼ˆè‡ªå·±ç”µè„‘æ²¡æ³•è¿æœºæˆ¿çš„æ‰“å°æœºï¼‰ï¼Œä»¥åŠæˆ‘è¿˜æ˜¯ç”¨çš„è‡ªå·±çš„é”®ç›˜ï¼ˆç”¨40%é…åˆ—å¤ªä¹…äº†æ”¹ä¸å›æ¥äº†ï¼‰ã€‚

[æ’å](https://ecna21.kattis.com/standings)æœ‰ç‚¹å‡ºä¹æ„æ–™ï¼Œè€ƒè™‘åˆ°é˜Ÿå‹å¿™äºå®ä¹ ä»ä¸è®­ç»ƒã€æˆ‘ä¸Šäº†å¤§ä¸‰ä¹‹åè¯¾ç¨‹éš¾åº¦å¢åŠ ï¼Œåªèƒ½é æ¯å‘¨cfç»´æŒä¸€ç‚¹åšé¢˜é‡ï¼Œè¿™ä¸ªæ’åå·²ç»å¾ˆæ»¡æ„äº†ï¼Œæ¯•ç«Ÿå¦‚æœæŒ‰NACæ™‹çº§è§„åˆ™æŒ‰å­¦æ ¡æ’åæ˜¯ç¬¬6ï¼Œæ ¡æ’åè¦æ˜¯ç¬¬5çš„è¯æ€»æ’åè¦ç¬¬6ï¼Œå®Œå…¨æƒ³peachğŸ˜‚ã€‚

æ•´åœºæ¯”èµ›è¿˜æ˜¯æ¯”è¾ƒæµç•…çš„ï¼ŒåŸºæœ¬æ²¡æœ‰å¡å¤ªé•¿æ—¶é—´ï¼ŒAé¢˜ä½œä¸ºæ¯”è¾ƒç®€å•çš„é¢˜å¡äº†æœ‰ç‚¹ä¹…ï¼Œæœ€åè¿˜æ˜¯é çŒœç»“è®ºè¿‡çš„ï¼ŒFè®¡ç®—å‡ ä½•æŸé˜Ÿå‹åˆ°æœ€åä¹Ÿæ²¡æå‡ºæ¥ï¼Œä¸è¿‡æ²¡å ç”¨å¤ªå¤šæ­£å¸¸æ—¶é—´ã€‚æ—¶é—´å†ç¨å¾®å¤šä¸€ç‚¹ä¹Ÿè®¸èƒ½ææIæˆ–è€…Kï¼Œä¸è¿‡åˆ°æœ€åä¹Ÿæ¯”æœ‰ç‚¹ç´¯äº†ï¼Œæ˜¨æ™šä¹Ÿåªç¡äº†5ä¸ªåŠå°æ—¶ã€‚

## é¢˜ç›®

é¢˜ç›®æ•´ä½“éš¾åº¦é€‚ä¸­ï¼Ÿæ¯”å»å¹´éš¾ä¸€ç‚¹ï¼Œï¼ˆè¯»äº†çš„é¢˜ï¼‰ä»¥æ€ç»´é¢˜ä¸ºä¸»ã€‚é™¤äº†Jé¢˜æ‘†çƒ‚å‡ºäº†æœ€å¤§å­çŸ©å½¢åŸé¢˜ï¼Œé¢˜ç›®è´¨é‡è¿˜å¯ä»¥ï¼Ÿ

### A

ä¸€å¼€å§‹waæ˜¯å› ä¸ºå¿˜äº†è€ƒè™‘ç›¸åŠ çš„è½¬ç§»ã€‚è€ƒè™‘åŠ çš„è¯è¦éå†ä¸€éæ•´ä¸ªdpæ•°ç»„ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šå˜æˆ$O(n^2)$ï¼Œä½†å…¶å®ä¹Ÿèƒ½è¿‡å› ä¸ºæ—¶é—´ç»™äº†15sã€‚ã€‚ã€‚ï¼ˆæˆ‘tmå†™åšå®¢çš„æ—¶å€™æ‰å‘ç°ï¼‰ã€‚ä½†è²Œä¼¼åªè¦éå†å‰é¢ä¸€äº›æ•°å°±è¡Œäº†ï¼Œå› ä¸ºæ•°å¤§çš„æ—¶å€™ä¹˜è‚¯å®šæ¯”åŠ åˆ’ç®—ã€‚

{{% collapse ä»£ç  %}}
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin >> n;
    vector<int> dp(n + 1, 1e9);
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = i;

        for (int j = 1; j <= min(i / 2 + 1, 1000); j++)
            dp[i] = min(dp[i], dp[j] + dp[i - j]);

        string s = to_string(i);
        for (int j = 1; j < (int)size(s); j++) {
            string s1 = s.substr(0, j), s2 = s.substr(j);
            if (s2[0] == '0') continue;
            dp[i] = min(dp[i], dp[stoi(s1)] + dp[stoi(s2)]);
        }

        for (int f = 2; f * f <= i; f++) {
            if (i % f == 0) { dp[i] = min(dp[i], dp[f] + dp[i / f]); }
        }
    }
    cout << dp[n] << endl;
}
```
{{% /collapse %}}

### B

èµ›æ—¶æ— è„‘æ•²äº†ä¸ªlcaï¼Œä½†å…¶å®ç¨å¾®å†æƒ³æƒ³å°±æœ‰æ›´ç®€å•çš„åšæ³•ï¼šdfsæ—¶ç»´æŠ¤åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»ä»¥åŠæœ€çŸ­çš„ä¸¤æ¡åˆ°å¶å­çš„è·¯å¾„çš„ä¸¾ä¾‹å³å¯ã€‚

{{% collapse ä»£ç  %}}
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin >> n >> m;
    vector<vector<int>> g(n);
    vector<int> a(n);
    for (auto &x : a)
        cin >> x;
    vector<int> indeg(n), sum(n), color(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        g[u].push_back(v);
        indeg[v]++;
    }
    int c = 0;
    int ans = 1e9;
    auto dfs = [&](auto &slf, int u, int s) -> int {
        sum[u] = s + a[u];
        color[u] = c;
        int mn0 = 1e9, mn1 = 1e9;
        for (auto v : g[u]) {
            auto res = slf(slf, v, s + a[u]);
            if (res < mn1) mn1 = res;
            if (mn1 < mn0) swap(mn0, mn1);
        }
        ans = min(ans, mn0 + mn1 + sum[u]);
        return (mn0 == 1e9 ? 0 : mn0) + a[u];
    };
    for (int i = 0; i < n; i++) {
        if (indeg[i] == 0) {
            dfs(dfs, i, 0);
            c++;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (g[i].empty() && g[j].empty()) {
                if (color[i] != color[j]) {
                    ans = min(ans, sum[i] + sum[j]);
                }
            }
        }
    }
    cout << ans << endl;
}
```
{{% /collapse %}}

### G

ç­¾åˆ°é¢˜ï¼Œæšä¸¾æ‰€æœ‰å‰ç¼€ä»¥åŠäº¤æ¢é¡ºåºå³å¯

{{% collapse ä»£ç  %}}
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string a, b, c;
    char op, _;
    cin >> a >> op >> b >> _ >> c;
    auto check = [&](string a_, string b_, string c_) {
        __int128 a = stoll(a_), b=stoll(b_), c = stoll(c_);
        if (op=='+') return a+b==c;
        else return a*b==c;
    };
    for (int i=1; i<(int)size(a); i++) {
        for (int j=1; j<(int)size(b); j++) {
            for (int k=1; k<(int)size(c); k++) {
                string a1=a.substr(0, i), a2=a.substr(0+i);
                string b1=b.substr(0, j), b2=b.substr(0+j);
                string c1=c.substr(0, k), c2=c.substr(0+k);
                vector<string> s = {a1, b1, c1};
                sort(begin(s), end(s));
                do {
                    if (check(s[0]+a2, s[1]+b2, s[2]+c2)) {
                        cout << s[0]+a2 << ' ' << op << ' ' <<  s[1]+b2 << " = " << s[2]+c2;
                        exit(0);
                    }
                } while (next_permutation(begin(s), end(s)));
            }
        }
    }
}
```
{{% /collapse %}}

### J

ç»å…¸æœ€å¤§å­çŸ©é˜µï¼Œå•è°ƒæ ˆææå³å¯ã€‚å…¶å®æˆ‘èµ›æ—¶å·²ç»åŸºæœ¬å¿˜äº†æ€ä¹ˆåšäº†ï¼Œåªè®°å¾—æ˜¯æ˜¯å•è°ƒæ ˆï¼Œæƒ³äº†åŠå¤©æ‰æƒ³å‡ºæ¥æ­£è§£ï¼Œè¿™ä¸‹åº”è¯¥ä»¥åå¿˜ä¸äº†äº†233

{{% collapse ä»£ç  %}}
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long; //}}}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    stack<pair<int, int>> stk;
    ll ans = 0;
    int s = 1e9, e = 0;

    auto update = [&](ll cur, int curs, int cure) {
        if (cur > ans || (cur == ans && curs < s)) {
            ans = cur;
            s = curs;
            e = cure;
        }
    };
    for (int i = 0; i < n; i++) {
        int prev = i;
        while (!stk.empty() && stk.top().first >= a[i]) {
            prev = stk.top().second;
            ll cur = ll(i - prev) * stk.top().first;
            update(cur, prev, i - 1);
            stk.pop();
        }
        ll cur = ll(i - prev + 1) * a[i];
        update(cur, prev, i);
        stk.push({a[i], prev});
    }
    while (!stk.empty()) {
        auto [x, i] = stk.top();
        stk.pop();
        ll cur = ll(n - i) * x;
        update(cur, i, n - 1);
    }
    cout << s + 1 << ' ' << e + 1 << ' ' << ans << endl;
}
```
{{% /collapse %}}

### L

æšä¸¾å››ä¸ªè§’ç„¶åæ’åºåˆ†å±‚æä¸€æï¼Œé˜Ÿå‹å†™çš„

{{% collapse ä»£ç  %}}
```python
import collections
import itertools
import sys
ints = lambda: list(map(int, sys.stdin.readline().split()))
grid = []
gy, gx = ints()
for y in range(gy):
  grid.append(ints())
statues = []
for row in grid:
  for cell in row:
    if ~cell:
      statues.append(cell)
statues.sort()

def levels(grid):
  ret1 = collections.defaultdict(set)
  ret2 = collections.defaultdict(set)
  for y in range(gy):
    for x in range(gx):
      cell = grid[y][x]
      if ~cell:
        ret1[y+x].add(cell)
        ret2[y-x].add(cell)
  return ret1, ret2

ret1, ret2 = levels(grid)

keys1 = sorted(ret1.keys())
keys2 = sorted(ret2.keys())

import math
moved = math.inf

for keys, ret in (keys1, ret1), (reversed(keys1), ret1), (keys2, ret2), (reversed(keys2), ret2):
  this = len(statues)
  it = iter(statues)
  for key in keys:
    st = set()
    for _ in range(len(ret[key])):
      st.add(next(it))
    this -= len(st & ret[key])
  moved = min(moved, this)

print(moved)
```
{{% /collapse %}}

### M

æœ€çŸ­è·¯è€ƒè™‘ç”¨bfsï¼ŒæŠŠæ‰€æœ‰å­—ç¬¦ä¸²æ”¾å…¥ä¸€ä¸ªtrieå°±å¯ä»¥å¾ˆå®¹æ˜“çŸ¥é“å“ªäº›æ–¹å‘å¯ä»¥èµ°äº†ï¼Œæ‰€ä»¥çŠ¶æ€å°±æ˜¯[x][y][trieä¸­çš„èŠ‚ç‚¹çš„ä½ç½®][ä¸Šä¸€æ­¥çš„æ–¹å‘]ã€‚é™¤äº†çŠ¶æ€å¤æ‚ç‚¹å…¶ä»–å°±æ˜¯æ­£å¸¸bfsçš„å¥—è·¯ï¼Œæ³¨æ„å¦‚æœå½“å‰åœ¨å•è¯ç»“å°¾çš„ä½ç½®ï¼Œä¸‹ä¸€æ­¥å³å¯ä»¥å›åˆ°trieçš„æ ¹ï¼Œåˆå¯ä»¥ç»§ç»­é¡ºç€trieèµ°ã€‚

{{% collapse ä»£ç  %}}
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Trie {
    struct node {
        map<char, int> ch;
        bool term;
    };
    vector<node> t;
    Trie() { new_node(); }
    int new_node() {
        t.emplace_back();
        return t.size() - 1;
    }
    void insert(const string &s) {
        int p = 0;
        for (auto ch : s) {
            if (!t[p].ch.count(ch)) { t[p].ch[ch] = new_node(); }
            p = t[p].ch[ch];
        }
        t[p].term = true;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m, k;
    cin >> n >> m >> k;
    vector s(n, vector<char>(m));
    for (auto &v : s)
        for (auto &c : v)
            cin >> c;
    Trie tr;
    for (int i = 0; i < k; i++) {
        string ss;
        cin >> ss;
        tr.insert(ss);
    }
    vector dis(n, vector(m, vector(size(tr.t), vector(3, -1))));
    queue<array<int, 4>> q;
    for (int i = 0; i < m; i++) {
        if (tr.t[0].ch.count(s[0][i])) {
            int st = tr.t[0].ch[s[0][i]];
            dis[0][i][st][0] = 1;
            q.push({0, i, st, 0});
        }
    }

    const vector<pair<int, int>> dir{{1, 0}, {0, -1}, {0, 1}};
    while (!q.empty()) {
        auto [x, y, st, prev] = q.front();
        int olddis = dis[x][y][st][prev];
        q.pop();
        for (int ii = 0; ii < (int)size(dir); ii++) {
            auto [dx, dy] = dir[ii];
            if ((prev == 1 && dy == 1) || (prev == 2 && dy == -1))
                continue;
            unsigned nx = x + dx, ny = y + dy;
            if (nx < n && ny < m) {
                auto go = [&](int st) {
                    if (tr.t[st].ch.count(s[nx][ny])) {
                        int nst = tr.t[st].ch[s[nx][ny]];
                        if (dis[nx][ny][nst][ii] == -1) {
                            dis[nx][ny][nst][ii] = olddis + 1;
                            q.push({(int)nx, (int)ny, nst, ii});
                        }
                    }
                };
                go(st);
                if (tr.t[st].term) {
                    st = 0;
                    go(st);
                }
            }
        }
    }
    int ans = 1e9;
    for (int i = 0; i < m; i++) {
        for (int d = 0; d < 3; d++) {
            for (int st = 0; st < (int)size(tr.t); st++) {
                if (tr.t[st].term && dis[n - 1][i][st][d] != -1) {
                    ans = min(ans, dis[n - 1][i][st][d]);
                }
            }
        }
    }
    if (ans == 1e9) {
        cout << "impossible\n";
    } else
        cout << ans << endl;
}
```
{{% /collapse %}}
