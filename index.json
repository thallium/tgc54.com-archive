[{"authors":null,"categories":null,"content":" Also known online as @Thallium54 Back End Developer intern @ IBM CS student @ York University Tech things that I enjoy: software development, home server, Linux… Competitive programming enthusiast Some of my other hobbies: Rubik’s cube, custom (ergonomic) mechanical keyboard, table tennis. Languages: C/C++, Python, Go, JS, Java, Lua ","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Also known online as @Thallium54 Back End Developer intern @ IBM CS student @ York University Tech things that I enjoy: software development, home server, Linux… Competitive programming enthusiast Some of my other hobbies: Rubik’s cube, custom (ergonomic) mechanical keyboard, table tennis.","tags":null,"title":"Gengchen Tuo","type":"authors"},{"authors":null,"categories":null,"content":"","date":1636848e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636848e3,"objectID":"fe2f41546cc94fa45b68377537542160","permalink":"https://tgc54.com/project/cp-parser/","publishdate":"2021-11-14T00:00:00Z","relpermalink":"/project/cp-parser/","section":"project","summary":"A command line application that parses sample test cases from various competitive programming websites with ease.","tags":null,"title":"Competitive Programming Parser","type":"project"},{"authors":null,"categories":null,"content":"","date":1647388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647388800,"objectID":"846a6d9a8dbf496181714ada857357e8","permalink":"https://tgc54.com/project/mirai-cp/","publishdate":"2022-03-16T00:00:00Z","relpermalink":"/project/mirai-cp/","section":"project","summary":"A QQ bot centered around Competitive Programming. Inspired by TLE discord bot. \n \n Current feature: get upcoming contests, plot user's rating graph.","tags":null,"title":"Mirai-competitive-programming","type":"project"},{"authors":null,"categories":["cp-bot"],"content":"这周没做什么大功能，做了下几件小事：\n参数 原来on_shell_command就是专门负责这个的，可以传入一个argument parser，那这样就很简单了，于是给查比赛加了-n x和--all以显示前x条或者全部比赛。\n数据库相关 最近了解到ORM（我真是孤陋寡闻现在才知道这个东西），于是决定放弃MongoDB还是用关系型数据库，但APScheduler的SQLAlchemyJobStore好像没完全支持SQLAlchemy 2所以比赛提醒暂时就没法做可持久化了，但一想可持久化也没有太大的用，每次更新缓存的时候重新添加一遍提醒应该就够了。。。缓存的话到是弄完了但是没法测试，因为今天cf的API一直都是挂了的。说到ORM就不得不提重构的事：\n重构 现在Contest类不再用NamedTuple了，因为可以和ORM（用的SQLModel）的Model共用一个类，而且SQLModel的model也是Pydantic model所以可以直接用parse_obj，比之前NamedTuple优雅多了。不得不说SQLModel的理念真的很有想法。\nLaTex插件 受群友的提示写了个渲染LaTex的插件，试了Matplotlib和SymPy的latex功能都不太满意，最后基于SymPy的preview函数自己写了个插件。\nTODO：\n缓存和提醒 继续研究TLE的代码看看有没有好玩的功能 把代码整理好开源到github上 ","date":1661132506,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661132506,"objectID":"16cb3152850d3b634351bc37b64cd4bf","permalink":"https://tgc54.com/zh/post/cp-bot-dev-log-2/","publishdate":"2022-08-21T21:41:46-04:00","relpermalink":"/zh/post/cp-bot-dev-log-2/","section":"zh","summary":"这周没做什么大功能，做了下几件小事： 参数 原来on_shell","tags":[],"title":"全新的开始 - 算法竞赛机器人开发日志2","type":"zh"},{"authors":null,"categories":["cp-bot"],"content":"我的机器人，明明只有两个功能，却已重写了两次了，第一次从C++搬到Python，现在又从Python搬到Nonebot框架上（虽说还是Python)，以后应该不会再动了。这次搬迁起源于周六在给上一版本写readme，准备发布到GitHub上，当时我在特点里写下了\n不使用框架（可能是个错误的决定）\n然后我就不禁思考这到底是不是个错误的决定：当初不用框架的原因也很简单，就是不想学框架的那一套，然后又觉得自己造点轮子也挺好玩的，但后来发现自己需要造的轮子越来越大时就不那么好玩了，目前有几个大轮子要造：\n命令与参数系统，如果将来命令增多的话一堆if else加字符串匹配又麻烦又丑 定时命令，比赛提醒是我接下来想做的一大特性，因为我老是忘AtCoder的比赛 配置系统，要是将来别人要用的话一定要做好配置系统 于是我又看了看Nonebot的文档，发现好像也没那么麻烦，而且自带命令与定时系统，又想到框架难道不就是为了让开发者专注于编写业务逻辑吗？于是就想先试试看，然后第二天早上加中午吃完饭一点时间就基本搬过去了，又看到非常fancy的log界面就决定完全转到Nonebot上了。\n那又为什么要写开发日志捏？因为机器人其实好久没再继续开发了，自从前两周发现了APScheduler之后就开始研究加缓存与比赛提醒的功能，然后就萌生了写日志的想法，这次搬迁又差不多算是“从头开始”所以就每周写一篇开发日志记录本周工作以及接下来要做的任务，顺便起到督促自己的作用。\n第一篇（这篇）本来应该周日写的来着，结果周日出去玩由于突发情况回来的很晚，基本上接着就上床睡觉了。以后日志争取在周末写，这次由于背景介绍所以稍长，以后应该就简单记录一下。\n上周工作：\n基本完成搬运，两个命令已可用，但缓存还没搞定 一些重构：重命名，添加type hint 变成包之后import语句要变成类似from . import xxx，把所有import都修了（还挺多的） TODO：\n参数系统，查比赛命令挺需要的 画图功能也很需要 看看内置的scheduler能不能用数据库的job store，如果能的话： 尽快能把缓存弄好 比赛提醒 根据配置开关某些功能，比如是否使用缓存 重构一些抄的TLE的代码，感觉不是很喜欢TLE的一些设计 搬一些TLE其他的有趣的功能 ","date":1660614388,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1660614388,"objectID":"2e27259f2872c1394ecd74cea7e58d51","permalink":"https://tgc54.com/zh/post/cp-bot-dev-log-1/","publishdate":"2022-08-15T21:46:28-04:00","relpermalink":"/zh/post/cp-bot-dev-log-1/","section":"zh","summary":"我的机器人，明明只有两个功能，却已重写了两次了，第一次从C+","tags":[],"title":"全新的开始 - 算法竞赛机器人开发日志1","type":"zh"},{"authors":null,"categories":["题解"],"content":"首先发现无论如何操作，只有关于对角线对称的两个位置（$a_{i, j}, a_{j, i}$）会被交换，而且只有$k=i$和$k=j$的操作会影响这两个位置的交换。 我们用$s_i$来表示操作$k=i$是否被执行，如果$a_{i, j} \u0026lt; a_{j, i}$，我们不希望他们被交换所以我们希望$s_i\\oplus s_j=0$，反之如果$a_{i, j} \u0026gt; a_{j, i}$，我们希望他们交换所以我们希望$s_i \\oplus s_j = 1$。（$\\oplus$代表按位异或）\n对于字典序的问题，往往采用从前往后贪心的策略。对于当前的$i, j$我们要看之前的限制是否允许我们希望的$s_i \\oplus s_j$值。那么如何判断呢？我们用一种让并查集的边带权的技巧，即边$(u, v)$的权值代表$s_u\\oplus s_v$，那么一个分量中任意两点的异或值即为路径上边的异或值。为了方便实现我们用节点$u$代表$u$到其父节点的边。在find和join时要更新边权（见代码）。\n条件$s_i \\oplus s_j = x$就相当于给$i$和$j$中间连一条权值为$x$的边，对应并查集的join操作，如果加边之前两个点不在同一个连通分量，那么条件一定是可以满足的。如果在同一个分量中，那么说明$s_i \\oplus s_j$已经是确定的，如果$s_i \\oplus s_j \\neq x$说明当前条件不能满足，我们就跳过它。\n其他实现细节见代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct UF { vector\u0026lt;int\u0026gt; fa, sz, parity; UF(int n) : fa(n), sz(n, 1), parity(n) { iota(fa.begin(), fa.end(), 0); } array\u0026lt;int, 2\u0026gt; find(int x) { if (fa[x] == x) { return {x, 0}; } auto [f, z] = find(fa[x]); fa[x] = f; parity[x] ^= z; return {fa[x], parity[x]}; } bool same(int x, int y) { return find(x) == find(y); } bool join(int x, int y, int p) { auto [fx, px] = find(x); auto [fy, py] = find(y); if (fx == fy) return (px ^ py ^ p) == 0; if (sz[fx] \u0026gt; sz[fy]) swap(fx, fy); fa[fx] = fy; parity[fx] = px ^ py ^ p; sz[y] += sz[x]; return true; } }; void test_case() { int n; cin \u0026gt;\u0026gt; n; vector a(n, vector(n, 0)); for (auto\u0026amp; v : a) { for (auto\u0026amp; x : v) { cin \u0026gt;\u0026gt; x; } } UF uf(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (a[i][j] == a[j][i]) { continue; } if (uf.join(i, j, a[i][j] \u0026gt; a[j][i]) ^ (a[i][j] \u0026lt; a[j][i])) { swap(a[i][j], a[j][i]); } } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { cout \u0026lt;\u0026lt; a[i][j] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[j == n - 1]; } } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; while (tt--) { test_case(); } } ","date":1659875914,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659875914,"objectID":"abaae27a5ddd5577e0bd0dc9ca81becf","permalink":"https://tgc54.com/zh/post/cf1713e/","publishdate":"2022-08-07T08:38:34-04:00","relpermalink":"/zh/post/cf1713e/","section":"zh","summary":"学习到了一种新的并查集用法","tags":["数据结构","贪心","并查集"],"title":"Codeforces Round #812 E - Cross Swapping题解","type":"zh"},{"authors":null,"categories":[],"content":"There is problem managing python version with your package manager. An easy solution is to use pyenv:\nInstall pyenv with your package manager. For MacOS, it’s brew install pyenv. Install desired python version: pyenv install \u0026lt;version\u0026gt; Set global python version pyenv global \u0026lt;version\u0026gt; Set up your shell environment for Pyenv, for zsh, add this to your .zshrc: export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34; command -v pyenv \u0026gt;/dev/null || export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34; eval \u0026#34;$(pyenv init -)\u0026#34; ","date":1658544335,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658544335,"objectID":"69807e372c83d163840d800fba09da6f","permalink":"https://tgc54.com/post/manage-python-with-pyenv/","publishdate":"2022-07-22T22:45:35-04:00","relpermalink":"/post/manage-python-with-pyenv/","section":"post","summary":"There is problem managing python version with your package manager. An easy solution is to use pyenv:\nInstall pyenv with your package manager. For MacOS, it’s brew install pyenv. Install desired python version: pyenv install \u003cversion\u003e Set global python version pyenv global \u003cversion\u003e Set up your shell environment for Pyenv, for zsh, add this to your .","tags":[],"title":"Manage Python Version With Pyenv","type":"post"},{"authors":null,"categories":[],"content":"","date":1658544335,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658544335,"objectID":"f462bef34480d6fd4187f14ca8b8c6d1","permalink":"https://tgc54.com/zh/post/manage-python-with-pyenv/","publishdate":"2022-07-22T22:45:35-04:00","relpermalink":"/zh/post/manage-python-with-pyenv/","section":"zh","summary":"","tags":[],"title":"Manage Python With Pyenv","type":"zh"},{"authors":null,"categories":[],"content":"As a competitive programmer, I always want to find a solution to avoid copy-and-pasting my algorithm library so I can write more complex code lol.\nInspired by Egor’s rust bundler, I wondered is there something similar for C++? I remembered that I read this long time ago then I spent some time finding that blog but it’s not a bundler and looks quite complicated. In the comment someone mentioned using the cpp command which does the preprocessing work. As you may know, #include is basically copy-and-paste so this actually sounds right, but the problem is that it also copies and pastes the standard library which is over 200k+ lines of code. So I dug a bit further to see if it’s possible to skip system header and found this, but it only works for clang which what I’m using so I didn’t look for a solution for gcc.\nThe command is:\nclang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc main.cpp \u0026gt; bundled.cpp Explanation:\n-E Only run the preprocessor -P Disable linemarker output in -E mode -nostdinc++ Disable standard #include directories for the C++ standard library -nobuiltininc Disable builtin #include directories (may not be needed) As #include of system header isn’t preserved, you can add the system headers using another command and I made a shell function to do that:\nexpand_cpp () { clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc $1 \u0026gt; bundled.cpp gsed -i \u0026#34;1s/^/#include \u0026lt;bits\\/stdc++.h\u0026gt;\\n/\u0026#34; bundled.cpp } ","date":1658497915,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658497915,"objectID":"2aaf534fcdf3f74676cef5dea201c42e","permalink":"https://tgc54.com/post/bundle-cpp-code/","publishdate":"2022-07-22T09:51:55-04:00","relpermalink":"/post/bundle-cpp-code/","section":"post","summary":"As a competitive programmer, I always want to find a solution to avoid copy-and-pasting my algorithm library so I can write more complex code lol.\nInspired by Egor’s rust bundler, I wondered is there something similar for C++?","tags":["Tricks"],"title":"Bundle C++ Code with Clang","type":"post"},{"authors":null,"categories":[],"content":"作为一名算法竞赛选手，我一直在寻找避免复制粘贴板子的方法，这样我就的板子库就能更加复杂。\n受Egor的rust bundler启发，我不禁想C++也有没有相似的东西? 于是想起来很久之前看过这个博客然后我就话了点时间又找到了那篇博文，但并不是bundler而且看起来很复杂。评论区里有人提到用cpp这个预处理命令。也许你知道，#include基本就是复制粘贴所以看起来好像有戏，但问题是预处理也会复制粘贴标准库，大概有20多万行。所以我继续搜寻能不能跳过系统头文件，然后就找到了这个，但只有clang才能用，因为我自己也用clang所以就没再找gcc的解决办法。\n命令如下\nclang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc main.cpp \u0026gt; bundled.cpp 解释：\n-E 只进行预处理 -P 关闭在预处理中生成行标记 -nostdinc++ 关闭C++标准库 -nobuiltininc 关闭内置的#include目录（不太知道什么意思，可能没用） 因为系统头文件不会被保留，所以需要另一条命令把体统头文件加上，然后我就写了一个shell函数一起做这两件事：\nexpand_cpp () { clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc $1 \u0026gt; bundled.cpp gsed -i \u0026#34;1s/^/#include \u0026lt;bits\\/stdc++.h\u0026gt;\\n/\u0026#34; bundled.cpp } ","date":1658497915,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658497915,"objectID":"ff0322e931f0e31b2a6d6a6c50b048de","permalink":"https://tgc54.com/zh/post/bundle-cpp-code/","publishdate":"2022-07-22T09:51:55-04:00","relpermalink":"/zh/post/bundle-cpp-code/","section":"zh","summary":"作为一名算法竞赛选手，我一直在寻找避免复制粘贴板子的方法，这","tags":["Tricks"],"title":"用Clang打包C++代码","type":"zh"},{"authors":null,"categories":["Tutorial"],"content":"If you are developing a simple static website like a blog or wiki, you probably don’t really like to play with a hosting service involving a remote repository like GitHub pages. Pushing to the remote repo every time you make changes and waiting for the building process is not that pleasant. With Cloudflare Workers/Pages, you can upload your website directly using Wrangler.\nInstallation Install Wrangler globally:\nnpm install -g wrangler Authentication There are two ways of authentication:\nIf you are using it on your own computer, you can use OAuth in your browser to login by running wrangler login. set CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID environmental variables. API token can be generated here for workers, you can use the “Edit Cloudflare Workers” template. for pages, follow the offical guice here. To find your account ID, log in to the Cloudflare dashboard \u0026gt; select your zone in Account Home \u0026gt; find your account ID in Overview under API on the right-side menu. Cloudflare Workers Cloudflare Worker is flexible and powerful. You can do much more than hosting website. You websites are stored in the KV storage.\nTo deploy your website:\ncopy wrangler.toml to your project directory. change bucket to your website directory, e.g. public folder for a hugo website. optionally, add route = \u0026#34;your-domain.com/*\u0026#34; to set custom domain/route for your website. create src folder and copy index.js in the src folder, run npm i @cloudflare/kv-asset-handler finally, back to the folder where you put wrangler.toml, run wrangler publish to deploy your website. Cloudflare Pages Cloudflare Pages is meant to replace the website hosting functionality of Workers. It supports lots of front-end framework so you can deploy your front-end application very easily. You can still upload locally with wrangler but it doesn’t work that well (it failed to upload my hugo blog).\nThe upload is pretty easy: simple run wrangler pages publish \u0026lt;directory\u0026gt; and follow the instruction.\n","date":1653138941,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1653138941,"objectID":"05d7e1cdaf88add45ffac425242b25cc","permalink":"https://tgc54.com/post/cloudflare-workers-and-pages/","publishdate":"2022-05-21T09:15:41-04:00","relpermalink":"/post/cloudflare-workers-and-pages/","section":"post","summary":"Cloudflare is the new contender in the hosting service.","tags":["cloudflare"],"title":"Fast Static Website Deployment with Cloudflare Workers and Pages","type":"post"},{"authors":[],"categories":["更新"],"content":"好久没写东西了，考试也基本完事了，大概说一下最近的一些变化，主要就两个：1. 博客换了个主题，主要是想吧portfolio和博客合并到一个网站上，而之前那个主题扩展性太差了，而且自己又不写前端代码，于是研究了其他各种解决方案。其实notion我还挺喜欢的，可惜不开源而且没法导出数据。Ghost看起来不错但又增加新的学习成本，而且感觉是用来做订阅服务的。最后还是决定继续hugo，wowchemy看起来不错，扩展性和定制性兼具。2. 前段时间弄了个wiki单独记录一些以后可能会经常查阅的东西，要是发在博客里就会分散在各个地方不方便检索。链接就在菜单栏上。\n","date":1650987722,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650987722,"objectID":"0c27541e57f65f14a679868f1050d68a","permalink":"https://tgc54.com/zh/post/update-2022-04-26/","publishdate":"2022-04-26T11:42:02-04:00","relpermalink":"/zh/post/update-2022-04-26/","section":"zh","summary":"好久没写东西了，考试也基本完事了，大概说一下最近的一些变化，","tags":[],"title":"一些更新","type":"zh"},{"authors":null,"categories":null,"content":"","date":1647388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647388800,"objectID":"3c6e89aadc48603546f328157d9e6db4","permalink":"https://tgc54.com/zh/project/mirai-cp/","publishdate":"2022-03-16T00:00:00Z","relpermalink":"/zh/project/mirai-cp/","section":"zh","summary":"围绕算法竞赛的Mirai QQ机器人插件。","tags":null,"title":"Mirai-CP","type":"zh"},{"authors":null,"categories":["LaTex"],"content":"如果是中文文档的话可以用ctex包：\n\\usepackage{ctex} \\setCJKmainfont{Source Han Sans SC} % 设置默认中文字体 \\setCJKfamilyfont{songti}{FZShuSong-Z01S} % 设置默认宋体字体 % 上面的songti也可以换成别的，默认定义了songti、heiti、fangsong \\begin{document} 使用默认字体 {\\heiti 使用特定字体} \\end{document} 如果只加入少量中文的话可以直接调用中文字体：\n\\usepackage{fontspec} \\newfontfamily{\\han}{Source Han Sans SC} \\begin{document} {\\han 中文} \\end{document} 附：macOS下“The font “KaitiSC” cannot be found.”解决方案\n详细情况请看原文, Monterey下执行\nsudo tlmgr conf texmf OSFONTDIR /System/Library/AssetsV2/com_apple_MobileAsset_Font7 ","date":1646527179,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646527179,"objectID":"403df443ad72ea0b8df6f79d5fb9f50c","permalink":"https://tgc54.com/zh/post/luatex-chinese-guide/","publishdate":"2022-03-05T19:39:39-05:00","relpermalink":"/zh/post/luatex-chinese-guide/","section":"zh","summary":"","tags":["LaTex"],"title":"在LuaTex/LuaLaTex使用中文，附Font KaitiSC not found.解决方法","type":"zh"},{"authors":null,"categories":["比赛题解"],"content":"A 输出$s/(n^2)$即可。\n代码\nB 红色的和要尽量大而且个数要尽量小，所以排序之后红色的是一段后缀、蓝色是一段前缀而且长度比红色大1。枚举红色的个数即可。\n代码\nC 由于$15!\u0026gt;10^{12}$，所以最多有15个阶乘数，我们可以枚举每个阶乘是否被用，然后剩下的数计算其二进制表示中1的个数。记得n是long long，所以要用__builtin_popcountll()。\n代码\nD 除了n=2的情况，两个good节点就不能相邻的，所以问题就转化成了树上最大独立集问题，用树上dp可以轻松解决： $dp_{u, choose}$代表 $u$的子树中最大独立集，其中choose为0或1代表u是否在独立集当中，转移为:\n$$\\begin{aligned} dp_{u,0}\u0026amp;=\\sum_{v\\in child(u)}\\max(dp_{v, 0}, dp_{v, 1})\\\\ dp_{u, 1}\u0026amp;=\\sum_{v\\in child(u)}dp_{v, 0} \\end{aligned}$$\n当然这个题还要最小化点权之和，所以还要记录$cost_{u, i}$在当$dp_{u,0}=dp_{u, 1}$的时候用。还要输出方案所以还得记录每个节点的儿子选或不选。\n代码\nE 重复的数只会发生在一个数以及它的幂中，所以我们每次处理一个数和它的所有幂，典型的容斥问题。\n代码\n大佬的polylog复杂度解法，n可以到$10^{15}$。（还没时间仔细研究）\n","date":1646519635,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646519635,"objectID":"acc072fd80ae488fcf6c9d2dad0056f5","permalink":"https://tgc54.com/zh/post/cf1646/","publishdate":"2022-03-05T17:33:55-05:00","relpermalink":"/zh/post/cf1646/","section":"zh","summary":"","tags":["题解"],"title":"Codeforces Round #774 (Div. 2) A-E 题解","type":"zh"},{"authors":null,"categories":["比赛题解"],"content":"差不多最后一年了，明年队友估计就都毕业了，看看能不能找到其他人吧，或者solo也行？\n总结 今年由于疫情依然不能去温莎线下比赛，但相比去年三人三机今天变成了更像线下的三人一机，不过是在各自学校比赛，但令人不能理解是的居然一点监控措施都没有，全凭自己自觉和教练监督。。。。可以理解为摆烂吧😂。我们队算是做到了遵循规则，除了多接了一个显示器用来看代码（自己电脑没法连机房的打印机），以及我还是用的自己的键盘（用40%配列太久了改不回来了）。\n排名有点出乎意料，考虑到队友忙于实习从不训练、我上了大三之后课程难度增加，只能靠每周cf维持一点做题量，这个排名已经很满意了，毕竟如果按NAC晋级规则按学校排名是第6，校排名要是第5的话总排名要第6，完全想peach😂。\n整场比赛还是比较流畅的，基本没有卡太长时间，A题作为比较简单的题卡了有点久，最后还是靠猜结论过的，F计算几何某队友到最后也没搞出来，不过没占用太多正常时间。时间再稍微多一点也许能搞搞I或者K，不过到最后也比有点累了，昨晚也只睡了5个半小时。\n题目 题目整体难度适中？比去年难一点，（读了的题）以思维题为主。除了J题摆烂出了最大子矩形原题，题目质量还可以？\nA 一开始wa是因为忘了考虑相加的转移。考虑加的话要遍历一遍整个dp数组，时间复杂度会变成$O(n^2)$，但其实也能过因为时间给了15s。。。（我tm写博客的时候才发现）。但貌似只要遍历前面一些数就行了，因为数大的时候乘肯定比加划算。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; dp(n + 1, 1e9); dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = i; for (int j = 1; j \u0026lt;= min(i / 2 + 1, 1000); j++) dp[i] = min(dp[i], dp[j] + dp[i - j]); string s = to_string(i); for (int j = 1; j \u0026lt; (int)size(s); j++) { string s1 = s.substr(0, j), s2 = s.substr(j); if (s2[0] == \u0026#39;0\u0026#39;) continue; dp[i] = min(dp[i], dp[stoi(s1)] + dp[stoi(s2)]); } for (int f = 2; f * f \u0026lt;= i; f++) { if (i % f == 0) { dp[i] = min(dp[i], dp[f] + dp[i / f]); } } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; } B 赛时无脑敲了个lca，但其实稍微再想想就有更简单的做法：dfs时维护到根节点的距离以及最短的两条到叶子的路径的举例即可。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); vector\u0026lt;int\u0026gt; a(n); for (auto \u0026amp;x : a) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; indeg(n), sum(n), color(n); for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; g[u].push_back(v); indeg[v]++; } int c = 0; int ans = 1e9; auto dfs = [\u0026amp;](auto \u0026amp;slf, int u, int s) -\u0026gt; int { sum[u] = s + a[u]; color[u] = c; int mn0 = 1e9, mn1 = 1e9; for (auto v : g[u]) { auto res = slf(slf, v, s + a[u]); if (res \u0026lt; mn1) mn1 = res; if (mn1 \u0026lt; mn0) swap(mn0, mn1); } ans = min(ans, mn0 + mn1 + sum[u]); return (mn0 == 1e9 ? 0 : mn0) + a[u]; }; for (int i = 0; i \u0026lt; n; i++) { if (indeg[i] == 0) { dfs(dfs, i, 0); c++; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (g[i].empty() \u0026amp;\u0026amp; g[j].empty()) { if (color[i] != color[j]) { ans = min(ans, sum[i] + sum[j]); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } G 签到题，枚举所有前缀以及交换顺序即可\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string a, b, c; char op, _; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; op \u0026gt;\u0026gt; b \u0026gt;\u0026gt; _ \u0026gt;\u0026gt; c; auto check = [\u0026amp;](string a_, string b_, string c_) { __int128 a = stoll(a_), b=stoll(b_), c = stoll(c_); if (op==\u0026#39;+\u0026#39;) return a+b==c; else return a*b==c; }; for (int i=1; i\u0026lt;(int)size(a); i++) { for (int j=1; j\u0026lt;(int)size(b); j++) { for (int k=1; k\u0026lt;(int)size(c); k++) { string a1=a.substr(0, i), a2=a.substr(0+i); string b1=b.substr(0, j), b2=b.substr(0+j); string c1=c.substr(0, k), c2=c.substr(0+k); vector\u0026lt;string\u0026gt; s = {a1, b1, c1}; sort(begin(s), end(s)); do { if (check(s[0]+a2, s[1]+b2, s[2]+c2)) { cout \u0026lt;\u0026lt; s[0]+a2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; op \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s[1]+b2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; s[2]+c2; exit(0); } } while (next_permutation(begin(s), end(s))); } } } } J 经典最大子矩阵，单调栈搞搞即可。其实我赛时已经基本忘了怎么做了，只记得是是单调栈，想了半天才想出来正解，这下应该以后忘不了了233\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; //}}} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a[i]; } stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; stk; ll ans = 0; int s = 1e9, e = 0; auto update = [\u0026amp;](ll cur, int curs, int cure) { if (cur \u0026gt; ans || (cur == ans \u0026amp;\u0026amp; curs \u0026lt; s)) { ans = cur; s = curs; e = cure; } }; for (int i = 0; i \u0026lt; n; i++) { int prev = i; while (!stk.empty() \u0026amp;\u0026amp; stk.top().first \u0026gt;= a[i]) { prev = stk.top().second; ll cur = ll(i - prev) * stk.top().first; update(cur, prev, i - 1); stk.pop(); } ll cur = ll(i - prev + 1) * a[i]; update(cur, prev, i); stk.push({a[i], prev}); } while (!stk.empty()) { auto [x, i] = stk.top(); stk.pop(); ll cur = ll(n - i) * x; update(cur, i, n - 1); } cout \u0026lt;\u0026lt; s + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; e + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } L 枚举四个角然后排序分层搞一搞，队友写的\n代码 import collections import itertools import sys ints = lambda: list(map(int, sys.stdin.readline().split())) grid = [] gy, gx = ints() for y in range(gy): grid.append(ints()) statues = [] for row in grid: for cell in row: if ~cell: statues.append(cell) statues.sort() def levels(grid): ret1 = collections.defaultdict(set) ret2 = collections.defaultdict(set) for y in range(gy): for x in range(gx): cell = grid[y][x] if ~cell: ret1[y+x].add(cell) ret2[y-x].add(cell) return ret1, ret2 ret1, ret2 = levels(grid) keys1 = sorted(ret1.keys()) keys2 = sorted(ret2.keys()) import math moved = math.inf for keys, ret in (keys1, ret1), (reversed(keys1), ret1), (keys2, ret2), (reversed(keys2), ret2): this = len(statues) it = iter(statues) for key in keys: st = set() for _ in range(len(ret[key])): st.add(next(it)) this -= len(st \u0026amp; ret[key]) moved = min(moved, this) print(moved) M 最短路考虑用bfs，把所有字符串放入一个trie就可以很容易知道哪些方向可以走了，所以状态就是[x][y][trie中的节点的位置][上一步的方向]。除了状态复杂点其他就是正常bfs的套路，注意如果当前在单词结尾的位置，下一步即可以回到trie的根，又可以 …","date":1645927637,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645927637,"objectID":"9eee61fc25c9d2c597a15dd68a9e092b","permalink":"https://tgc54.com/zh/post/2021-ecna/","publishdate":"2022-02-26T21:07:17-05:00","relpermalink":"/zh/post/2021-ecna/","section":"zh","summary":"差不多最后一年了，明年队友估计就都毕业了，看看能不能找到其他人吧，或者solo也行？\n","tags":[],"title":"2021 ECNA区域赛总结与题解","type":"zh"},{"authors":null,"categories":["科技"],"content":"简单记录自己服务器的配置过程，方便需要时查看以及但愿对你有所帮助。\n服务器配置 整机 Intel NUC CPU i7-10710U 内存 16G 硬盘 500G西数蓝盘+1TB希捷机械 OS Ubuntu 20.04.4 LTS 通用 远程访问：端口转发，DDNS…\nSSL证书：\nhttps://www.youtube.com/watch?v=c1t_OrIia1U\nhttps://certbot.eff.org/instructions?ws=apache\u0026amp;os=ubuntufocal\n软件 Nextcloud 安装教程\n反向代理\nPi-hole 安装：使用官方安装脚本即可。注意：脚本有个bug，即使你已经装了其他web server（比如Apache）也要选择装lighttdp，否则重启服务的时候脚本会崩溃。。。（当你看到此的时候也许已经修复了）\n配置Apache以访问web UI\n一些黑名单：\nhttps://github.com/blocklistproject/Lists https://anti-ad.net/domains.txt Photoprism 安装\n反向代理，把http中的photoprism换成localhost\nRSSHub docker compose部署\nMiniflux docker compose部署\nNavidrome docker-compose\nqBittorrent(-nox) 在服务器由于没有xorg所以装的是nox版本\n[安装教程](https://github.com/qbittorrent/qBittorrent/wiki/Running-qBittorrent-without-X-server-(WebUI-only,-systemd-service-set-up,-Ubuntu-15.04-or-newer)\n不知道为啥用局域网也访问不到，一种解决办法是利用ssh建立通道（教程)，或者apache反向代理。\n","date":1645563342,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645563342,"objectID":"93c30f1048eb4f6ee21057b9e4b47937","permalink":"https://tgc54.com/zh/post/home-server-guide/","publishdate":"2022-02-22T15:55:42-05:00","relpermalink":"/zh/post/home-server-guide/","section":"zh","summary":"简单记录自己服务器的配置过程，方便需要时查看以及但愿对你有所帮助。\n","tags":["科技"],"title":"家庭服务器折腾记录","type":"zh"},{"authors":null,"categories":["题解"],"content":"有段时间没做难一点的思维题了\n思路 首先不难发现对于每个数来说，它的第一次和最后一次出现的位置是最重要的，因为使用其他位置的操作都可以使用两端的位置完成而且中间的位置的c值可以被两端变成1。我们将每个数$i$的第一次和最后一次位置记作$l_i, r_i$，于是我们就可以将每个数表示成一个线段 $[l_i, r_i]$。\n对于一个线段的集合$S$，如果这些线段的并集等于线段$[\\min(l_i), \\max(r_i)]$，我们称$S$是连通的。 对于所有线段我们可以将其划分为极大连通子集对于每个子集其互不影响所以最终的答案就是每个子集的答案之和。\n对于每个极大子集$S$，我们可能找到其最小子集$S’\\subseteq S$使得$S’$中的线段的并等于 $S$中线段的并，这样我们可以将尽量多的线段的端点的c值变成1.对于 $S’$中的线段我们可以证明最多可以将 $|S’|-1$个位置的c值变成1。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; l(n, n), r(n, -1); for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; x--; l[x] = min(l[x], i); r[x] = max(r[x], i); } vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; b, c; for (int i = 0; i \u0026lt; n; i++) { if (l[i] \u0026lt; r[i]) b.emplace_back(l[i], r[i]); } sort(begin(b), end(b)); for (auto [l, r] : b) { // 去除在包含在其他线段之内的线段 if (c.empty() || r \u0026gt; c.back().second) c.emplace_back(l, r); } int ans = 0, last = -1; int m = size(c); for (int i = 0; i \u0026lt; m; i++) { if (c[i].first \u0026gt; last) { // 新的子集的第一个线段，端点的c值无法变成1 ans += c[i].second - c[i].first - 1; last = c[i].second; } else if (i == m - 1 || c[i + 1].first \u0026gt; last) { // 子集中的其他线段，左端点c值会变成1，会在之前被记入答案 ans += c[i].second - last - 1; last = c[i].second; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","date":1643473246,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643473246,"objectID":"b1eba545e8caa15522332f078054af21","permalink":"https://tgc54.com/zh/post/cf1630c/","publishdate":"2022-01-29T11:20:46-05:00","relpermalink":"/zh/post/cf1630c/","section":"zh","summary":"有段时间没做难一点的思维题了\n","tags":["思维"],"title":"Codeforces Round #768 Div1C/Div2E Paint the Middle题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"题解 本题要求的是在某一时刻前k小的优先级的和，所以我们不妨以优先级（要先离散化）为下标建立可持久化线段树（主席树），也就是说从任一根节点出发得到的是某一时刻正在运行的所有任务。这样一个任务可以被拆分成两个事件：\n在S秒时加入正在运行的任务的集合（也就是在主席树上对应的优先级上+1） 在E+1秒时从正在运行的任务的集合中移除（也就是在主席树上对应的优先级上-1） 我们把所有事件按时间顺序排序并依次更新主席树，并记录对于每个时刻，该时刻前最新版本的线段树的根节点，查询时就从该根节点出发。\n线段树要维护两个信息，一个是区间内正在运行任务的数量，一个是正在运行的任务的优先级之和。\n值得注意的是查询的是单一时刻的信息，不像求区间第k小时要两个区间信息相减，所以写起来也简单一点。\n一个非常容易错的地方是查询是当走到叶子节点时，如果该优先级的任务数量大于当前的k值，不能直接加上叶子节点中的优先级之和，要先除以任务数量再乘k值。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; struct PST { int n, tot = 0; struct node { int lc, rc, cnt; ll sum; }; vector\u0026lt;node\u0026gt; t; vector\u0026lt;int\u0026gt; roots; // left child, right child PST(int n_) : n(n_), t(n \u0026lt;\u0026lt; 6), roots(1) { build(0, n - 1, roots[0]); } #define lc(rt) t[rt].lc #define rc(rt) t[rt].rc void pushup(int rt) { t[rt].sum = t[lc(rt)].sum + t[rc(rt)].sum; t[rt].cnt = t[lc(rt)].cnt + t[rc(rt)].cnt; } void build(int l, int r, int \u0026amp;rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc(rt)); build(mid + 1, r, rc(rt)); pushup(rt); } void update(int pos, int dcnt, int dsum, int l, int r, int old, int \u0026amp;rt) { rt = ++tot; t[rt] = t[old]; if (l == r) { t[rt].cnt = t[old].cnt + dcnt; t[rt].sum = t[old].sum + dsum; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, dcnt, dsum, l, mid, lc(old), lc(rt)); else update(pos, dcnt, dsum, mid + 1, r, rc(old), rc(rt)); pushup(rt); } int update(int pos, int dcnt, int dsum) { // return the root of the new version int new_root; update(pos, dcnt, dsum, 0, n - 1, roots.back(), new_root); roots.push_back(new_root); return new_root; } ll query(int v, int l, int r, int k) { if (l == r) return (t[v].cnt \u0026gt; k ? t[v].sum / t[v].cnt * k : t[v].sum); int mid = (l + r) / 2, x = t[lc(v)].cnt; ll sum = t[lc(v)].sum; if (k \u0026lt;= x) return query(lc(v), l, mid, k); return sum + query(rc(v), mid + 1, r, k - x); } ll query(int v, int k) { return query(v, 0, n - 1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; tasks(n); vector\u0026lt;int\u0026gt; p; // 所有的优先级，用于离散化 for (auto \u0026amp;[s, e, pp] : tasks) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; pp; p.push_back(pp); } sort(begin(p), end(p)); p.erase(unique(begin(p), end(p)), end(p)); // 离散化 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; events; for (auto [s, e, pp] : tasks) { int id = lower_bound(begin(p), end(p), pp) - begin(p); // 两个事件，用优先级的正负来表示加入或者删除 events.emplace_back(s, id + 1); events.emplace_back(e + 1, -id - 1); } sort(begin(events), end(events)); PST tr(size(p)); vector\u0026lt;int\u0026gt; roots(n + 1); // root[i]代表i时刻前最新的线段树的版本 roots[0] = 1; for (auto [time, id] : events) { if (id \u0026gt; 0) { roots[time] = (tr.update(id - 1, 1, p[id - 1])); } else { id = -id - 1; roots[time] = (tr.update(id, -1, -p[id])); } } for (int i = 1; i \u0026lt;= n; i++) // 对于没有事件发生的时刻i，其最新的版本为上一时刻的最新版本 if (!roots[i]) roots[i] = roots[i - 1]; ll pre = 1; while (q--) { int x, a, b, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; auto k = 1 + (a * pre + b) % c; auto res = tr.query(roots[x], k); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pre = res; } } ","date":1642777956,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1642777956,"objectID":"9774ea1f599280f3f1bdcfb304339423","permalink":"https://tgc54.com/zh/post/loj2097/","publishdate":"2022-01-21T10:12:36-05:00","relpermalink":"/zh/post/loj2097/","section":"zh","summary":"","tags":["数据结构","可持久化线段树","主席树"],"title":"「CQOI2015」任务查询系统题解","type":"zh"},{"authors":null,"categories":[],"content":"用PB_DS实现一个只能单点修改的线段树，但又能动态插入和删除，现场赛的时候在对时间要求不大的情况下可以节约敲代码时间。\n原理 原理就是PB_DS里的tree的最后一个模板参数定义了节点如何更新，我们可以通过自定义类让节点维护额外的信息（子树大小之类的）。需要定义额外信息类为metadata_type，然后重载括号运算符来定义节点如何合并。通过树分裂实现区间查询，但有个问题就是分裂之后的树的大小是通过std::distance()来计算的，对于tree的迭代器来说时间复杂度是$O(n)$的，所以我们还要重载 $std::distance$\n例子：RMQ #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; struct Node { int size, min; }; template\u0026lt;typename node_const_iterator, typename node_iterator, typename cmp_fn, typename _Alloc\u0026gt; struct tree_max { typedef Node metadata_type; inline void operator() (node_iterator it, node_const_iterator null) const { auto\u0026amp; n = (Node\u0026amp;)it.get_metadata(); n.size=1; n.min=(*it)-\u0026gt;second; for (auto\u0026amp; c : {it.get_l_child(), it.get_r_child()}) { if (c != null) { n.size+=c.get_metadata().size; n.min=min(n.min, c.get_metadata().min); } } } }; using Tree = __gnu_pbds::tree\u0026lt;int, int, std::less\u0026lt;int\u0026gt;, __gnu_pbds::splay_tree_tag, tree_max\u0026gt;; using ti = Tree::iterator; Tree *other; namespace std { template\u0026lt;\u0026gt; iterator_traits\u0026lt;ti\u0026gt;::difference_type distance\u0026lt;ti\u0026gt;(ti a, ti b) { return other-\u0026gt;node_begin().get_metadata().size; } } void split(Tree\u0026amp; a, Tree\u0026amp; b, int x) { other = \u0026amp;b; a.split(x, b); } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; Tree tr; for (int i=0; i\u0026lt;n; i++) { int x; cin \u0026gt;\u0026gt; x; tr.insert({i, x}); } while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; Tree B, C; split(tr, C, r-1); split(tr, B, l-1); cout \u0026lt;\u0026lt; B.node_begin().get_metadata().min\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; tr.join(B); tr.join(C); } } 非分裂做法 对于可逆的信息（如区间和）我们可以通过在树上行走获得前缀信息，然后通过前个前缀信息得到区间信息。目前先贴个别人的链接，还没研究如何写的短点。\n","date":1641696535,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641696535,"objectID":"eb105ebc12b8bbe6e64f71fb2e29df50","permalink":"https://tgc54.com/zh/post/pb_ds-segment-tree/","publishdate":"2022-01-08T21:48:55-05:00","relpermalink":"/zh/post/pb_ds-segment-tree/","section":"zh","summary":"用PB_DS实现一个只能单点修改的线段树，但又能动态插入和删除，现场赛的时候在对时间要求不大的情况下可以节约敲代码时间。\n","tags":[],"title":"用PB_DS实现简单线段树","type":"zh"},{"authors":null,"categories":["题解"],"content":"一种比官方题解简单一点的做法\n前置知识 确保你已经知道D1的做法\n题解 由于我们已经知道了区间长度为偶数的时候最多只用去掉两个数而长度为奇数的时候要去掉一个数，所以对于区间长度为偶数的询问，我们可以去掉最后一个数从而将其转化为长度为奇数的询问，所以我们只要考虑如何求长度为奇数的询问即可。\n首先还是像D1一样求出前缀和，将$l\\dots r$的区间和记作 $S_{l, r}$。不难得出去掉一个数之后区间和会变成$S_{l, i-1}-S_{i+1, r}$。 我们想使其为0，所以要找到一个$i$使得$S_{l, i-1}=S_{i+1, r}$。将等式做如下变换： $$\\begin{align*} S_{l, i-1}\u0026amp;=S_{i+1, r}\\\\ S_{0, i-1}-S_{0, l-1} \u0026amp;= S_{0, r} - S_{0, i}\\\\ S_{0, i-1} + S_{0, i} \u0026amp;= S_{0, r} + S_{0, l-1} \\end{align*}$$\n所以我们可以提用所有$i$的 $S_{0, i-1}+S_{0, i}$的值构建反查表（即给出$S_{0, i-1}+S_{0, i}$的值查询符合条件的$i$）。这样就可以做到 $O(\\log n)$回答询问了（log来自于在反查表中二分）。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void test_case() { int n, q; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; ps(n + 1); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(4 * n + 1); for (int i = 0; i \u0026lt; n; i++) { int x = (s[i] == \u0026#39;+\u0026#39; ? 1 : -1); ps[i + 1] = ps[i] + (i % 2 ? -x : x); } const int OFFSET = 2 * n; for (int i = 1; i \u0026lt;= n; i++) { pos[ps[i] + ps[i - 1] + OFFSET].push_back(i); } auto solve = [\u0026amp;](int l, int r) { int x = ps[l] + ps[r] + OFFSET; auto it = lower_bound(pos[x].begin(), pos[x].end(), l + 1); assert(it != end(pos[x]) \u0026amp;\u0026amp; *it \u0026lt;= r); return *it; }; while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--; if (ps[r] - ps[l] == 0) { cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; } else { if ((r - l) % 2) cout \u0026lt;\u0026lt; \u0026#34;1\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;2\\n\u0026#34; \u0026lt;\u0026lt; r-- \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; solve(l, r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; while (tt--) { test_case(); } } ","date":1640543778,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640543778,"objectID":"a6addc398ed772d3f8ae93cbc438707b","permalink":"https://tgc54.com/zh/post/cf1562d2/","publishdate":"2021-12-26T11:36:18-07:00","relpermalink":"/zh/post/cf1562d2/","section":"zh","summary":"一种比官方题解简单一点的做法\n","tags":["前缀和"],"title":"Codeforces Round #741 D2(1562D2) - Two Hundred Twenty One (hard version) 题解","type":"zh"},{"authors":null,"categories":null,"content":"","date":1636848e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636848e3,"objectID":"d1b0dedd39fb4ecd52ce4aafef17a672","permalink":"https://tgc54.com/zh/project/cp-parser/","publishdate":"2021-11-14T00:00:00Z","relpermalink":"/zh/project/cp-parser/","section":"zh","summary":"用命令行获取各种算法竞赛网站的样例","tags":null,"title":"Competitive Programming Parser","type":"zh"},{"authors":null,"categories":["键盘"],"content":"一篇如何用两个pro micro当作ISP(In-System Programmer)互相给对方刷上DFU bootloader.\n众所周知，一般pro micro自带的bootloader是caterina，有一个比较烦人的缺点就是一次reset之后只有8秒的时间在dfu模式里。而dfu bootloader就不会有这个问题。\n免责声明 本人并不是学电子专业的，只是以一个客制化键盘爱好者的角度写的此教程，如有不慎或意外可能会导致pro micro变砖。纯小白请谨慎考虑。本文如有错误欢迎指正。\n工具 软件 Arduino IDE QMK toolbox bootloader文件 硬件 两个 pro micro，6根导线\n步骤 给两个pro micro刷bootloader的步骤稍有不同\n给第一个pro micro刷 打开Arduino IDE, Tools -\u0026gt; Arduino Leonardo, Tools -\u0026gt; Port 并记住端口号，File -\u0026gt; Examples -\u0026gt; ArduinoISP -\u0026gt; ArduinoISP 然后点upload，这样一个pro micro就变成了ISP。 接线： 每行左右两侧脚位相连:\nISP 目标 VCC VCC GND GND SCLK SCLK MISO MISO MOSI MOSI 10 RST 刷入 Win+R然后输入cmd打开命令行，然后进到QMK Toolbox的目录，用到的程序在这个目录里。下面的0.x.x要换成你QMK Toolbox 的版本号(写这个教程时最新的版本为0.1.1)，所以不要直接复制粘贴。\ncd AppData\\Local\\QMK\\QMK Toolbox\\0.x.x\\ 然后运行刷入的命令，其中\u0026lt;PORT\u0026gt;换成第一步中的端口号，\u0026lt;PATH\u0026gt;换成bootloader文件的地址\navrdude.exe -c arduino -p atmega32u4 -P \u0026lt;PORT\u0026gt; -U flash:w:\u0026#34;\u0026lt;PATH\u0026gt;\u0026#34;:a -U hfuse:w:0xD9:m -U efuse:w:0xC3:m -U lock:w:0x3F:m 如果运行成功的话你就成功将dfu bootloader刷到pro micro上了。\n给另一个pro micro刷 由于arduino不支持dfu，所以我们需要用另一个程序dfu-programmer（也在QMK Toolbox的目录下）来将刷入dfu的那个pro micro再变成ISP。首先要找到ArduinoISP编译后的hex文件:AppData\\Local\\Temp\\arduino_build_xxxxxx\\ArduinoISP.ino.hex(xxxxxx是一串数字，每个人的不一样)。接下来就准备刷入了，还是在QMK Toolbox的目录下，执行下面3条命令：(其中换成刚才提到的ArduinoISP.ino.hex的路径)\ndfu-programmer.exe atmega32u4 erase dfu-programmer.exe atmega32u4 flash \u0026lt;PATH\u0026gt; dfu-programmer.exe atmega32u4 reset 最后再重复上一个部分的2、3步即可。\n参考资料 https://www.reddit.com/r/olkb/comments/9ctx37/qmk_burn_dfu_bootloader_into_keyboard_with/ https://www.reddit.com/r/olkb/comments/8sxgzb/replace_pro_micro_bootloader_with_qmk_dfu/\n","date":1634102269,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1634102269,"objectID":"ee2f69d619a0bc2910231729caba92e1","permalink":"https://tgc54.com/zh/post/pro-micro-dfu-bootloader/","publishdate":"2021-10-12T23:17:49-06:00","relpermalink":"/zh/post/pro-micro-dfu-bootloader/","section":"zh","summary":"一篇如何用两个pro micro当作ISP(In-System Programmer)互相给对方刷上DFU bootloader.\n","tags":["键盘","客制化"],"title":"用两个Pro Micro互相给对方刷上DFU bootloader","type":"zh"},{"authors":null,"categories":["题解"],"content":"从动态规划的角度考虑，很容易想到的一种状态是当前位置前$m$的字符的状态，但这样的状态数为$2^m$，显然不可行。不妨进一步想，当前字符串能对后面产生影响的只有与字符串 $b$的前缀匹配的部分， 所以状态可以被优化为当前字符串的后缀与$b$的前缀最大匹配长度。整个dp的状态$dp_{i, j, k}$为当前位置 $i$, $b$作为子串已经出现了 $j$次， 最长公共前后缀的长度为$k$。\n为了实现$O(1)$转移，我们还需要预处理对于$b$的所有后缀，在后面加0或者加1之后其后缀与$b$的前缀的最大匹配状态。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=500; short dp[N+1][N+1][N+1], nxt[N+1][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a=\u0026#39; \u0026#39;+a, b=\u0026#39; \u0026#39;+b; for (int i=0; i\u0026lt;=m; i++) { for (int x : {0, 1}) { string s=b.substr(1, i)+char(\u0026#39;0\u0026#39;+x); for (int j=min(m, (int)size(s)); j\u0026gt;=1; j--) { if (b.substr(1, j) == s.substr(size(s)-j)) { nxt[i][x]=j; break; } } } } auto ckmin=[](auto\u0026amp; a, auto b) { if (b\u0026lt;a) a=b; }; for (int i=0; i\u0026lt;=n; i++) for (int j=0; j\u0026lt;=n; j++) for (int k=0; k\u0026lt;=m; k++) dp[i][j][k]=20000; dp[0][0][0]=0; for (int i=0; i\u0026lt;n; i++) for (int j=0; j\u0026lt;=n; j++) for (int k=0; k\u0026lt;=m; k++) for (int x : {0, 1}) ckmin(dp[i+1][j+(nxt[k][x]==m)][nxt[k][x]], dp[i][j][k]+(a[i+1]!=\u0026#39;0\u0026#39;+x)); for (int i=0; i\u0026lt;=n-m+1; i++) { auto ans=*min_element(dp[n][i], dp[n][i]+m+1); cout \u0026lt;\u0026lt; (ans==20000 ? -1 : ans) \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n-m+1]; } } ","date":1634097019,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1634097019,"objectID":"81a64736522e1666d30ff1ee38b1eaf8","permalink":"https://tgc54.com/zh/post/cf1575h/","publishdate":"2021-10-12T21:50:19-06:00","relpermalink":"/zh/post/cf1575h/","section":"zh","summary":"","tags":["动态规划"],"title":"COMPFEST 13 - Finals H. Holiday Wall Ornaments 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"题目链接\n题解 首先，以下两点不难想到：\n我们只会在最大生成树的边上走，这样我们就把图变成了树。 对于所有边，最优策略永远是先吃树上一边的所有点然后再吃另一边。 由于宽度小的边会最先不满足条件，因此要优先考虑宽度小的边，但边两侧的连通块的情况还不知道，所以我们要先继续处理两侧的信息再确定吃的方向，而每侧的连通块中最窄的边又会把连通块一分为二……这样一直递归下去直到每个连通块只剩一个点。合并的顺序就是从宽边到窄边，这正好也是求最大生成树的顺序，于是可以在求最大生成树的同时维护答案。对于每个连通块，我们维护进入这个连通块时人的最大宽度$mx$。假设待合并的两个连通块为$u,v$，每个块的$c$值的和为$sum_u, sum_v$，$u,v$之间的边的宽度为$w$，从$u$到$v$要满足$mx_u+sum_u\\le mx_v$和$mx_u+sum_u\\le w$，变形一下就是$mx_u=\\min(mx_v, w)-sum_u$，也就是说如果先吃$u$再吃 $v$的话，进入合并之后的连通块时最大的宽度为 $\\min(mx_v, w)-sum_u$，先吃$v$再吃$u$的情况类似，取两种情况中宽度更大的情况。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(), (x).end() using ll = long long; constexpr ll INF = 1e18; struct UF { vector\u0026lt;int\u0026gt; fa, sz; vector\u0026lt;ll\u0026gt; mx, sum; UF(int n) : fa(n), sz(n, 1), mx(n, INF), sum(n) { iota(all(fa), 0); } int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } void join(int u, int v, ll w) { u = find(u), v = find(v); if (u == v) return; if (sz[u] \u0026gt; sz[v]) swap(u, v); ll fromV = -INF, fromU = -INF; if (sum[v] \u0026lt;= mx[u]) fromV = min(mx[u], w) - sum[v]; if (sum[u] \u0026lt;= mx[v]) fromU = min(mx[v], w) - sum[u]; mx[v] = max(fromU, fromV); sum[v] += sum[u]; fa[u] = v; sz[v] += sz[u]; return; } auto check() { return mx[find(0)]; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; edges(m); UF uf(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; uf.sum[i]; for (auto \u0026amp;[u, v, c] : edges) cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c, u--, v--; sort(begin(edges), end(edges), [\u0026amp;](auto\u0026amp; i, auto\u0026amp; j) { return i[2] \u0026gt; j[2]; }); for (auto \u0026amp;[u, v, c] : edges) uf.join(u, v, c); if (auto mx = uf.check(); mx \u0026lt; 1) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl; } ","date":1633138328,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633138328,"objectID":"4cfe32d9853a944bcdbb07d666ec63e8","permalink":"https://tgc54.com/zh/post/icpc-wf-2020-invitational-l/","publishdate":"2021-10-01T19:32:08-06:00","relpermalink":"/zh/post/icpc-wf-2020-invitational-l/","section":"zh","summary":"","tags":["图论","最大生成树","贪心"],"title":"ICPC WF Moscow Invitational Contest L - Labyrinth 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"前置知识：霍尔定理（Hall’s Theorem) 也叫霍尔结婚定理(Hall’s marriage theorem)。在二分图中，令两部分点集分别为$X, Y$, 则存在$X-$完美匹配（$X$中的点集全部被匹配）的充分必要条件是:对于$X$的任意子集$W$,$|W|\\le|\\Gamma(W)|$，其中$\\Gamma(W)$为与$W$直接相连的点的集合。\n题解 本题是让我们求最大匹配数，但直接跑匹配算法肯定不合适，此时我们考虑霍尔定理：假设所有人的集合为$X$,我们至少还需要$\\max_{W\\subseteq X}|W|-|\\Gamma(W)|$。但是$X$的子集的个数是指数级的所以不能直接考虑子集。\n但是我们发现$\\Gamma(X)$总是所有椅子的一个前缀加一个后缀，也就是$\\{i|i\\le l\\lor i\\ge r, l\u0026lt;r\\}$。于是我们可以考虑枚举$l, r$，那么椅子的集合所对应的人的集合$W$为$\\{i|l_i\\le l\\land r_i\\ge r\\}$,此时$|W|-|\\Gamma(W)|=|W| -(l+m-r+1)$。但很显然$(l, r)$的个数是$O(N^2)$的，还是太慢，不过这已经是一个很大的进步了。\n我们再想进一步优化，从小到大枚举$l$，通过某些数据结构直接求得所有$r$中的最大值：我们可以用线段树维护对于每一个$r$,$|W|-(m-r+1)$的最大值。对于每一个人的限制条件$L_i, R_i$，当我们枚举到$l\\ge L_i$时，如果选择的$r\\le R_i$的话，那么对应的人的集合就会包含$i$，反映到维护的值上去的话就是把区间$[l+1, R_i]$里的值+1。然后用$[l+1, m+1]$中的最大值减当前的$l$来更新答案。\n注意几点：\n按l从小到大的顺序可以保证前面的$L_i$都是符合条件的，只要考虑$r$的取值即可。 维护的值是把$l$除去的，因为我们只考虑 $r$的取值。 每个位置的$m-r+1$都是固定的，所以建树的时候就可以加进去。 特殊情况当$\\Gamma(X)$为整个椅子的集合时，$|X|-\\Gamma(X)=n-m$ 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; struct SegTree { int n, M; vector\u0026lt;T\u0026gt; t; SegTree(int n_, int _m) : n(n_), M(_m), t(4 * n) { build(1, 0, n - 1); } void pull(int node) { t[node] = t[node * 2] + t[node * 2 + 1]; } void build(int node, int l, int r) { if (l == r) { return t[node].apply(l, r, -M + r - 1); } int mid = (l + r) / 2; build(node * 2, l, mid); build(node * 2 + 1, mid + 1, r); pull(node); } void push(int p, int l, int r) { if (t[p].lazy) { int m = (l + r) / 2; t[p * 2].apply(l, m, t[p].lazy); t[p * 2 + 1].apply(m + 1, r, t[p].lazy); t[p].lazy = 0; } } void add(int node, int ql, int qr, int l, int r, int x) { if (r \u0026lt; ql || l \u0026gt; qr) return; if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node].apply(l, r, x); push(node, l, r); int mid = (l + r) / 2; add(node * 2, ql, qr, l, mid, x); add(node * 2 + 1, ql, qr, mid + 1, r, x); pull(node); } T get(int node, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node]; push(node, l, r); int mid = (l + r) / 2; if (qr \u0026lt;= mid) return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid); if (ql \u0026gt; mid) return get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid) + get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); } // wrapper void add(int l, int r, int x) { assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); add(1, l, r, 0, n - 1, x); } T get(int l, int r) { assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); return get(1, l, r, 0, n - 1); } }; struct node { int v = 0; // don\u0026#39;t forget to set default value (used for leaves), // not necessarily zero element int lazy = 0; void apply(int l, int r, int x) { lazy += x; v += x; } node operator+(const node \u0026amp;b) const { node res; res.v = max(v, b.v); return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; const int M = 200000; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; rs(M + 1); for (int i = 0; i \u0026lt; n; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; rs[l].push_back(r); } SegTree\u0026lt;node\u0026gt; tr(m + 2, m); int ans = n - m; for (int l = 0; l \u0026lt;= M \u0026amp;\u0026amp; l \u0026lt;= m - 1; l++) { for (auto r : rs[l]) { tr.add(l + 1, r, 1); } ans = max(ans, tr.get(l + 1, m + 1).v - l); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":1627489409,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1627489409,"objectID":"5a5997b8946cecccfaf71af1dba6a1f5","permalink":"https://tgc54.com/zh/post/arc076d/","publishdate":"2021-07-28T13:23:29-03:00","relpermalink":"/zh/post/arc076d/","section":"zh","summary":"","tags":["数据结构","线段树"],"title":"AtCoder Regular Contest (ARC) 076F - Exhausted? 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"题目链接\n首先我们要知道对于固定的数组如何求遍历轮数： 创建一个复制数组b，其中b[i]={a[i], i}，然后排序b，排序后b[i].second-i的最大值就是答案，b[i].second-i本质上就是一个数向前移动的距离，不难想出每个会向前移动的数从第一轮遍历就会开始向前移动，直到到达排序后的位置，所以最大的向前移动距离就是遍历的轮数。\n现在考虑修改原数组后，数组b以及b[i].second-i的值会有什么改变，不难发现其实就是删掉了{a[x], x}，然后再插入{v, x}（x与v的含义与题目相同），b数组中在老位置与新位置中间的元素会移动一位，所以他们的b[i].second-i会+1或者-1（由新老位置的关系而定），所以我们需要一个可以插入删除又能区间加的数据结构，并且支持查询全局最大值，那只能是平衡树了。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; auto seed=chrono::high_resolution_clock::now().time_since_epoch().count(); mt19937 gen(seed); template \u0026lt;typename T\u0026gt; struct Treap { struct node { int ch[2], sz; unsigned k; pair\u0026lt;int, int\u0026gt; d; T mx, lazy, dif; node(pair\u0026lt;int, int\u0026gt; d_, int dd, int z = 1) : sz(z), k((unsigned)gen()), d(d_), mx(dd), lazy(), dif(dd) { ch[0] = ch[1] = 0; } }; vector\u0026lt;node\u0026gt; nodes; int root=0, recyc=0; Treap(int size = 2e5) { nodes.reserve(size); nodes.emplace_back(pair{0, 0}, -1e9, 0); } inline int \u0026amp;ch(int rt, int r) { return nodes[rt].ch[r]; } int new_node(const pair\u0026lt;int, int\u0026gt; \u0026amp;d, int dd) { nodes.emplace_back(d, dd); return nodes.size()-1; } int pull(int rt) { node \u0026amp;n = nodes[rt]; n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz; n.mx = max({n.dif, nodes[n.ch[0]].mx, nodes[n.ch[1]].mx}); return rt; } void add(int rt, const T \u0026amp;d) { node \u0026amp;n = nodes[rt]; n.lazy += d; n.mx += d; n.dif+=d; } void pushdown(int rt) { node \u0026amp;n = nodes[rt]; if (n.lazy) { add(n.ch[0], n.lazy); add(n.ch[1], n.lazy); n.lazy = T(); } } int merge(int tl, int tr) { if (!tl) return tr; if (!tr) return tl; if (nodes[tl].k \u0026lt; nodes[tr].k) { pushdown(tl); ch(tl, 1) = merge(ch(tl, 1), tr); return pull(tl); } else { pushdown(tr); ch(tr, 0) = merge(tl, ch(tr, 0)); return pull(tr); } } void split(int rt, pair\u0026lt;int, int\u0026gt; k, int \u0026amp;x, int \u0026amp;y) { // split out element less than or equal to k if (!rt) { x = y = 0; return; } pushdown(rt); if (k \u0026lt; nodes[rt].d) { y = rt; split(ch(rt, 0), k, x, ch(rt, 0)); } else { x = rt; split(ch(rt, 1), k, ch(rt, 1), y); } pull(rt); } // interface void insert(pair\u0026lt;int, int\u0026gt; v, int d) { int rt = new_node(v, d); root = merge(root, rt); } void move_right(int old, int ne, int idx) { int a, b, c, d; split(root, {ne, idx}, c, d); split(c, {old, idx}, b, c); split(b, {old, idx-1}, a, b); if (c) add(c, 1); nodes[b]=node({ne, idx}, idx-(nodes[a].sz+nodes[c].sz)); root = merge(merge(merge(a, c), b), d); } void move_left(int old, int ne, int idx) { int a, b, c, d; split(root, {old, idx}, c, d); split(c, {old, idx-1}, b, c); split(b, {ne, idx}, a, b); if (b) add(b, -1); nodes[c]=node({ne, idx}, idx-(nodes[a].sz)); root=merge(merge(merge(a, c), b), d); } int query() { return nodes[root].mx; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;int\u0026gt; a(n); for (auto\u0026amp; x : a) cin\u0026gt;\u0026gt;x; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; b(n); for (int i=0; i\u0026lt;n; i++) { b[i]={a[i], i}; } sort(b.begin(), b.end()); Treap\u0026lt;int\u0026gt; tr; for (int i=0; i\u0026lt;n; i++) { tr.insert(b[i], b[i].second-i); } while (q--) { int x, v; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; if (a[x]\u0026lt;v) { // move right tr.move_right(a[x], v, x); } else { // move left tr.move_left(a[x], v, x); } a[x]=v; cout\u0026lt;\u0026lt;tr.query()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } ","date":1627173695,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1627173695,"objectID":"1481a3b101243db41c06985e7c5e9e25","permalink":"https://tgc54.com/zh/post/joioc18-bubblesort2/","publishdate":"2021-07-24T21:41:35-03:00","relpermalink":"/zh/post/joioc18-bubblesort2/","section":"zh","summary":"","tags":["数据结构","平衡树","treap"],"title":"JOI '18 Open P1 - Bubble Sort 2 题解","type":"zh"},{"authors":null,"categories":["教程"],"content":"rime输入法框架配置码表输入法的简单教程，以windows上小鹤音形为例。\n最近由于wayland有点受不了了，决定换成windows+wsl试试，虽说windows上有现成的小鹤音形，但相信大多数码表用户和我一样在标准词库上有所删减，所以需要一个输入法框架。用linux的时候久闻rime之大名，但并没有找到很好配置码表的教程，而官方文档有点长再加上是繁体写的读起来有点费事，遂决定记录一下自己配置的过程供大家参考。\n其实码表配置起来很简单，一共只需要两个文件：名为\u0026lt;name\u0026gt;.schema.yaml的方案定义文件和名为\u0026lt;name\u0026gt;.dict.yaml的码表文件。方案定义文件一般都有现成的，比如小鹤音形的在这(挂接第三方平台里)。码表格式要求看这，如果你像我一样之前是用fcitx格式的码表，可以很简单的用awk \u0026#39;{ OFS=\u0026#34;\\t\u0026#34;; print $2, $1 }\u0026#39; flypy_rime.txt \u0026gt; flypy.dict.yaml修改格式。然后将两个文件放入默认文件夹（windows上默认为%APPDATA%\\Rime），并修改build/default.yaml:在schema_list里加一行- schema: flypy。最后右键输入法图标点“重新部署”即可。\n","date":1626834697,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626834697,"objectID":"fb9451f314b7f00f1e7bf8949fd3c634","permalink":"https://tgc54.com/zh/post/rime-flypy/","publishdate":"2021-07-20T23:31:37-03:00","relpermalink":"/zh/post/rime-flypy/","section":"zh","summary":"rime输入法框架配置码表输入法的简单教程，以windows上小鹤音形为例。\n","tags":["小鹤音形","rime","输入法"],"title":"Rime配置码表输入法（以小鹤音形为例）","type":"zh"},{"authors":null,"categories":["题解"],"content":"方法一 一种简单的dp是令$dp_{i, j}$为将前$i$个数分成$j$个子数组的分法的个数。次转移要遍历$i$前的每个位置$k$然后前缀前缀和判断$sum_i-sum_k$是否是$j$的倍数，如果是的话就加上$dp_{k, j-1}$，所以转移是 $O(n)$的，总的复杂度是$O(n^3)$，会TLE，于是我们想如何优化。考虑到$$((sum_i-sum_k) \\bmod j =0)\\iff (sum_i\\equiv sum_k \\mod j)$$ 也许我们不用遍历所有的$k$，只要记录对于每个位置$k$, $sum_k\\bmod i=j$的$dp_{k, i-1}$的和就行了。于是我们的状态$dp_{i, j}$的定义就变成了在k位置结束的子数组,分成$i$个子数组并且$sum_k\\bmod i=j$的分法的个数。（说实话不是很好理解）\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt \u0026amp;x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt \u0026amp;x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt \u0026amp;x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt \u0026amp;x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt \u0026amp;operator+=(const ModInt \u0026amp;x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt \u0026amp;operator-=(const ModInt \u0026amp;x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt \u0026amp;operator*=(const ModInt \u0026amp;x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt \u0026amp;operator/=(const ModInt \u0026amp;x) { return *this *= x.inv(); } // compare bool operator==(const ModInt \u0026amp;b) const { return val == b.val; } bool operator!=(const ModInt \u0026amp;b) const { return val != b.val; } // I/O friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, ModInt \u0026amp;x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const ModInt \u0026amp;x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint = ModInt\u0026lt;int(1e9 + 7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n), sum(n + 1); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; sum[i + 1] = sum[i] + a[i]; } vector dp(n + 2, vector\u0026lt;mint\u0026gt;(n + 2)); dp[1][0] += 1; mint ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = n; j \u0026gt;= 1; j--) { dp[j + 1][sum[i + 1] % (j + 1)] += dp[j][sum[i + 1] % j]; if (i == n - 1) ans += dp[j][sum[n] % j]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 方法二 这种方法和方法一的出发点一样，但转移的时候我们只考虑最大的k,这是因为两个和为$j$的的倍数的子数组拼起来和依然是$j$的倍数，所以我们保持一开始的dp状态定义，然后用$O(n^2)$的时间预处理出$pre_{i, j}$，即对于每个位置$i$，其左边第一个位置使得$sum_{pre_{i, j}}\\equiv sum_{i}\\mod j$，转移时考虑两种情况：pre的位置被分成了$j$或$j-1$个子数组。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt \u0026amp;x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt \u0026amp;x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt \u0026amp;x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt \u0026amp;x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt \u0026amp;operator+=(const ModInt \u0026amp;x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt \u0026amp;operator-=(const ModInt \u0026amp;x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt \u0026amp;operator*=(const ModInt \u0026amp;x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt \u0026amp;operator/=(const ModInt \u0026amp;x) { return *this *= x.inv(); } // compare bool operator==(const ModInt \u0026amp;b) const { return val == b.val; } bool operator!=(const ModInt \u0026amp;b) const { return val != b.val; } // I/O friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, ModInt \u0026amp;x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const ModInt \u0026amp;x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint = ModInt\u0026lt;int(1e9 + 7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); for (auto \u0026amp;x : a) cin \u0026gt;\u0026gt; x; vector pre(n, vector(n + 1, -1)); vector last(n + 1, vector(n, -1)); ll sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += a[i]; for (int j = 1; j \u0026lt;= n; j++) { pre[i][j] = last[j][sum % j]; last[j][sum % j] = i; } } vector dp(n, vector\u0026lt;mint\u0026gt;(n + 1)); dp[0][1] = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= n; j++) { int p = pre[i][j]; if (p != -1) { dp[i][j] = dp[p][j] + dp[p][j - 1]; } } } cout \u0026lt;\u0026lt; accumulate(dp[n - 1].begin(), dp[n - 1].end(), mint()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":1625756675,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625756675,"objectID":"e5b1742510f68045db500473b4d76610","permalink":"https://tgc54.com/zh/post/abc207e/","publishdate":"2021-07-08T11:04:35-04:00","relpermalink":"/zh/post/abc207e/","section":"zh","summary":"","tags":["动态规划"],"title":"AtCoder Beginner Contest(ABC) 207E - Mod i题解","type":"zh"},{"authors":null,"categories":["算法笔记"],"content":"Tarjan的论文中指出\nLOWLINK(v) is the smallest vertex which is in the same component as v and is reachable by traversing zero or more tree arcs followed by at most one [back edge] or [cross edge].\n也就是说u的lowlink是在dfs树中u的子树中的节点经过最多一条返祖边（back edge,也叫反向边）能到达最低的dfs序。所以在dfs的时候对于已访问和未访问的节点要用不同的更新：对于未访问的节点v我们用low[u]=min(low[u], low[v])，对于访问过的节v点用low[u]=min(low[u], order[v])。但这样也许有一点麻烦，增加了记忆难度，一不小心也可能写错。\n如果我们稍微修改一下定义，忽略返祖边的数量限制，得到的算法依然是对的！因为我们只关心lowlink是否是u的祖先，至于哪个祖先无所谓。所以这种定义在保证正确性的同时简化了代码，可以考虑使用。代码见此\n","date":1625544250,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625544250,"objectID":"e72c7f887be7ab3eb6039a7c197d9b46","permalink":"https://tgc54.com/zh/post/tarjan-lowlink/","publishdate":"2021-07-06T00:04:10-04:00","relpermalink":"/zh/post/tarjan-lowlink/","section":"zh","summary":"","tags":["强连通分量","割点","桥"],"title":"关于Tarjan算法中的low link的另类定义与更新","type":"zh"},{"authors":null,"categories":["题解"],"content":"注：下文的regular bracket sequence 简写为RBS\n首先对于每个右括号，我们找到与其配对的左括号（也就是该右括号往左最短的RBS）的位置$l$（如果没有配对的就是-1），比如样例对应的位置就是\n下标 0 1 2 3 4 5 6 7 8 9 10 11 12 13 括号 ) ( ( ( ) ) ) ) ( ( ) ( ) ) $l$ -1 3 2 1 -1 9 11 8 $l$数组可以很容易的用一个栈求得。\n那么如何求最长的RBS呢？如果两个RBS相邻的话我们可以将他们合并为一个更长的RBS，于是我们可以再遍历一遍$l$数组并尝试扩展RBS的长度，我们便得到了以$i$结尾的最长的RBS，相应地更新答案即可。更新完之后的$l$数组如下：(好吧其实没什么变化)\n下标 0 1 2 3 4 5 6 7 8 9 10 11 12 13 括号 ) ( ( ( ) ) ) ) ( ( ) ( ) ) $l$ -1 3 2 1 -1 9 9 8 完整代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; int n = (int)s.size(); vector\u0026lt;int\u0026gt; l(n, -1); vector\u0026lt;int\u0026gt; stk; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;(\u0026#39;) stk.push_back(i); // 如果是左括号就入栈 else if (!stk.empty()) { // 否则就是右括号，如果栈非空就说明有对应的左括号 l[i] = stk.back(); stk.pop_back(); } } for (int i = 0; i \u0026lt; n; i++) { //如果当前RBS左边也有一个RBS就更新左端点 if (l[i] \u0026gt; 0 \u0026amp;\u0026amp; l[l[i] - 1] != -1) l[i] = l[l[i] - 1]; } int ans = 0, cnt = 1; for (int i = 0; i \u0026lt; n; i++) { if (l[i] == -1) continue; int len = i - l[i] + 1; if (len \u0026gt; ans) { ans = len; cnt = 1; } else if (len == ans) cnt++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":1625157699,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625157699,"objectID":"b0bb3ff9f59198bc70a430de32c01221","permalink":"https://tgc54.com/zh/post/cf5c/","publishdate":"2021-07-01T12:41:39-04:00","relpermalink":"/zh/post/cf5c/","section":"zh","summary":"","tags":["dp"],"title":"CodeForces 5C - Longest Regular Bracket Sequence 题解","type":"zh"},{"authors":null,"categories":["算法笔记"],"content":"不包括相同子串 后缀自动机中每一个路径都代表一个子串，所以第k小子串就对应第k小路径，所以我们可以先计算从每个状态开始有多少条路径，然后再根据k判断走哪条路径。计算路径的方法如下： $$path_u=1+\\sum_{v\\in next}path_v$$\n包括相同子串 由于标准的后缀自动机里是体现不出重复路径的信息的，所以我们要在上问的基础上维护每个状态代表的子串们出现的次数$occur$:\n$$occur_u=\\sum_{v\\in next}occur_v$$\n如何理解？当前状态的子串们都是下一个状态子串们的前缀，所以下一个状态的出现次数应当加到当前状态上。特别的，如果当前状态是终止状态，它的出现次数应为1。\n路径数的计算与前面类似： $$path_u=occur_u+\\sum_{v\\in next}path_v$$\n例题：[TJOI2015]弦论\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int t; struct SAM { struct state { int len = 0, link = -1; unordered_map\u0026lt;char, int\u0026gt; next; bool is_term; ll occur = 0, path_cnt=0; }; // the index of the equivalence class of the whole string int last = 0; vector\u0026lt;state\u0026gt; st; void extend(char c) { int cur = (int)st.size(); st.emplace_back(); st[cur].len = st[last].len + 1; int p = last; while (p != -1 \u0026amp;\u0026amp; !st[p].next.count(c)) { st[p].next[c] = cur; p = st[p].link; } if (p == -1) st[cur].link = 0; else { int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) { st[cur].link = q; } else { int clone = (int)st.size(); st.push_back(st[q]); st[clone].len = st[p].len + 1; while (p != -1 \u0026amp;\u0026amp; st[p].next[c] == q) { st[p].next[c] = clone; p = st[p].link; } st[q].link = st[cur].link = clone; } } last = cur; } SAM() { st.emplace_back(); } SAM(const string \u0026amp;s) : SAM() { for (auto c : s) extend(c); int p = last; while (p != 0) { st[p].is_term = true; p = st[p].link; } } void dfs(int i) { if (st[i].occur) return; if (st[i].is_term) st[i].occur++; for (auto [_, v] : st[i].next) { dfs(v); st[i].occur += st[v].occur; st[i].path_cnt += st[v].path_cnt; } st[i].path_cnt += t ? st[i].occur : 1; } string query(ll k) { string ans; int cur = 0; while (k \u0026gt; 0) { for (char c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) { if (!st[cur].next.count(c)) continue; auto \u0026amp;nxt = st[st[cur].next[c]]; if (nxt.path_cnt \u0026lt; k) k -= nxt.path_cnt; else { ans += c; cur = st[cur].next[c]; k -= t ? st[cur].occur : 1; break; } } } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; k; int len = (int)s.size(); SAM sa(s); sa.dfs(0); if (sa.st[0].path_cnt\u0026lt;k) cout\u0026lt;\u0026lt; -1 \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; sa.query(k); return 0; } ","date":1625150624,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625150624,"objectID":"a4a702bf1160719f42df1b20b4b0cb55","permalink":"https://tgc54.com/zh/post/k-th-smallest-substring/","publishdate":"2021-07-01T10:43:44-04:00","relpermalink":"/zh/post/k-th-smallest-substring/","section":"zh","summary":"","tags":["后缀自动机"],"title":"后缀自动机应用之求字典序第k小子串（包括与不包括相同子串）","type":"zh"},{"authors":null,"categories":["算法笔记","题解"],"content":"例题： Another Substring Query Problem\n由于次题中模式串有重复，会影响时间复杂度，所以我们要提前处理相同的字符串。下面的方法均假设无重复模式串。并以$n$为模式串的总长度，$m$为文本串的长度。\n方法一：字符串哈希 由于总长为$n$的模式串最多只有$O(\\sqrt{n})$种长度，所以我们可以遍历每种长度$l$然后遍历每个位置$i$然后判断从$i$开始长度为$l$的子串是否是模式串。时间复杂度为$O(\\sqrt{n}m)$。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using ull = unsigned long long; struct PolyHash { static constexpr int mod = (int)1e9 + 123; static vector\u0026lt;int\u0026gt; pow; static constexpr int base = 233; vector\u0026lt;int\u0026gt; pref; PolyHash(const string \u0026amp;s) : pref(s.size() + 1) { assert(base \u0026lt; mod); int n = (int)s.size(); while ((int)pow.size() \u0026lt;= n) { pow.push_back((ll)pow.back() * base % mod); } for (int i = 0; i \u0026lt; n; i++) { pref[i + 1] = ((ll)pref[i] * base + s[i]) % mod; } } int get_hash() { return pref.back(); } int substr(int pos, int len) { return (pref[pos + len] - (ll)pref[pos] * pow[len] % mod + mod) % mod; } }; vector\u0026lt;int\u0026gt; PolyHash::pow{1}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; int len = (int)s.size(); PolyHash ha(s); int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;string\u0026gt; qstr(q); vector\u0026lt;int\u0026gt; qk(q); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; lens(len + 1); vector\u0026lt;int\u0026gt; ans(q); for (int i = 0; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; qstr[i] \u0026gt;\u0026gt; qk[i]; if ((int)qstr[i].size() \u0026lt;= len) lens[qstr[i].size()].push_back(i); else ans[i] = -1; } for (int l = 1; l \u0026lt;= len; l++) { if (lens[l].empty()) continue; unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; mp, poss; for (auto i : lens[l]) { mp[PolyHash(qstr[i]).get_hash()].push_back(i); } for (int p = 0; p + l \u0026lt;= len; p++) { if (mp.count(ha.substr(p, l))) { poss[ha.substr(p, l)].push_back(p); } } for (auto \u0026amp;[h, v] : mp) { auto \u0026amp;pos = poss[h]; for (auto i : v) { if (pos.size() \u0026gt;= qk[i]) ans[i] = pos[qk[i] - 1] + 1; else ans[i] = -1; } } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 方法二：AC自动机 先将所有模式串加入AC自动机，然后再匹配文本串。注意AC自动机中要维护output link（沿fail link跳转时第一个模式串）。时间复杂度$O(n+m+m\\sqrt{n})$。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct AhoCorasick { enum { alpha = 26, first = \u0026#39;a\u0026#39; }; // change this! struct Node { // (nmatches is optional) int back, end = -1, nmatches = 0, output = -1; array\u0026lt;int, alpha\u0026gt; next; Node(int v = -1) { fill(next.begin(), next.end(), v); } }; vector\u0026lt;Node\u0026gt; N; AhoCorasick() : N(1) {} void insert(string \u0026amp;s, int j) { // j: id of string s assert(!s.empty()); int n = 0; for (char c : s) { int \u0026amp;m = N[n].next[c - first]; if (m == -1) { n = m = (int)N.size(); N.emplace_back(); } else n = m; } N[n].end = j; N[n].nmatches++; } void build() { N[0].back = (int)N.size(); N.emplace_back(0); queue\u0026lt;int\u0026gt; q; q.push(0); while (!q.empty()) { int n = q.front(); q.pop(); for (int i = 0; i \u0026lt; alpha; i++) { int pnx = N[N[n].back].next[i]; auto \u0026amp;nxt = N[N[n].next[i]]; if (N[n].next[i] == -1) N[n].next[i] = pnx; else { nxt.back = pnx; nxt.output = N[pnx].end == -1 ? N[pnx].output : pnx; q.push(N[n].next[i]); } } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; find(const string \u0026amp;text) { int n = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(text.size()); // ll count = 0; for (int i = 0; i \u0026lt; (int)text.size(); i++) { n = N[n].next[text[i] - first]; if (N[n].end != -1) { res[i].push_back(N[n].end); } for (int ind = N[n].output; ind != -1; ind = N[ind].output) { res[i].push_back(N[ind].end); } } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; AhoCorasick ac; int q; cin \u0026gt;\u0026gt; q; unordered_map\u0026lt;string, int\u0026gt; mp; vector\u0026lt;string\u0026gt; qstr(q); vector\u0026lt;int\u0026gt; qk(q), ans(q); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; same(q); for (int i = 0; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; qstr[i] \u0026gt;\u0026gt; qk[i]; if (!mp.count(qstr[i])) { mp[qstr[i]] = mp.size(); ac.insert(qstr[i], mp.size() - 1); } same[mp[qstr[i]]].push_back(i); } ac.build(); auto v = ac.find(s); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(mp.size()); for (int i = 0; i \u0026lt; (int)v.size(); i++) { for (auto p : v[i]) { pos[p].push_back(i); } } for (int i = 0; i \u0026lt; (int)mp.size(); i++) { for (auto qi : same[i]) { if (pos[i].size() \u0026gt;= qk[qi]) { ans[qi] = pos[i][qk[qi] - 1] - qstr[qi].size() + 2; } else { ans[qi] = -1; } } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 方法三：后缀数据结构 后缀数据结构也能是很擅长字符串匹配的，后缀树和后缀自动机都可以解决本题，由于没学过后缀树就只写后缀自动机的做法了：\n英文原文\n中文翻译\n注意后缀自动机是这三种做法中唯一可以在线处理询问的做法，处理单次询问的时间复杂度为$O(|s|+occurrence)$，occurrence为出现次数。整体时间复杂度$O(m+n+m\\sqrt{n})$。\n代码 #include \u0026lt;bits/extc++.h\u0026gt; using namespace std; struct SAM { struct state { int len = 0, link = -1; unordered_map\u0026lt;char, int\u0026gt; next; bool is_clone; int first_pos; vector\u0026lt;int\u0026gt; inv_link; }; int last = 0; // the index of the equivalence class of // the whole string vector\u0026lt;state\u0026gt; st; void extend(char c) { int cur = (int)st.size(); st.emplace_back(); st[cur].len = st[last].len + 1; st[cur].first_pos = st[cur].len - 1; int p = last; while (p != -1 \u0026amp;\u0026amp; !st[p].next.count(c)) { st[p].next[c] = cur; p = st[p].link; } if (p == -1) st[cur].link = 0; else { int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) { st[cur].link = q; } else { int clone = (int)st.size(); st.push_back(st[q]); st[clone].len = st[p].len + 1; st[clone].is_clone = true; while (p != -1 \u0026amp;\u0026amp; st[p].next[c] == q) { st[p].next[c] = clone; p = st[p].link; } st[q].link = st[cur].link = clone; } } last = cur; } SAM() …","date":1625005546,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625005546,"objectID":"4c622239e16c367177ed4ec882909ffa","permalink":"https://tgc54.com/zh/post/multi-pattern-matching/","publishdate":"2021-06-29T18:25:46-04:00","relpermalink":"/zh/post/multi-pattern-matching/","section":"zh","summary":"","tags":["哈希","AC自动机","后缀自动机"],"title":"多模式串匹配的3种方法","type":"zh"},{"authors":null,"categories":["题解"],"content":"很考验思维的一道题\n此题为North American Invitational Programming Contest (NAIPC) 2014 F题，题目链接。\n题意 给出一张图，每个顶点有$a_i$的金子，你要从顶点1沿最短路到顶点2，再沿任意路径返回。对于路径上的每个顶点，你可以选择抢劫他们的金子，但如果你抢了金子，返回的时候就不能经过这个顶点，问最多能抢多少金子。\n题解 由于n很小，可以考虑暴力枚举每一条最短路。我们不妨换个角度思考：去的时候先把路径上的金子都抢了，回来的时候再把经过的顶点的金子还回去。这样回去的路径就可以看作是最短路：如果经过在来的路径上的点花费就是$a_i$没，否则花费就是0.\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); for (int i = 2; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; g[u].push_back(v); g[v].push_back(u); } queue\u0026lt;int\u0026gt; q; q.push(0); vector\u0026lt;int\u0026gt; dep(n, -1); dep[0] = 0; while (!q.empty()) { auto u = q.front(); q.pop(); for (auto v : g[u]) { if (dep[v] == -1) { dep[v] = dep[u] + 1; q.push(v); } } } int ans = 0; vector\u0026lt;bool\u0026gt; vis(n); auto dijkstra = [\u0026amp;]() { vector\u0026lt;int\u0026gt; dis(n, -1); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; q; dis[0] = 0; q.emplace(0, 0); while (!q.empty()) { auto [d, u] = q.top(); q.pop(); if (d != dis[u]) continue; for (auto v : g[u]) { int nd = d + (vis[v] ? a[v] : 0); if (dis[v] == -1 || nd \u0026lt; dis[v]) { dis[v] = nd; q.emplace(nd, v); } } } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { if (vis[i]) sum += a[i]; } ans = max(ans, sum - dis[1]); }; auto dfs = [\u0026amp;](auto \u0026amp;me, int u) -\u0026gt; void { vis[u] = true; for (auto v : g[u]) { if (v == 1) dijkstra(); else if (dep[v] == dep[u] + 1 \u0026amp;\u0026amp; dep[v] \u0026lt; dep[1]) me(me, v); } vis[u] = false; }; dfs(dfs, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":1624494507,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1624494507,"objectID":"ff98692889fbd07b5886e1e2271b0af0","permalink":"https://tgc54.com/zh/post/kattis-goldbandits/","publishdate":"2021-06-23T20:28:27-04:00","relpermalink":"/zh/post/kattis-goldbandits/","section":"zh","summary":"很考验思维的一道题\n","tags":["BFS","最短路","图论"],"title":"NAIPC2014 F - Gold Bandits 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"This problem is North American Invitational Programming Contest (NAIPC) 2014 F，link to the problem。\nSolution As n is small, we can consider brute force each shortest path. Then let’s rephrase the problem: we first take the gold from all the village on the path to the castle, then we return it if we go through a village that we steal before when returning to home. Then finding the returning path becomes a shortest path problem: the cost of the vertex $i$ is $a_i$ if we steal it before, is 0 otherwise.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); for (int i = 2; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; g[u].push_back(v); g[v].push_back(u); } queue\u0026lt;int\u0026gt; q; q.push(0); vector\u0026lt;int\u0026gt; dep(n, -1); dep[0] = 0; while (!q.empty()) { auto u = q.front(); q.pop(); for (auto v : g[u]) { if (dep[v] == -1) { dep[v] = dep[u] + 1; q.push(v); } } } int ans = 0; vector\u0026lt;bool\u0026gt; vis(n); auto dijkstra = [\u0026amp;]() { vector\u0026lt;int\u0026gt; dis(n, -1); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; q; dis[0] = 0; q.emplace(0, 0); while (!q.empty()) { auto [d, u] = q.top(); q.pop(); if (d != dis[u]) continue; for (auto v : g[u]) { int nd = d + (vis[v] ? a[v] : 0); if (dis[v] == -1 || nd \u0026lt; dis[v]) { dis[v] = nd; q.emplace(nd, v); } } } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { if (vis[i]) sum += a[i]; } ans = max(ans, sum - dis[1]); }; auto dfs = [\u0026amp;](auto \u0026amp;me, int u) -\u0026gt; void { vis[u] = true; for (auto v : g[u]) { if (v == 1) dijkstra(); else if (dep[v] == dep[u] + 1 \u0026amp;\u0026amp; dep[v] \u0026lt; dep[1]) me(me, v); } vis[u] = false; }; dfs(dfs, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":1624494507,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1624494507,"objectID":"81c5f85d5da19f1f812f69539e7a3d8a","permalink":"https://tgc54.com/post/kattis-goldbandits/","publishdate":"2021-06-23T20:28:27-04:00","relpermalink":"/post/kattis-goldbandits/","section":"post","summary":"","tags":["BFS","Shortest Path","Graph Theory"],"title":"Solution to NAIPC2014 F - Gold Bandits","type":"post"},{"authors":null,"categories":["题解"],"content":"题目链接\n思路不难但线段树维护的内容需要一定的技巧。\n题解 首先我们看如何取l和r才能使得答案最大。如果$l=r=i$的话，$a_i$在正中间，如果加入一个小于等于$a_i$的数会让$a_i$往右偏，反之，加入大于等于的数会往左偏，所以设[l, r]中大于 $a_i$ 的数的个数为$x$，小于$a_i$的数的个数为$y$，（等于$a_i$的数可以算入$x$或$y$其中之一）我们要调整$l,r$找到 $x-y$的最大和最小值（分别对应$a_i$在最左和最右）, 此时的答案为$\\max(\\frac{x-y+1}{2}, \\frac{y-x}{2})$。由于$l, r$互相独立，所以我们可以分别看$[1, i], [i, n]$两个区间，找到$l\\in[1, i], r\\in [i, n]$, 使得$[l, i-1], [i+1, r]$中的$x-y$最大或最小。\n如果只找一个$a_i$的答案的话，可以非常轻松的用线段树解决。但是对于整个数组的答案就行不通了，对于处理大小关系的题目一种常用的技巧是将整个数组排序，从小到大进行处理，这样就能保证之前的数都比当前数小，处理起来就会简单很多。对于本题我们需要一个数组，其中大于$a_i$的位置设为$1$，小于 $a_i$的位置设为 $-1$，对于每个位置 $i$，我们只要找到$sum(l, i-1), l\\in [1, i]$与$sum(i+1, r), r\\in [i, n]$的最大值与最小值。由于我们是从小到大处理的所以每次只改动一个位置(将1变成-1)，这样数组就变得非常易于维护。\n维护数组的题我们很容易想到用线段树，但这题的询问比较特别，看似是区间最值但$sum$函数对于不同的i也会有不同的值。这里我们用到一种在最大子段和的递归实现中用到的技巧，即对于线段树中的每个区间，维护区间和，从左/右端点开始的最大/最小子段和mnl, mnr, mxl, mxr，用数学语言描述就是:令当前维护的区间是$[l, r]$\n$$\\begin{align*}mnl\u0026amp;=\\min_{l\\le i\\le r}(\\operatorname{sum}(l, i))\\\\ mnr\u0026amp;=\\min_{l\\le i\\le r}(\\operatorname{sum}(i, r))\\\\ mxl\u0026amp;=\\max_{l\\le i\\le r}(\\operatorname{sum}(l, i))\\\\ mxr\u0026amp;=\\max_{l\\le i\\le r}(\\operatorname{sum}(i, r))\\end{align*} $$\n了解了定义之后，如何合并区间也就很容易想到了（具体看代码），此外为了方便实现，我们在代码中允许最大/最小子段不包含任何数。还有，由于相等的数可以随意排列，所以既可以算作大的数又可以算作小的数，所以要询问两遍一次当作小的数，一次当作大的数。\n代码： #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; struct SegTree { int n; vector\u0026lt;T\u0026gt; t; SegTree(int n_) : n(n_), t(4 * n) { build(1, 0, n - 1, vector(n, T())); } template \u0026lt;typename U\u0026gt; SegTree(const vector\u0026lt;T\u0026gt; \u0026amp;v) : SegTree((int)v.size()) { build(1, 0, n - 1, v); } void pull(int node) { t[node] = t[node \u0026lt;\u0026lt; 1] + t[node \u0026lt;\u0026lt; 1 | 1]; } template \u0026lt;typename U\u0026gt; void build(int node, int l, int r, const vector\u0026lt;U\u0026gt; \u0026amp;v) { if (l == r) { t[node] = T(v[l]); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(node \u0026lt;\u0026lt; 1, l, mid, v); build(node \u0026lt;\u0026lt; 1 | 1, mid + 1, r, v); pull(node); } void set(int node, int i, T x, int l, int r) { if (l == r) { t[node] = x; return; } int mid = (l + r) / 2; if (i \u0026lt;= mid) set(node \u0026lt;\u0026lt; 1, i, x, l, mid); else set(node \u0026lt;\u0026lt; 1 | 1, i, x, mid + 1, r); pull(node); } T get(int node, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (qr \u0026lt;= mid) return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid); if (ql \u0026gt; mid) return get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid) + get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); } // wrapper void set(int i, T x) { assert(i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; n); set(1, i, x, 0, n - 1); } T get(int l, int r) { // assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); if (l \u0026gt; r) return T(); return get(1, l, r, 0, n - 1); } }; struct node { int sum = 0; int mxl = 0, mxr = 0, mnl = 0, mnr = 0; node(int x = 0) : sum(x), mxl(max(0, x)), mxr(mxl), mnl(min(0, x)), mnr(mnl) {} node(int a, int b, int c, int d, int e) : sum(a), mxl(b), mxr(c), mnl(d), mnr(e) {} node operator+(const node \u0026amp;b) const { return { sum + b.sum, max(mxl, sum + b.mxl), max(b.mxr, b.sum + mxr), min(mnl, sum + b.mnl), min(b.mnr, b.sum + mnr), }; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(n + 1); SegTree\u0026lt;node\u0026gt; st(n); for (int i = 0; i \u0026lt; n; i++) { st.set(i, node(1)); } for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; pos[x].push_back(i); } vector\u0026lt;int\u0026gt; ans(n); for (int i = 1; i \u0026lt;= n; i++) { for (auto p : pos[i]) { auto r = st.get(p + 1, n - 1); auto l = st.get(0, p - 1); ans[p] = max(ans[p], (r.mxl + l.mxr + 1) / 2); } for (auto p : pos[i]) st.set(p, node(-1)); for (auto p : pos[i]) { auto r = st.get(p + 1, n - 1); auto l = st.get(0, p - 1); ans[p] = max(ans[p], (-r.mnl - l.mnr) / 2); } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } ","date":1624201329,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1624201329,"objectID":"c01129d3bf6365cb5bed3c896a109666","permalink":"https://tgc54.com/zh/post/cf1539f/","publishdate":"2021-06-20T11:02:09-04:00","relpermalink":"/zh/post/cf1539f/","section":"zh","summary":"题目链接\n思路不难但线段树维护的内容需要一定的技巧。\n","tags":["数据结构","线段树"],"title":"CodeForces 1539F - Strange Array 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"当时有个细节没想到，直接fst\n首先不难证明最终的字符串一定是由s的一个前缀不断重复得到的。所以我们可以枚举前缀的位置i,如果从i开始重复能使得新字符串比原字符串小的话这个位置就是有利的，同时根据字典序的规则，i肯定是越靠前越好，于是我们就得到了策略：将$s_{i\\dots n}$与$s$比较，从比$s$大的中找出i最小的那个。我比赛的时候一看这不就是后缀数组嘛，过了pretest心里美滋滋，结果system test的时候： 那么问题出在哪了呢？我们来看这个例子$s=bab$。当$i=2$时，$s_{2\\dots 2}=b$是$s$的一个前缀，看似$b$比较小，但由于字符串是循环的所以补上一个$s$之后变为$bbab$就比s大了。所以这种情况也就是说$s$的某个后缀等于前缀，我们接下来说明扔掉这个后缀可以获得更好的答案：假设这个后缀的长度是$i$，$s$与$s_{0\\dots n-i-1}$循环一次后会在$s$与$s_{i\\dots n-1}$对应的位置发生不同，比如说$s=cbcacb$循环之后是这样的\n$$\\begin{align*}\u0026amp;cbcacb|\\underline{cbcacb} \\\\ \u0026amp;cbca|cb\\underline{ca} \\end{align*}$$\n其中竖线用来分隔循环，下划线是两个字符串开始不同的位置。可以证明$s\\ge s_{i\\dots n-1}$,因为如果小于的话，由于$i\u0026lt;n-i-1$，所以$i$就是更好的位置，也就用不到考虑后缀的情况了，因此我们说明了扔掉后缀一定是更好的选择，所以我们要想办法让后缀在后缀数组中排在$s$后面，于是我们可以在$s$后面加一个大于所有字母的字符，这样就保证了如果有后缀是s的前缀的情况，后缀一定排在s后面。这样我们就得到了用比较无脑的用后缀数组的做法：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; suffix_array(string s) { s += \u0026#34;#\u0026#34;; int n = s.size(), N = n + 256; vector\u0026lt;int\u0026gt; sa(n), ra(n); for (int i = 0; i \u0026lt; n; i++) sa[i] = i, ra[i] = s[i]; for (int k = 0; k \u0026lt; n; k ? k *= 2 : k++) { vector\u0026lt;int\u0026gt; nsa(sa), nra(n), cnt(N); for (int i = 0; i \u0026lt; n; i++) nsa[i] = (nsa[i] - k + n) % n; for (int i = 0; i \u0026lt; n; i++) cnt[ra[i]]++; for (int i = 1; i \u0026lt; N; i++) cnt[i] += cnt[i - 1]; for (int i = n - 1; i \u0026gt;= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i]; int r = 0; for (int i = 1; i \u0026lt; n; i++) { if (ra[sa[i]] != ra[sa[i - 1]]) r++; else if (ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n]) r++; nra[sa[i]] = r; } ra = nra; } sa.erase(sa.begin()); return sa; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; s += \u0026#39;|\u0026#39;; auto sa = suffix_array(s); int ii = find(sa.begin(), sa.end(), 0) - sa.begin(); int mn = *min_element(sa.begin() + ii + 1, sa.end()); for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; s[i % mn]; return 0; } 但是后缀数组有点杀鸡用牛刀了，我们其实只用和$s$做比较，所以另一种更简单的做法是用z函数，因为z函数求的是与整个字符串的最长公共前缀，所以比较前缀后下一个字符就能知道大小关系了。对于后缀的特殊情况，如果下一个字符的位置是$n$也就说明 $s_{i\\dots n-1}$是$s$的前缀，所以此时i的位置就是最佳位置。代码如下：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; z_function(const string \u0026amp;s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; auto z = z_function(s); for (int i = 1; i \u0026lt; n; i++) { int f = z[i]; if (f + i \u0026gt;= n || s[f] \u0026lt; s[f + i]) { s.erase(s.begin() + i, s.end()); break; } } for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; s[i % s.size()]; return 0; } ","date":1624113729,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1624113729,"objectID":"9333e489d9afdf95accbc70bf2415485","permalink":"https://tgc54.com/zh/post/cf1537e/","publishdate":"2021-06-19T10:42:09-04:00","relpermalink":"/zh/post/cf1537e/","section":"zh","summary":"当时有个细节没想到，直接fst\n","tags":["字符串","z函数","后缀数组"],"title":"CodeForces 1537E - Erase and Extend 题解","type":"zh"},{"authors":null,"categories":["算法笔记"],"content":"整体二分在国外称为parallel binary search，是一种用于同时解决大量二分搜索的离线算法。\n适用问题的描述 一种常见的类型是：给出多个修改与询问，每个询问有一个目标，问多少个修改之后目标可以达到。修改和询问需要满足以下性质：\n询问的答案可以二分（废话） 修改对目标的贡献互相独立 修改对目标的贡献与目标无关 当然不是所有问题都要严格符合这种形式，整体二分的本质就是将询问归类，一起处理归类在一起询问。\n思路 假设当前有一些询问的答案在某个区间中，我们将区间一分为二 应用某一些修改，这些修改是可以帮助我们判断答案在在哪一半区间的修改 判断这些询问是否达到目标，将询问分为达到目标和没达到目标两个集合，同时可能会修改没达到目标的询问的目标（这一步要具体问题具体分析） 撤销步骤2中的修改 分别递归左右两个区间 例题 多次询问数组第k小 正常的思路是对于每个询问二分一次。但我们也可以所有询问一起二分，根据左半部分的数的个数判断每个询问应该分到哪个集合中。\n核心代码如下(简洁起见没用离散化, query[i]是第i个询问的k值，sum(l, r)是在[l, r]区间中的数的个数)\nvoid solve(int l, int r, vector\u0026lt;int\u0026gt; id) { if (l==r || id.empty()) { for (auto i : id) ans[i]=l; return; } vector\u0026lt;int\u0026gt; less, more; int mid=(l+r)/2; for (auto i : id) { if (query[i]\u0026lt;=sum(l, mid)) less.push_back(i); else { query[i]-=sum(l, mid); more.push_back(i); } } solve(l, mid, less); solve(mid+1, r, more); } 静态数组区间第k小 题目链接\n这题的一般做法是在可持久化线段树（主席树）上二分，并且可以在线回答询问。整体二分思路有相似也有不同，假设目前询问的区间是$[ql, qr]$,答案在$[l, r]$中，令$mid=(l+r)/2$，此时我们新建一个和原数组一样长的辅助数组，将整个数组中在$[l, mid]$中的数在辅助数组中各自的位置上+1，然后查询位置在$[ql, qr]$中的数的个数（也就是辅助数组中$[ql, qr]$的区间和），与k做比较并由此判断再往哪个区间继续二分。\n这里要注意要是每次构建辅助数组的时候都扫过整个数组，时间会爆炸，所以我们可以像划分询问那样划分数组，这样添加的数都是在$[l, r]$中的数。\n关于划分的写法：\n常见的写法是用两个数组存左边和右边的询问，但其实可以直接利用std::partition或者std::stable_partition直接在原数组上划分，内存和时间上都更优（时间少10%左右，内存少30%左右），而且个人感觉写起来更简洁一些？后面所有题都有partition的写法，部分有数组的写法，选择自己喜欢的即可。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(),(x).end() constexpr int M=3e5; namespace fenwick { int n; int t[M]; using T=int; void update(int i, T x) { while (i \u0026lt; n) { t[i] += x; i |= (i + 1); } } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } template \u0026lt;typename U\u0026gt; U query(int l, int r) { return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } }; struct Num{ int x, i; }; struct Query { int l, r, k, id; }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;Num\u0026gt; a(n); vector\u0026lt;int\u0026gt; comp(n), aa(n); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;aa[i]; comp[i]=aa[i]; } sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (int i=0; i\u0026lt;n; i++) a[i]={static_cast\u0026lt;int\u0026gt;(lower_bound(all(comp), aa[i])-comp.begin()), i}; // 离散化 vector\u0026lt;Query\u0026gt; Q(q); for (int i=0; i\u0026lt;q; i++) { auto\u0026amp; [l, r, k, id]=Q[i]; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;k; id=i; l--, r--; } fenwick::n=n; vector\u0026lt;int\u0026gt; ans(q); // abegin 和 aend 是原数组中值在[l, r]中的数的区间， qbegin 和 qend是答案在[l, r]中的询问的区间 auto solve=[\u0026amp;](auto\u0026amp; solve, int l, int r, auto abegin, auto aend, auto qbegin, auto qend) { if (l==r || qbegin==qend) { for (auto it=qbegin; it!=qend; ++it) ans[it-\u0026gt;id]=l; return; } int mid=(l+r)/2; auto amid=partition(abegin, aend, [\u0026amp;](Num\u0026amp; x){ // 划分原数组，并更新树状数组 if (x.x\u0026lt;=mid) { fenwick::update(x.i, 1); return true; } return false; }); auto qmid=partition(qbegin, qend, [\u0026amp;](Query\u0026amp; q) { // 划分询问 int t=fenwick::query\u0026lt;int\u0026gt;(q.l, q.r); if (q.k\u0026lt;=t) return true; else { q.k-=t; return false; } }); for (auto it=abegin; it!=amid; ++it) fenwick::update(it-\u0026gt;i, -1); // 撤销之前的操作以清空树状数组 solve(solve, l, mid, abegin, amid, qbegin, qmid); solve(solve, mid+1, r, amid, aend, qmid, qend); }; solve(solve, 0, (int)comp.size(), a.begin(), a.end(), Q.begin(), Q.end()); for (auto x : ans) cout\u0026lt;\u0026lt;comp[x]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } 动态区间第k小 题目链接\n修改无非就是把原来的数删掉（在辅助数组中减1），再加上修改之后的数，和上一题大同小异。区别是由于有了时间顺序，不能像上一题先修改再询问了，要把修改和询问放在一个数组（其实上一题也能放在一个数组里，只是为了方便理解分成了两个数组），而且要用std::stable_partition以保证相对时间顺序不变。\n代码1（partition） #include \u0026lt;algorithm\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(), (x).end() constexpr int M = 3e5; int N; int t[M]; using T = int; void update(int i, T x) { while (i \u0026lt; N) { t[i] += x; i |= (i + 1); } } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } template \u0026lt;typename U\u0026gt; U query(int l, int r) { return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } struct op { int type; // if type==0, add j to position i, a[i]=k // if type==1, query k-th smallest element in [i, j], id is the index of the query int i, j, k, id; }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;op\u0026gt; ops; vector\u0026lt;int\u0026gt; comp, a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; comp.push_back(a[i]); ops.push_back({0, i, 1, a[i], -1}); } int qcnt = 0; for (int i = 0; i \u0026lt; q; i++) { char ch; cin \u0026gt;\u0026gt; ch; if (ch == \u0026#39;Q\u0026#39;) { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; ops.push_back({1, l - 1, r - 1, k, qcnt++}); } else { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--; ops.push_back({0, x, -1, a[x], -1}); comp.push_back(y); a[x] = y; ops.push_back({0, x, 1, y, -1}); } } // 离散化 sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (auto \u0026amp;[type, i, j, k, id] : ops) { if (type == 0) k = lower_bound(all(comp), k) - comp.begin(); } N = n; vector\u0026lt;int\u0026gt; ans(qcnt); auto solve = [\u0026amp;](auto \u0026amp;solve, int l, int r, auto begin, auto end) { if (l == r || begin == end) { for (auto it = begin; it != end; ++it) if (it-\u0026gt;type == 1) ans[it-\u0026gt;id] = l; return; } int mid = (l + r) / 2; // 因为要保证相对顺序不变所以要用stable_partition auto qmid = stable_partition(begin, end, [\u0026amp;](op \u0026amp;q) { auto \u0026amp;[type, i, j, k, id] = q; if (type == 1) { int cnt …","date":1622911019,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622911019,"objectID":"9cdf1524038ec0cec410eae0aad1b1e7","permalink":"https://tgc54.com/zh/post/parallel_bsearch/","publishdate":"2021-06-05T12:36:59-04:00","relpermalink":"/zh/post/parallel_bsearch/","section":"zh","summary":"整体二分在国外称为parallel binary search，是一种用于同时解决大量二分搜索的离线算法。\n","tags":["整体二分","离线技巧","二分"],"title":"整体二分学习笔记","type":"zh"},{"authors":null,"categories":["题解"],"content":"有点不知如何下手的题\n本文基本是照着这个翻译的。Pawn是国际象棋里的兵。\n由于只能往下走，我们从上到下一行一行的处理，维护本层能够到达 的位置。根据规则，有两种情况会使到达性发生改变：\n如果能到达上一行的i位置而本行的i位置有一个兵，那么本行的i位置就是不可达的。 如果上一行的i-1或i+1能到达的话而本行的i位置有一个兵，本行的i位置就是可达的。 由于第二种情况可以覆盖掉第一种情况（即如果i同时符合两种情况那他也是可达的），所以在我们记录不可达和可达的变化之后，先处理不可达的变化，再处理可达的变化。\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; p(m); for (auto \u0026amp;[x, y] : p) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; } sort(p.begin(), p.end()); set\u0026lt;int\u0026gt; s{n}; for (int l = 0, r = 0; l \u0026lt; m; l = r) { while (r \u0026lt; m \u0026amp;\u0026amp; p[l].first == p[r].first) r++; vector\u0026lt;int\u0026gt; rem, ins; for (int i = l; i \u0026lt; r; i++) { int y = p[i].second; rem.push_back(y); if (s.count(y - 1) || s.count(y + 1)) ins.push_back(y); } for (auto x : rem) s.erase(x); for (auto x : ins) s.insert(x); } cout \u0026lt;\u0026lt; s.size(); return 0; } ","date":1622909529,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622909529,"objectID":"b5da84a1387d7a8ada5a97a40fa6a43f","permalink":"https://tgc54.com/zh/post/abc203e/","publishdate":"2021-06-05T12:12:09-04:00","relpermalink":"/zh/post/abc203e/","section":"zh","summary":"有点不知如何下手的题\n","tags":[],"title":"AtCoder Beginner Contest (ABC) 203E 题解","type":"zh"},{"authors":null,"categories":["算法笔记"],"content":"子树相关的应用 由于子树的dfs序是连续的，所以很容易得到子树的信息。\n树上启发式合并 用于删掉轻子树的信息\nvector\u0026lt;int\u0026gt; bch(n, -1); int cur_big=-1; auto get_big = [\u0026amp;](auto \u0026amp;dfs, int u, int p) -\u0026gt; int { int sz = 1, mx = 0; for (auto v : g[u]) { if (v == p) continue; int csz = dfs(dfs, v, u); if (csz \u0026gt; mx) mx = csz, bch[u] = v; sz += csz; } return sz; }; auto add=[\u0026amp;](auto\u0026amp; slf, int u, int p, int x) -\u0026gt; void { // update info of u here for (auto v : g[u]) { if (v==p || v==cur_big) continue; slf(slf, v, u, x); } }; auto dfs = [\u0026amp;](auto \u0026amp;dfs, int u, int pa, bool keep) -\u0026gt; void { int big = bch[u]; for (auto v : g[u]) if (v != pa \u0026amp;\u0026amp; v != big) dfs(dfs, v, u, 0); if (big != -1) { dfs(dfs, big, u, 1); cur_big=big; } add(add, u, pa, 1); // now you get all the info of subtree of u, answer queries about u here. cur_big=-1; if (!keep) add(add, u, pa, -1); }; 利用二分查询子树信息 如果查询的信息是类似于子树中有多少个节点满足一定条件，比如：有多少个节点的颜色为x，此时我们可以为每个颜色开一个数组存，并且在dfs的时候将每个节点放入对应数组。由于子树的dfs序是连续的，在数组中的节点也是连续的，所以我们可以通过子树的根节点的进出时间戳，利用二分得到子树区间的长度。\n练习题：\nABC202 E\n代码 //#pragma GCC target(\u0026#34;avx,avx2,fma\u0026#34;) //#pragma GCC optimize(\u0026#34;unroll-loops,Ofast\u0026#34;) #include \u0026lt;algorithm\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; /*{{{*/ using namespace std; #ifdef LOCAL #include\u0026lt;pprint.hpp\u0026gt; // https://github.com/p-ranav/pprint pprint::PrettyPrinter P(cerr); #define de(...) P.compact(true);P.print(__VA_ARGS__) #define de_nc(...) P.compact(false);P.print(__VA_ARGS__) #else #define de(...) #define de_nc(...) #endif #define all(x) (x).begin(),(x).end() using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; inline namespace Traits { // is iterable template\u0026lt;typename T, typename = void\u0026gt; struct is_iterable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_iterable\u0026lt;T, void_t\u0026lt;decltype(begin(declval\u0026lt;T\u0026gt;())), decltype(end(declval\u0026lt;T\u0026gt;()))\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_iterable_v = is_iterable\u0026lt;T\u0026gt;::value; // is readable template\u0026lt;typename T, typename = void\u0026gt; struct is_readable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_readable\u0026lt;T, enable_if_t\u0026lt;is_same_v\u0026lt;decltype(cin \u0026gt;\u0026gt; declval\u0026lt;T\u0026amp;\u0026gt;()), istream\u0026amp;\u0026gt;\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_readable_v = is_readable\u0026lt;T\u0026gt;::value; // is printable template\u0026lt;typename T, typename = void\u0026gt; struct is_printable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_printable\u0026lt;T, enable_if_t\u0026lt;is_same_v\u0026lt;decltype(cout \u0026lt;\u0026lt; declval\u0026lt;T\u0026gt;()), ostream\u0026amp;\u0026gt;\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_printable_v = is_printable\u0026lt;T\u0026gt;::value; } inline namespace Input { template\u0026lt;typename T\u0026gt; constexpr bool needs_input_v = !is_readable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_iterable_v\u0026lt;T\u0026gt;; template\u0026lt;typename T, typename U\u0026gt; void re(pair\u0026lt;T, U\u0026gt;\u0026amp; p); template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;is_readable_v\u0026lt;T\u0026gt;\u0026gt; re(T\u0026amp; x) { cin\u0026gt;\u0026gt;x; } template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;needs_input_v\u0026lt;T\u0026gt;\u0026gt; re(T\u0026amp; v) { for (auto\u0026amp; x : v) re(x); } template\u0026lt;typename... T\u0026gt; void re(T\u0026amp;... args) {(re(args), ...);} template\u0026lt;typename T, typename U\u0026gt; void re(pair\u0026lt;T, U\u0026gt;\u0026amp; p) { re(p.first, p.second); }; } inline namespace Output { template\u0026lt;typename T\u0026gt; constexpr bool needs_output_v = !is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_iterable_v\u0026lt;T\u0026gt;; template\u0026lt;int offset=0, typename... T\u0026gt; void wr(T... args); template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_integral_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { cout\u0026lt;\u0026lt;x+offset; } template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; !is_integral_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { cout\u0026lt;\u0026lt;x; } template\u0026lt;int offset=0,typename T, typename U\u0026gt; void _W(const pair\u0026lt;T, U\u0026gt;\u0026amp; p) { wr\u0026lt;offset\u0026gt;(p.first, p.second); } template\u0026lt;int offset=0,typename It\u0026gt; void _W(It f, const It\u0026amp; l) { for (;f!=l; ++f) { _W\u0026lt;offset\u0026gt;(*f); if (f!=l) cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }} template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;needs_output_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { _W\u0026lt;offset\u0026gt;(begin(x), end(x)); } template\u0026lt;int offset, typename... T\u0026gt; void wr(T... args) { int i=0; ((_W\u0026lt;offset\u0026gt;(args), ++i, cout\u0026lt;\u0026lt;(i==sizeof...(args) ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;)), ...); #ifdef LOCAL cout.flush(); #endif } } template\u0026lt;typename T\u0026gt; bool ckmin(T\u0026amp; a, const T\u0026amp; b) { return b \u0026lt; a ? a = b, 1 : 0; } // set a = min(a,b) template\u0026lt;typename T\u0026gt; bool ckmax(T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? a = b, 1 : 0; }/*}}}*/ void solve() { int n; re(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=1; i\u0026lt;n; i++) { int p; re(p); g[p-1].push_back(i); } int timer=0; vector\u0026lt;int\u0026gt; in(n), out(n), dep(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(n); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u) -\u0026gt; void { in[u]=timer++; pos[dep[u]].push_back(in[u]); for (auto v : g[u]) { dep[v]=dep[u]+1; dfs(dfs, v); } out[u]=timer; }; dfs(dfs, 0); int q; re(q); while (q--) { int u, d; re(u, d); u--; auto\u0026amp; v=pos[d]; wr(lower_bound(all(v), out[u])-lower_bound(all(v), in[u])); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt=1; while (tt--) { solve(); } return 0; } 路径相关应用 如果信息是可逆的，比如说求和，我们可以结合欧拉序，第一次访问节点的时候在序列中放入正值，访问结束之后放入负值，这样不在dfs栈中的节点就会被抵消掉。总的来说，假设要求的路径是从u到v（v是u的祖先，如果不是就拆成u-\u0026gt;lca(u, v)和v-\u0026gt;lca(u, v)两条路径），那么路径和就是序列中in[v]到in[u]的和。\n","date":1621783234,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621783234,"objectID":"399591302db39f2accc927873e258b17","permalink":"https://tgc54.com/zh/post/dfs_ordering/","publishdate":"2021-05-23T11:20:34-04:00","relpermalink":"/zh/post/dfs_ordering/","section":"zh","summary":"","tags":["DFS"],"title":"DFS序/欧拉序的应用（持续更新）","type":"zh"},{"authors":null,"categories":["算法笔记"],"content":"背景：今天做了个题，用自己平常的二分写法很不方便，第一次碰到这种情况，为了防止后面再碰到类似的情况，决定记录一下二分的两种常见写法。\n根据搜索的条件，整个搜索区间可以被划分为两个区间，其中一个为符合条件的区间，我们想要的值就是最接近分界线的那个数：如果前半部分符合条件，那我们要找的是其中最大的那个值，反之则是后半部分中最小的那个值。这两种不同的情况会在写法有所不同。\n写法一：\n循环条件为while (l \u0026lt;= r)，优点是不论哪部分符合条件，边界变化都是l = mid + 1或r = mid - 1，终止时，$r=l-1$，也就是r是前半部分的最大值，l和后半部分的最小值，根据情况取l或者r。\n次方法缺点是不能同时进行两个二分搜索，不适合在某些二分的交互题里使用。\n写法二：\n循环终止条件为while (l \u0026lt; r)但中点的取法和边界的变化两种情况不一样：\n如果前半部分符合条件：\n搜索区间为$(l, r]$\nwhile (l \u0026lt; r) { int mid = (l + r + 1) / 2; if (ok(mid)) l = mid; else r = mid - 1; } 如果后半部分符合条件： 搜索区间为$[l, r)$\nwhile (l \u0026lt; r) { int mid = (l + r) / 2; if (ok(mid)) r = mid; else l = mid + 1; } 总结下来就是：\n中点偏向分界线 符合条件的话，边界移动到中点，否则要+1或者-1 半开半闭区间是为了考虑到没有符合条件的数的情况，此时边界会移动到开区间那头，类似于std::lower_bound(a.begin(), a.end(), x)找不到的话会返回a.end()。 优点是可以同时进行两个二分，当其中一个区间收敛之后就不会再变化了。而且这种写法比较符合直觉，有些二分交互题中我就会不由自主的换成这种写法（虽然以前并没有仔细研究过）。缺点就是细节稍多，一是取中点的写法，二是注意开区间。\n","date":1621738736,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621738736,"objectID":"b4b7059181a33116fdaaaf6c4e2c2625","permalink":"https://tgc54.com/zh/post/bsearch_implementations/","publishdate":"2021-05-22T22:58:56-04:00","relpermalink":"/zh/post/bsearch_implementations/","section":"zh","summary":"背景：今天做了个题，用自己平常的二分写法很不方便，第一次碰到这种情况，为了防止后面再碰到类似的情况，决定记录一下二分的两种常见写法。\n","tags":["二分"],"title":"二分搜索的两种写法","type":"zh"},{"authors":null,"categories":["题解"],"content":"很神奇的技巧\n题解 我们创建一个辅助数组$b$其中$b_i$是$a_i$后第$k$个$a_i$的下标，或者是$n+1$如果后面没有$k$个$a_i$了。比如说，样例的辅助数组是[3, 7, 7, 6, 7, 7].\n考虑询问$(l, r)$，对于$i\\in [l, r]$，如果$b_i\\le r$，说明$i$后$a_i$出现了多于$k$次，所以$i$不应该在军队里。 所以答案是$r-l+1-|\\{b_i|b_i\\le r, i\\in[l, r]\\}|$。找区间里小于$x$的数的个数可以用主席树或者wavelet树解决。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct PST { int n, tot=0; vector\u0026lt;int\u0026gt; lc, rc, sum, roots; // left child, right child PST(int n_) : n(n_), lc(n\u0026lt;\u0026lt;5), rc(n\u0026lt;\u0026lt;5), sum(n\u0026lt;\u0026lt;5), roots(1) { build(0, n-1, roots[0]); } void pushup(int rt) { sum[rt] = sum[lc[rt]] + sum[rc[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc[rt]); build(mid + 1, r, rc[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int old, int\u0026amp; rt) { rt = ++tot; lc[rt] = lc[old]; rc[rt] = rc[old]; if (l == r) { sum[rt] = sum[old] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lc[old], lc[rt]); else update(pos, val, mid + 1, r, rc[old], rc[rt]); pushup(rt); } int update(int pos, int val) { // return the root of the new version int new_root; update(pos, val, 0, n-1, roots.back(), new_root); roots.push_back(new_root); return new_root; } int query(int u, int v, int l, int r, int k) { if (l==r) return sum[v]-sum[u]; int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]]; if (mid\u0026lt;k) return x+query(rc[u], rc[v], mid+1, r, k); return query(lc[u], lc[v], l, mid, k); } int query(int u, int v, int k) { return query(u, v, 0, n-1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; constexpr int M=1e5; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(M); vector\u0026lt;int\u0026gt; a(n, n); for (int i=0; i\u0026lt;n; i++) { int x; cin\u0026gt;\u0026gt;x; pos[x].push_back(i); if (pos[x].size()\u0026gt;k) { a[*(pos[x].rbegin()+k)]=i; } } int last=0; vector\u0026lt;int\u0026gt; roots(n+1); roots[0]=1; PST tr(n+1); for (int i=0; i\u0026lt;n; i++) { roots[i+1]=tr.update(a[i], 1); } int q; cin\u0026gt;\u0026gt;q; while (q--) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=(x+last)%n, r=(y+last)%n; if (l\u0026gt;r) swap(l, r); last=(r-l+1)-tr.query(roots[l], roots[r+1], r); cout\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } ","date":1621648547,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621648547,"objectID":"28e49ba21b17fc3fe0422fcfd63292a1","permalink":"https://tgc54.com/zh/post/cf813e/","publishdate":"2021-05-21T21:55:47-04:00","relpermalink":"/zh/post/cf813e/","section":"zh","summary":"很神奇的技巧\n","tags":["数据结构","可持久化线段树","主席树"],"title":"CodeForces 813E - Army Creation题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Interesting technique.\nSolution We create an auxiliary array $b$ where $b_i$ is the index of the next $k$-th occurrence of $a_i$, or $n+1$ if such occurrence doesn’t exist. For example, the auxiliary array of the example input should be [3, 7, 7, 6, 7, 7].\nConsider query $(l, r)$, for $i\\in [l, r]$, if $b_i\\le r$, this means that there are more than $k$ occurrences of $a_i$ after $i$ so $i$ should not be in the army. Thus the answer to the query is $r-l+1-|\\{b_i|b_i\\le r, i\\in[l, r]\\}|$. Finding the number of elements in a range that are smaller than $x$ is a classic problem that can be solved with persistent segment tree or wavelet tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct PST { int n, tot=0; vector\u0026lt;int\u0026gt; lc, rc, sum, roots; // left child, right child PST(int n_) : n(n_), lc(n\u0026lt;\u0026lt;5), rc(n\u0026lt;\u0026lt;5), sum(n\u0026lt;\u0026lt;5), roots(1) { build(0, n-1, roots[0]); } void pushup(int rt) { sum[rt] = sum[lc[rt]] + sum[rc[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc[rt]); build(mid + 1, r, rc[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int old, int\u0026amp; rt) { rt = ++tot; lc[rt] = lc[old]; rc[rt] = rc[old]; if (l == r) { sum[rt] = sum[old] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lc[old], lc[rt]); else update(pos, val, mid + 1, r, rc[old], rc[rt]); pushup(rt); } int update(int pos, int val) { // return the root of the new version int new_root; update(pos, val, 0, n-1, roots.back(), new_root); roots.push_back(new_root); return new_root; } int query(int u, int v, int l, int r, int k) { if (l==r) return sum[v]-sum[u]; int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]]; if (mid\u0026lt;k) return x+query(rc[u], rc[v], mid+1, r, k); return query(lc[u], lc[v], l, mid, k); } int query(int u, int v, int k) { return query(u, v, 0, n-1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; constexpr int M=1e5; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(M); vector\u0026lt;int\u0026gt; a(n, n); for (int i=0; i\u0026lt;n; i++) { int x; cin\u0026gt;\u0026gt;x; pos[x].push_back(i); if (pos[x].size()\u0026gt;k) { a[*(pos[x].rbegin()+k)]=i; } } int last=0; vector\u0026lt;int\u0026gt; roots(n+1); roots[0]=1; PST tr(n+1); for (int i=0; i\u0026lt;n; i++) { roots[i+1]=tr.update(a[i], 1); } int q; cin\u0026gt;\u0026gt;q; while (q--) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=(x+last)%n, r=(y+last)%n; if (l\u0026gt;r) swap(l, r); last=(r-l+1)-tr.query(roots[l], roots[r+1], r); cout\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } ","date":1621648547,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621648547,"objectID":"3a9ab9456f9cd71870b71a35fcab982d","permalink":"https://tgc54.com/post/cf813e/","publishdate":"2021-05-21T21:55:47-04:00","relpermalink":"/post/cf813e/","section":"post","summary":"Interesting technique.\n","tags":["Data Structure","Persistent Segment Tree"],"title":"Solution for CodeForces 813E - Army Creation","type":"post"},{"authors":null,"categories":["杂项"],"content":"算法竞赛中主要有两种调试方式：调试器(debugger)和直接输出。调试器适合查看少量或者特定位置的信息，但可能比较费时间并且如果错过了某些信息就要重新运行,而且必须要吐槽gdb输出二维数组全挤在一行根本没法看；而直接输出适合跟踪大量的信息，并且可以方便的查看之前的信息，缺点就是需要在代码中添加额外的语句（可能会很多）并且要在提交之前删掉（即便是输出到标准错误流也会影响性能）。一种解决办法就是使用提前写好的代码/头文件，并结合#ifdef宏和命令行define参数实现区分本地和评测环境，让调试代码在环境中失效。\n输出我直接用的现成的pretty printer，然后在代码中加入如下语句：\n#ifdef LOCAL #include\u0026lt;pprint.hpp\u0026gt; // https://github.com/p-ranav/pprint pprint::PrettyPrinter P(cerr); #define de(...) P.compact(true);P.print(__VA_ARGS__) #define de_nc(...) P.compact(false);P.print(__VA_ARGS__) #else #define de(...) #define de_nc(...) #endif 注意需要把头文件的目录加到CPLUS_INCLUDE_PATH环境变量里，或者使用-I标记。编译时加上-DLOCAL标记以定义LOCAL，可以换成其他的词，只要保证oj里没有这个标记就行。\n如果你使用预编译头文件的话，要把include的那一行放到bits/stdc++.h里，然后重新编译bits/stdc++.h。\n","date":1621642947,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621642947,"objectID":"fa5566104007eaa43804938b0da3840a","permalink":"https://tgc54.com/zh/post/debug_output_header/","publishdate":"2021-05-21T20:22:27-04:00","relpermalink":"/zh/post/debug_output_header/","section":"zh","summary":"算法竞赛中主要有两种调试方式：调试器(debugger)和直","tags":null,"title":"使用自定义头文件在算法竞赛中辅助本地调试","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution 1: Suffix Array For each suffix starting from $i$, the length of the shortest unique substring which is a prefix of that suffix is $\\max(lcp_i, lcp_{i+1})+1$ where $lcp_0$ and $lcp_{n}$ is defined to be $0$. Note that if that length is greater than the length of suffix, it’s an invalid substring\nCode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; vector\u0026lt;int\u0026gt; suffix_array(string s) { s+=\u0026#34;#\u0026#34;; int n = s.size(), N = n + 256; vector\u0026lt;int\u0026gt; sa(n), ra(n); for(int i = 0; i \u0026lt; n; i++) sa[i] = i, ra[i] = s[i]; for(int k = 0; k \u0026lt; n; k ? k *= 2 : k++) { vector\u0026lt;int\u0026gt; nsa(sa), nra(n), cnt(N); for(int i = 0; i \u0026lt; n; i++) nsa[i] = (nsa[i] - k + n) % n; for(int i = 0; i \u0026lt; n; i++) cnt[ra[i]]++; for(int i = 1; i \u0026lt; N; i++) cnt[i] += cnt[i - 1]; for(int i = n - 1; i \u0026gt;= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i]; int r = 0; for(int i = 1; i \u0026lt; n; i++) { if(ra[sa[i]] != ra[sa[i - 1]]) r++; else if(ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n]) r++; nra[sa[i]] = r; } ra = nra; } sa.erase(sa.begin()); return sa; } vector\u0026lt;int\u0026gt; build_lcp(const string\u0026amp; s, const vector\u0026lt;int\u0026gt;\u0026amp; sa) { int n=s.size(); vector\u0026lt;int\u0026gt; pos(n); for (int i = 0; i \u0026lt; n; i++) pos[sa[i]] = i; vector\u0026lt;int\u0026gt; lcp(n); int k = 0; for (int i = 0; i \u0026lt; n; i++) { if (pos[i]==0) continue; if (k) k--; while (s[i+k] == s[sa[pos[i]-1]+k]) k++; lcp[pos[i]] = k; } return lcp; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; auto sa=suffix_array(s); auto lcp=build_lcp(s, sa); lcp.push_back(0); int ans=s.size(); int l=0; for (int i=1; i\u0026lt;(int)s.size(); i++) { int len=max(lcp[i], lcp[i+1])+1; if (len\u0026gt;s.size()-sa[i]) continue; if (len\u0026lt;ans) { ans=len; l=sa[i]; } else if (len==ans) l=min(l, sa[i]); } cout\u0026lt;\u0026lt;s.substr(l, ans); } Solution 2: Binary Search + String Hashing Note that if a substring is unique, then all the other substrings containing that substring is also unique. So we can binary search the length of the substring.\nFor each length, we check if there is a unique substring in all the substrings of that length using hashing. One way of calculating hash value of a substring efficiently is to precalculate hash value of all prefixes (like prefix sum). Note that in the implementation, we let the left position be more significant bit in order to avoid division.\nCode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); constexpr int mod=1e9+7; vector\u0026lt;ll\u0026gt; pow(n+1), ha(n+1); pow[0]=1; for (int i=1; i\u0026lt;=n; i++) { pow[i]=pow[i-1]*233%mod; ha[i]=(ha[i-1]*233+s[i-1])%mod; } auto get_hash=[\u0026amp;](int l, int r) { l++, r++; return (ha[r]-ha[l-1]*pow[r-l+1]%mod+mod)%mod; }; auto check=[\u0026amp;](int len) { unordered_map\u0026lt;int, int\u0026gt; cnt; for (int i=0; i+len-1\u0026lt;n; i++) { cnt[get_hash(i, i+len-1)]++; } for (int i=0; i+len-1\u0026lt;n; i++) { if(cnt[get_hash(i, i+len-1)]==1) return i; } return -1; }; int l=1, r=n; while (l\u0026lt;=r) { int mid = (l+r)/2; if (check(mid)!=-1) { r=mid-1; } else { l=mid+1; } } int ans=check(l); cout\u0026lt;\u0026lt;s.substr(ans, l); } ","date":1621350038,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621350038,"objectID":"ad1ecd57211d38bbfa11b4a9f1868c73","permalink":"https://tgc54.com/post/2020_swerc_k/","publishdate":"2021-05-18T11:00:38-04:00","relpermalink":"/post/2020_swerc_k/","section":"post","summary":"","tags":["Suffix Array","Binary Search","Hashing"],"title":"Solution for 2020 ICPC SWERC K - Unique Activities","type":"post"},{"authors":null,"categories":["题解"],"content":"比赛的时候想错方向了😞\nSolution 设从里向外多边形的边数为$e1, e2, \\dots, e_n$。不难发现$e_i$必须是$e_{i-1}$的倍 数，因此我们可以把$e$写成$e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$。所以 如果我们知道最里面的多边形的边数，那么剩下的事情就是找到最长的序列$$k_1=1, k_2, k_3, \\dots, k_n$$ 使得$k_i$是$k_{i-1}$的倍数并且$\\sum_i k_i=K$。\n注意$k_2, k_3,\\dots, k_n$都是$k_2$的倍数，所以如果我们把它们都除以$k_2$就又得到 了一个以$1$开头的序列！也就是说我们得到了一个更小的子问题，所以我们可以用动态规 划来解决：设$dp_i$为和为$i$的上述序列的最大长度。因为我们可以把一个短的序列乘上 一个数并在最前面放一个$1$，从而得到一个更长的序列，所以状态转移就是： $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":1621111156,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621111156,"objectID":"532e17989cc83df47c3461e73283c736","permalink":"https://tgc54.com/zh/post/gcj2021_r2_matrygons/","publishdate":"2021-05-15T16:39:16-04:00","relpermalink":"/zh/post/gcj2021_r2_matrygons/","section":"zh","summary":"比赛的时候想错方向了😞\n","tags":["动态规划"],"title":"Google Code Jam 2021 R2 Matrygons题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Went the wrong direction during the contest. 😞\nSolution Let the number of edges of the polygons be $e1, e2, \\dots, e_n$. It’s easy to find that $e_i$ has to be a multiple of $e_{i-1}$, thus we can rewrite $e$ as $e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$. Hence if we know the number of edges of the first polygon, all we left if to find the longest sequence $$k_1=1, k_2, k_3, \\dots, k_n$$ such that $k_i$ is a multiple if $k_{i-1}$ and $\\sum_i k_i=K$.\nNote that $k_2, k_3,\\dots, k_n$ are all multiple of $k_2$, so if we divide them by $k_2$ we get a sequence starting with $1$ again! This means we get a smaller subproblem and we can use dynamic programming to solve it: let $dp_i$ be the length of the longest such sequence described above which sums to $i$. Since we can get a longer sequence by multiplying a shorter one by a constant and prepending a $1$, so the transition is: $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":1621111156,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621111156,"objectID":"b30eab7750270e7a43def446e7f8d22d","permalink":"https://tgc54.com/post/gcj2021_r2_matrygons/","publishdate":"2021-05-15T16:39:16-04:00","relpermalink":"/post/gcj2021_r2_matrygons/","section":"post","summary":"Went the wrong direction during the contest. 😞\n","tags":["DP"],"title":"Solution for Google Code Jam 2021 R2 Matrygons","type":"post"},{"authors":null,"categories":["算法笔记"],"content":"路径覆盖是一个路径的集合使得每个顶点都只被一条路径覆盖。最小路径覆盖问题要求集合中路径的条数是最小的。\n树的最小路径覆盖 做法1：DP $dp_{u, 0}$代表当u不为路径的端点的时候，u 的子树里最少的路径的数目，$dp_{u, 1}$代表当u为路径的端点的时候，u 的子树里最少的路径的数目。\n设$v$为u的儿子，状态转移时u不为端点的情况可以是之前u不为端点的情况加上v不为端点的情况，即: $$dp_{u, 0}\\coloneqq dp_{u, 0}+dp_{v, 0}$$ 也可以是以u为端点的路与以v为端点 的路连成一条路，即: $$dp_{u, 0}\\coloneqq dp_{u, 1}+dp_{v, 1}-1$$ u为端点的情况类似，可以是之前u为端点的情况加上v不为端点的情况，即： $$dp_{u, 1}\\coloneqq dp_{u, 1}+dp_{v, 0}$$ 也可以是前面所有儿子的不以儿子为端点的路径加上以v为端点的路径,即： $$dp_{u, 1}\\coloneqq sum+dp_{v, 1}$$ 综上所述： $$\\begin{align*} dp_{u, 0}\u0026amp;\\coloneqq \\min(dp_{u, 0}+dp_{v, 0}, dp_{u, 1}+dp_{v, 1}-1)\\\\ dp_{u, 1}\u0026amp;\\coloneqq \\min(dp_{u, 1}+dp_{v, 0}, sum+dp_{v, 1})\\end{align*}$$\n如果要记录方案的话只先在dp的过程中记录经过u的路径往下走的儿子，然后再跑一遍dfs构建路径。\n代码：\nvector dp(n, vector\u0026lt;int\u0026gt;(2)); vector nxt(n, vector(2, pair{-1, -1})); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { dp[u][0]=dp[u][1]=1; int sum=0; for (auto v : g[u]) { if (v==p) continue; dfs(dfs, v, u); if (dp[u][0]+dp[v][0] \u0026gt; dp[u][1]+dp[v][1]-1) { nxt[u][0]={nxt[u][1].first, v}; } dp[u][0]=min(dp[u][0]+dp[v][0], dp[u][1]+dp[v][1]-1); if (dp[u][1]+dp[v][0] \u0026gt; sum+dp[v][1]) { nxt[u][1]={v, v}; } dp[u][1]=min(dp[u][1]+dp[v][0], sum+dp[v][1]); sum+=dp[v][0]; } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; end_point(n); //路径的端点 vector\u0026lt;pii\u0026gt; remove; // 不在路径覆盖中的路径 int tot{}; auto dfs2=[\u0026amp;](auto\u0026amp; dfs2, int u, int p, int flag, int id) -\u0026gt; void { // id 为当前路径的编号 for (auto v : g[u]) { if (v==p) continue; if (v==nxt[u][flag].first || v==nxt[u][flag].second) { dfs2(dfs2, v, u, 1, id); } else { remove.emplace_back(u, v); tot++; int nflag=dp[v][0]\u0026lt;dp[v][1] ? 0 : 1; if (nflag) end_point[tot].push_back(v); dfs2(dfs2, v, u, nflag, tot); } } if (nxt[u][flag]==pair{-1, -1}) end_point[id].push_back(u); }; 做法2：贪心 贪心做法更加简单，只用一个dfs就能实现。如果u有两个儿子是路径的端点那么就连接那两条路，否则就将u做为端点。\n代码：\nvector\u0026lt;pii\u0026gt; end_points, remove; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; int { // 返回-1代表u不是端点，否则返回以u为端点的路径的另一端。 vector\u0026lt;int\u0026gt; next; for (auto v : g[u]) { if (v==p) continue; int end_v=dfs(dfs, v, u); if (end_v\u0026gt;=0) { if (next.size() \u0026lt;= 1) { next.push_back(end_v); } else { remove.emplace_back(u, v); end_points.emplace_back(end_v, v); } } else { remove.emplace_back(u, v); } } if (next.empty()) next.push_back(u); if (next.size()==1) { if (p!=-1) return next[0]; end_points.emplace_back(next[0], u); return -1; } else { end_points.emplace_back(next[0], next[1]); return -1; } }; 练习题 CF1521D - Nastia Plays with a Tree\nDAG的最小路径覆盖 我们把原图上的每个点拆成两个点（对于点x，可以把从它拆出去的点记为x+n），其中一个点与源点相连，另一个与汇点相连。对于原DAG上的边u -\u0026gt; v，在新图中连接 u -\u0026gt; v\u0026#39;，所有边的容量均为1。跑一遍最大流（本质上是二分图匹配），得到的最大流（或者最大匹配）便是被覆盖的边数，由于路径上的点数等于边数+1，所以点数减被覆盖的边数便是路径的数目。也可以理解为最大流经过的每一条边对应原图中有一条向边的起点，所以路径的终点是没有对应的边的，所以点数减被覆盖的边数便是终点的数目也就是路径的数目。\n如何记录路径？可以在增广途中记录每个点的下一个点。如何找起点？如果x\u0026#39;到汇点的剩余容量为1，说明没有点流向x ，也就说明x是起点。\n模板题：\n洛谷P2764 最小路径覆盖问题\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h, nxt; Flow(int n) : n(n), g(n), nxt(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (a) nxt[u] = v; // 增广成功便记录路径 if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back((int)e.size()); e.emplace_back(v, c); g[v].push_back((int)e.size()); e.emplace_back(u, 0); } void maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } n = (n - 2) / 2; for (int i = n + 1; i \u0026lt;= 2 * n; i++) { if (e[g[i].back()].cap == 1) { int u = i - n; while (u \u0026gt; 0) { cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; u = nxt[u] - n; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Flow g(2 * n + 2); while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g.addEdge(u, v + n, 1); } for (int i = 1; i \u0026lt;= n; i++) { g.addEdge(0, i, 1); g.addEdge(i + n, 2 * n + 1, 1); } g.maxFlow(0, 2 * n + 1); return 0; } 参考资料 https://zhuanlan.zhihu.com/p/125759333\n","date":1620487550,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620487550,"objectID":"44839d503a65c9115fad6df50d174a04","permalink":"https://tgc54.com/zh/post/minimum_path_cover/","publishdate":"2021-05-08T11:25:50-04:00","relpermalink":"/zh/post/minimum_path_cover/","section":"zh","summary":"路径覆盖是一个路径的集合使得每个顶点都只被一条路径覆盖。最小路径覆盖问题要求集合中路径的条数是最小的。\n","tags":["图论"],"title":"树和DAG的最小路径覆盖问题","type":"zh"},{"authors":null,"categories":["算法笔记"],"content":"貌似还挺经典的一个问题\n显然我们要单独考虑每个连通块，结论是答案为$\\lfloor \\frac{m}{2} \\rfloor$，其中m为边数。寻找答案的算法如下：\n跑一遍dfs得到dfs生成树，然后从下往上处理边：将与当前节点相连的边两两配对，如果边数是奇数就留下与父亲节点相连的那条边给父亲节点。这样就可以保证所有边都被覆盖了。\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=0; i\u0026lt;m; i++) { int u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--, v--; g[u].push_back(v); g[v].push_back(u); } vector\u0026lt;int\u0026gt; vis(n); vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; res; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; bool { vis[u]=1; vector\u0026lt;int\u0026gt; w; if (p!=-1) w.push_back(p); for (auto v : g[u]) { if (v==p) continue; if (!vis[v]) { if (dfs(dfs, v, u)) w.push_back(v); } else if (vis[v]==1) w.push_back(v); } while (w.size() \u0026gt;= 2) { res.emplace_back(*(w.rbegin()+1), u, w.back()); w.pop_back(); w.pop_back(); } vis[u]=2; return !w.empty(); }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) dfs(dfs, i, -1); } cout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto\u0026amp; [x, y, z] : res) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 练习题：\nCF1159E - Off by One\ngym102001K - Boomerangs\nCF858E - Wizard’s Tour\n","date":1620271252,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620271252,"objectID":"1d1c5f1c1e46f92d61b44a2e3207f41c","permalink":"https://tgc54.com/zh/post/cover_edges_with_path_of_length_two/","publishdate":"2021-05-05T23:20:52-04:00","relpermalink":"/zh/post/cover_edges_with_path_of_length_two/","section":"zh","summary":"貌似还挺经典的一个问题\n","tags":["DFS","图论"],"title":"用长为2的路径覆盖所有边","type":"zh"},{"authors":null,"categories":["算法笔记"],"content":"总结一些常见的数学模型。\n将直线上多个点移动到一个点的最小距离 移动到最中间的那个点距离最小，或者说是移动到一点使得两侧的点一样多。\n将直线上多个点移动到连续的位置 假设起点为$a$, 也就是说最小化$\\sum_i|x_i-(a+i)|=\\sum_i|(x_i+i)-a|$, 于是问题又转化成了将坐标为$x_i-i$的点移动到一点的问题，取中间的坐标即可。\nChicken McNugget Theorem 假设$n, m$互质，最大的不能被表示为$an+bm, a, b\\ge 0$的数是$nm-m-n$.\nsource\n最小化一点到其他点距离的平方的和 由于$dis^2=x^2+y^2$，而x和y可以独立改变，所以可以分别最小化两个坐标轴的距离，也就是坐标的平均数。\n","date":1620268462,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620268462,"objectID":"1d462fede40616db9a9f4978036c41e7","permalink":"https://tgc54.com/zh/post/math_model/","publishdate":"2021-05-05T22:34:22-04:00","relpermalink":"/zh/post/math_model/","section":"zh","summary":"总结一些常见的数学模型。\n","tags":["数学"],"title":"一些数学模型","type":"zh"},{"authors":null,"categories":["题解"],"content":"算是有所进步但还是稍有遗憾，差一题就能进division championships.\n更新：所有7题队都以wildcard的身份晋级NADC了，而且如果本学校只有wildcard队的话，会被分到最弱的central division，然后我们又莫名其妙的拿了个第6，晋级NAC了😂\n比赛过程 两个队友一个简称T，一个简称J。\n开场我从前往后读，A比较长就直接跳过了，读了B感觉有点想法但又不是很确定就接着读，C很明显是个找最大环，一开始还觉得比较麻烦，但想想不是环就是链所以直接dfs就行了。同时队友J读到E发现就是个矩阵乘法于是开始写，我又跟榜做了G。之后不久队友J的E也过了。另一个队友T读了H是贪心但不会写，我此时在写B的暴力（但其实稍微想想暴力肯定超时但不知道为啥还是写完了）。B暴力写完才发现会超时，此时H还没做出来，我看了一眼也没想法，就扔给队友J了。然后发现B好像可以dp，然后就一边想一边写，虽然有点恶心但挺直接的，最后一遍过。写B的过程中队友J过了H，算是签完到了。此时才一个半小时，感觉非常好，比去年顺利多了。\n然后我在做K，感觉是dp，有点思路但不会写，队友J在做J，过了样例但是WA，队友T直接开I了（其实是最难的题orz）。于是三个人都卡题了，不知不觉过了一个半小时我终于放弃了，此时J题过了一大堆，于是我就跟队友J换了一下题，由于队友J用的python而我又懒的看所以就准备重写，然后没想到是个超级恶心模拟题，而且写了一堆bug，离结束还有半小时和队友J几乎同时过了J和K。然后仔细一看A发现很简单但输出格式很恶心，最后虽然勉强写完但没时间debug，以7题收场。\n反思 卡题太久没有及时放弃，哪怕去读读别的题。题没有都读一遍，队友J其实读了A但感觉很麻烦，但我感觉比J好做多了（可能我J写的太烂了）。L到最后也没人读，其实也不难，就是个二分图匹配的板子 题。所以说也不能一味的跟榜，毕竟每个人的知识点覆盖不一样。但K卡半天没做出来也不应该。\n题解 A 数据很小，找lca直接暴力网上跳也可以。输出格式比较恶心，要多看几遍，注意不要把11th, 12th, 13th输出成 11st, 12nd, 13rd。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, T; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;T; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; a(n); vector\u0026lt;string\u0026gt; name(n); unordered_map\u0026lt;string, int\u0026gt; id; for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;name[i]; id.try_emplace(name[i], id.size()); int x; cin\u0026gt;\u0026gt;x; a[i].resize(x); for (auto\u0026amp; s : a[i]) { cin\u0026gt;\u0026gt;s; id.try_emplace(s, id.size()); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(id.size()); vector\u0026lt;int\u0026gt; ind(id.size()); for (int i=0; i\u0026lt;n; i++) { int u=id[name[i]]; for (auto\u0026amp; s : a[i]) { g[u].push_back(id[s]); ind[id[s]]++; } } vector\u0026lt;int\u0026gt; pa(id.size()); vector\u0026lt;int\u0026gt; dep(id.size()); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { pa[u] = p; for (auto v : g[u]) { if (v == p) continue; dep[v]=dep[u]+1; dfs(dfs, v, u); } }; auto lca=[\u0026amp;](int x, int y) { while (x!=y) { if (dep[x]\u0026lt;dep[y]) swap(x, y); x=pa[x]; } return x; }; for (int i=0; i\u0026lt;id.size(); i++) { if (ind[i]==0) { dfs(dfs, i, i); break; } } auto ordinal=[](int x) { auto s=to_string(x); if (x\u0026gt;=11 \u0026amp;\u0026amp; x\u0026lt;=13) return s+\u0026#34;th\u0026#34;; if (x%10==1) return s+\u0026#34;st\u0026#34;; if (x%10==2) return s+\u0026#34;nd\u0026#34;; if (x%10==3) return s+\u0026#34;rd\u0026#34;; return s+\u0026#34;th\u0026#34;; }; while (T--) { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int l=lca(id[s], id[t]); int m=dep[id[s]]-dep[l]; int n=dep[id[t]]-dep[l]; int swaped=0; if (m\u0026gt;n) { swap(m, n); swaped=1; swap(s, t); } if (m==0) { swap(s, t); if (n==1) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the child of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { n-=2; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the \u0026#34;; for (int i=0; i\u0026lt;n; i++) cout\u0026lt;\u0026lt;\u0026#34;great \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;grandchild of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else if (m==n \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are siblings\\n\u0026#34;; else { n--; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(n)\u0026lt;\u0026lt;\u0026#34; cousins\\n\u0026#34;; } } else if (n\u0026gt;m \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n-m==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt; ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, 1 time removed\\n\u0026#34;; else cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, \u0026#34;\u0026lt;\u0026lt;n-m\u0026lt;\u0026lt;\u0026#34; times removed\\n\u0026#34;; } } return 0; } B dp[x][y][i][used][d] 代表是否存在以坐标 $(x, y)$ 的字符结尾，覆盖目标字符串的前i个字符，转向used次，结束时的方向是d的走法。注意长度为$i$的字符串最多转$i-1$次，虽然第一个字符是没有方向的，但为了转移方便就变成了所有方向，所以枚举转向次数的话要限制一下，不然会出现长度为2转两次的走法。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int dp[10][10][105][105][8]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector a(n, vector\u0026lt;char\u0026gt;(m)); for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { cin\u0026gt;\u0026gt;a[i][j]; } } int limit; string s; cin\u0026gt;\u0026gt;limit\u0026gt;\u0026gt;s; limit=min(limit, int(s.size())); const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { if (a[i][j]==s[0]) { for (int d=0; d\u0026lt;8; d++) dp[i][j][0][0][d]=1; } } } for (int i=1; i\u0026lt;s.size(); i++) { for (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (a[x][y]!=s[i]) continue; for (int used=0; used\u0026lt;=min(limit, i-1); used++) { for (int d=0; d\u0026lt;8; d++) { for (int pd=0; pd\u0026lt;8; pd++) { auto [dx, dy]=dirs[d]; unsigned nx=x+dx, ny=y+dy; int pused=used-(d!=pd); // if (i==1) pused=0; if (nx\u0026lt;n \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; pused\u0026gt;=0 \u0026amp;\u0026amp; dp[nx][ny][i-1][pused][pd]) { dp[x][y][i][used][d]=1; } } } } } } } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { for (int d=0; d\u0026lt;8; d++) if (dp[i][j][s.size()-1][limit][d]) return cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;, 0; } } cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;; return 0; } C 由于每个物品最多只有一个人要，所以每个点的出度最多为1，所以每个连通分量要么是环要么是链。直接dfs即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int …","date":1615334400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615334400,"objectID":"b2a65fcbc0fd04bee0acaa2d8f723381","permalink":"https://tgc54.com/zh/post/2020_icpc_ecna/","publishdate":"2021-03-10T00:00:00Z","relpermalink":"/zh/post/2020_icpc_ecna/","section":"zh","summary":"算是有所进步但还是稍有遗憾，差一题就能进division championships.\n更新：所有7题队都以wildcard的身份晋级NADC了，而且如果本学校只有wildcard队的话，会被分到最弱的central division，然后我们又莫名其妙的拿了个第6，晋级NAC了😂\n","tags":["Contests"],"title":"2020 ICPC East Central NA Regional Contest 总结与题解","type":"zh"},{"authors":null,"categories":["比赛题解"],"content":"官方英文题解\nA. Bitwise 从高位往低位贪心，写一个函数判断能否至少得到x。\n如何判断能否至少得到x？依然是贪心的思路，我们从某一位开始，记录当前的或值，如果大于x就开始新的一块。但如果从每个数都开始试一遍的话时间复杂度是$O(n^2)$。但是我们发现每个块的结束位置一定是某一位变成1的位置，所以说开始的位置其实并不重要，最多只会少算一个部分，所以如果我们遍历两圈，如果至少有$2k-1$个块的话就说明x是可行的。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n*2); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i+n]=a[i]; } auto can=[\u0026amp;](int x) -\u0026gt; bool { int cnt=0, cur=0; for (int i=0; i\u0026lt;2*n; i++) { cur|=a[i]; if ((cur\u0026amp;x)==x) { cnt++; cur=0; } } return cnt\u0026gt;=2*k-1; }; int ans=0; for (int bit=31; bit\u0026gt;=0; bit--) { if (can(ans|(1\u0026lt;\u0026lt;bit))) ans|=(1\u0026lt;\u0026lt;bit); } cout\u0026lt;\u0026lt;ans; return 0; } B. Conveyor Belts 我们可以把一个点拆成$K$个点，第$i$个点代表第$t\\bmod K$时刻。原图中a -\u0026gt; b的边拆完之后就变成了a的第$i$时刻连到b的第$(i+1)\\bmod K$时刻，容量为1。这样就保证了每时刻每条传送带上只有一个物品。然后添加一个超级源点，连到第$i$个producer的第$i$时刻，容量为1。最后从第$N$个点的每一个时刻连到一个超级汇点，容量为无穷大。然后跑个最大流就行了。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} // indexed from 0! struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } int maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; Flow mf(n*k+2); for (int i=0; i\u0026lt;m; i++) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; for (int j=0; j\u0026lt;k; j++) { mf.addEdge(x*k+j, y*k+(j+1)%k, 1); } } for (int i=0; i\u0026lt;k; i++) mf.addEdge(n*k, i*k+i, 1); for (int i=0; i\u0026lt;k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9); cout\u0026lt;\u0026lt;mf.maxFlow(n*k, n*k+1); return 0; } C. Free Food 暴力标记每一天即可\nD. Hoppers 如果有长度为奇数的环的话并且整个网络连通就能传播到整个网络。所以只少检查每个连通分量是不是二分图并计算连通分量的个数就行了。\n队友写的所以没有代码QAQ\nE. Largest Triangle 这题过于经典，网上应该有很多题解。\nG. Non-Prime Factors 先预处理答案，类似筛法的思路：如果不是质数就把它的倍数们的答案加1,质数就把它的倍数们标记成合数。$O(1)$输出询问即可。快读貌似不是很有必要。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} namespace IO { const int MAXSIZE = 1 \u0026lt;\u0026lt; 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u0026lt;\u0026lt; 20], *pp = pbuf; inline void push(const char \u0026amp;c) { if (pp - pbuf == 1 \u0026lt;\u0026lt; 20) fwrite(pbuf, 1, 1 \u0026lt;\u0026lt; 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + \u0026#39;0\u0026#39;); } } // const int N=2e6; int ans[N+1]; bool not_prime[N+1]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q=IO::rd(); for (int i=2; i\u0026lt;=N; i++) { if (!not_prime[i]) { for (int j=i+i; j\u0026lt;=N; j+=i) not_prime[j]=1; } else { for (int j=i; j\u0026lt;=N; j+=i) { ans[j]++; } } } while (q--) { int x=IO::rd(); printf(\u0026#34;%d\\n\u0026#34;, ans[x]+1); } return 0; } J. SG Coin 其实就是个取模下的减法。。。\nL. Wi Know 首先我们观察到：对于$i\u0026lt;j\u0026lt;k, S_i=S_j=S_k$，$(S_i, S_k)$一定不差于$(S_j, S_k)$。所以在$A, B, A, B$ 中第一个A我们一定选在$S$中第一次出现的A。同理，第二个B一定选$S$中最后一出现的B。\n解法的大致思路就是固定B找最小的A。一种比较naive的思路是在$[i+1, last_i-1]$中查询最小值，但有两个问题：\n不知道最小值在$i$之前有没有出现过。 最小值可能等于$S_i$。 所以我们不能一次把所有的数都放到线段树里，要按一定的顺序放。对于每个位置$i$，我们记录一个$nxt_i$为$S_i$的下一个出现位置。然后我们遍历$S$，首先查询$[i+1, last_i-1]$中的最小值min，然后用{min, S[i]}更新答案，最后在线段树中把$next_i$设为$S_i$。\n这样为什么避免了上面的两个问题呢？首先，只有在$i$之前出现过的数才会被加进去，避免了问题1，然后我们是先查询再添加，而且一次只加一个，这样就避免问题2。总之这个解法还是很妙的，比官方题解简单不少。\n#include …","date":1612656e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612656e3,"objectID":"7489626d958942531c3ebc91e145e00a","permalink":"https://tgc54.com/zh/post/2018_icpc_singapore/","publishdate":"2021-02-07T00:00:00Z","relpermalink":"/zh/post/2018_icpc_singapore/","section":"zh","summary":"官方英文题解\n","tags":null,"title":"题解 2018 ICPC Asia Singapore Regional Contest","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Feels pretty standard, but I was too bad at that time. Good problem.\nSolution For brevity, let’s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there’s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I’m wrong).\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } ","date":1611446400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1611446400,"objectID":"e516a03be95acc566377e6eca34a71d8","permalink":"https://tgc54.com/post/2019_ecna_k/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"/post/2019_ecna_k/","section":"post","summary":"Feels pretty standard, but I was too bad at that time. Good problem.\n","tags":["DP"],"title":"Tutorial for 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","type":"post"},{"authors":null,"categories":["题解"],"content":"感觉挺套路的，但当时太菜了不会做，是道不错的题\nSolution For brevity, let’s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there’s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I’m wrong).\n题解 首先先算出把每一种箱子放到结尾为$j$的位置的花费，然后遍历 $5!$ 种相对位置顺序，然后记录把前$i$种箱子放到结尾为$j$的位置的花费。 具体转移公式看上面吧，懒得复制了QAQ.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } ","date":1611446400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1611446400,"objectID":"328e34b1080a9578ea2f513367862707","permalink":"https://tgc54.com/zh/post/2019_ecna_k/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"/zh/post/2019_ecna_k/","section":"zh","summary":"感觉挺套路的，但当时太菜了不会做，是道不错的题\n","tags":["动态规划"],"title":"题解 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Easy to think but hard to write.\nSolution Since the radius of a circle is at most 5, we only need to check the status of 10 blocks before it, which could be represented as a binary number. Let $dp_{i, j}$ be the number of ways to draw circles whose right boundary is $i$, with mask of $j$. Here if the k-th bit of the mask is 1, it means that you can put a circle whose left boundary is $i-k$.\nFor a fixed right boundary, there are 5 possible positions for center, so $2^5$ circle combinations. So our strategy is that for each position, we check $2^{10}$ masks and $2^5$ circle combinations, then transition if possible.\nIn order to make coding easier, we could calculate some helper array: le is the mask for the left boundary of the corresponding center mask, all the bits in mhi[i] to the right of the highest bit of le[i] is set to 1 to make positions inside the circle unavailable for the next position.\nCode Credits\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} constexpr int mod=1e9+7; ll dp[1010][1\u0026lt;\u0026lt;10]; int already[1010]; int le[32], mhi[32]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i=0; i\u0026lt;k; i++) { int c, r; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;r; already[c+r]|=(1\u0026lt;\u0026lt;(r-1)); } for (int i=0; i\u0026lt;32; i++) { for (int j=0; j\u0026lt;5; j++) { if (i\u0026gt;\u0026gt;j\u0026amp;1) { le[i]|=(1\u0026lt;\u0026lt;(2*j+1)); mhi[i]=(1\u0026lt;\u0026lt;(2*j+1))-1; } } } dp[0][0]=1; for (int i=0; i\u0026lt;=n; i++) { for (int mask=0; mask\u0026lt;1024; mask++) { if (!dp[i][mask]) continue; for (int k=0; k\u0026lt;32; k++) { if ((already[i]\u0026amp;k) != already[i]) continue; if ((mask \u0026amp; le[k]) != le[k]) continue; int nxt=mask-(mask \u0026amp; mhi[k]); nxt=(2*nxt+1)\u0026amp;1023; (dp[i+1][nxt]+=dp[i][mask])%=mod; } } } ll ans=0; for (int i=0; i\u0026lt;1024; i++) (ans+=dp[n+1][i])%=mod; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1610236800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1610236800,"objectID":"81cf1ab431440474cc6806336034c704","permalink":"https://tgc54.com/post/gym102843j/","publishdate":"2021-01-10T00:00:00Z","relpermalink":"/post/gym102843j/","section":"post","summary":"Easy to think but hard to write.\n","tags":["DP"],"title":"Tutorial for 2020 CCPC Changchun Onsite J (GYM102832J) - Abstract Painting","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s consider the case where $\\max(h_{i + 1}, \\ldots, h_{j - 1}) \u0026lt; \\min(h_i, h_j)$. $h_i$ could be lower or higher than $h_j$. There can be multiple $i$ that satisfies the condition and we can observe the leftmost $i$ is the first that $h_i\\ge h_j$, let’s denote this $i_{min}$, other $i$ between $[i_{min},j]$ must satisfy that $h_i$ is the maximum value among $[i,j-1]$. This can be solved using monotonic stack. Assume we store the indices in the stack, when adding a new index $j$, all the indices that will be removed are a valid position to jump to $j$, so we can do dp and update the minimum number of moves. The time complexity is $O(n)$.\nThe second case is similar.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(n,n); dp[0]=0; vector\u0026lt;int\u0026gt; h{0},l{0}; for(int i=1;i\u0026lt;n;i++){ dp[i]=min(dp[i],dp[i-1]+1); while(!h.empty()\u0026amp;\u0026amp;a[i]\u0026gt;=a[h.back()]){ int x=a[h.back()]; h.pop_back(); if(a[i]\u0026gt;x\u0026amp;\u0026amp;!h.empty()) dp[i]=min(dp[i],dp[h.back()]+1); } while(!l.empty()\u0026amp;\u0026amp;a[i]\u0026lt;=a[l.back()]){ int x=a[l.back()]; l.pop_back(); if(a[i]\u0026lt;x\u0026amp;\u0026amp;!l.empty()) dp[i]=min(dp[i],dp[l.back()]+1); } h.push_back(i); l.push_back(i); } cout\u0026lt;\u0026lt;dp[n-1]; return 0; } ","date":1599523200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599523200,"objectID":"f9665c5bb2b9ab3d72814865a3a71848","permalink":"https://tgc54.com/post/cf1407d/","publishdate":"2020-09-08T00:00:00Z","relpermalink":"/post/cf1407d/","section":"post","summary":"","tags":["DP","Monotonic Stack"],"title":"Tutorial for CodeForces 1407D","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First, count how many palindromes begin with $s_i$ and let the number be $f_i$.\nThen, find the maximum length $d$ such that $s_{i - k} = t_k$ for each k = 1, 2, …, d and let the length be $g_i$.\nThe answer should be $\\sum_{i=1}^{\\lvert S\\rvert}f_i\\cdot g_i$.\nThe first part can be solved using manacher algorithm, and the second part is equivalent to calculate the longest common prefix (LCP) for every suffix of the reversed string $s$ with $t$, which can be solved using Z algorithm.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; vector\u0026lt;int\u0026gt; manacher(const string ss){ string s; for(auto ch:ss) s+=\u0026#34;#\u0026#34;,s+=ch; s+=\u0026#34;#\u0026#34;; int n=(int)s.size(); vector\u0026lt;int\u0026gt; d1(n); for (int i = 0, l = 0, r = -1; i \u0026lt; n; i++) { int k = (i \u0026gt; r) ? 1 : min(d1[l + r - i], r - i); while (0 \u0026lt;= i - k \u0026amp;\u0026amp; i + k \u0026lt; n \u0026amp;\u0026amp; s[i - k] == s[i + k]) { k++; } d1[i] = k--; if (i + k \u0026gt; r) { l = i - k; r = i + k; } } return d1; } vector\u0026lt;int\u0026gt; z_function(const string s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; auto man=manacher(s); vector\u0026lt;int\u0026gt; f(sz(s)); for(int i=1;i\u0026lt;sz(man)-1;i++){ int l=(i-man[i]+1)/2,r=(i-1)/2; f[l]++; if(r\u0026lt;sz(s)-1) f[r+1]--; } partial_sum(all(f),f.begin()); reverse(all(s)); auto g=z_function(t+\u0026#34;#\u0026#34;+s); g.erase(g.begin(),g.begin()+sz(t)+1); reverse(all(g)); g.erase(g.end()-1); g.insert(g.begin(),0); ll ans=0; forn(i,sz(s)) ans+=ll(f[i])*g[i]; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1594252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594252800,"objectID":"5c4b9ed7403cda6bc36c9dc6757c7398","permalink":"https://tgc54.com/post/gym101981m/","publishdate":"2020-07-09T00:00:00Z","relpermalink":"/post/gym101981m/","section":"post","summary":"","tags":["String","Manacher","Z Algorithm"],"title":"Tutorial 2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M - Mediocre String Problem","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Each element {x,i}in the stack represents a consecutive group of dominos such that if one domino can reach x, all the dominos starting from the i-th position until the next group will fall. So when we move to a new domino, we should firstly pop out all the domino that within the reach of the current domino. Then the top domino would be the closest domino that won’t fall if we pull of the current domino, i.e. the answer for the current domino.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1593907200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593907200,"objectID":"b47a991a93eebe7514a0f81cfe8c3b6b","permalink":"https://tgc54.com/post/cf56e/","publishdate":"2020-07-05T00:00:00Z","relpermalink":"/post/cf56e/","section":"post","summary":"","tags":["Data Structure","Monotonic Stack"],"title":"Tutorial for Codeforces 56E - Domino Principle","type":"post"},{"authors":null,"categories":["题解"],"content":"单调栈好题，非常独特的视角。\n题解 栈中的每一个元素{x,i}代表的是一组连续的多米诺，使得如果我们如果推倒x处的多米诺，从第i个开始一直到下一组的多米诺都会被推掉。所以我们处理新的多米诺的时候，要先把当前多米诺够得到的多米诺组弹出，最后栈顶的元素就是最近的够不着的多米诺，也就是当前多米诺的答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1593907200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593907200,"objectID":"733786c5b8a86a1b052a2ea3da2d1d8d","permalink":"https://tgc54.com/zh/post/cf56e/","publishdate":"2020-07-05T00:00:00Z","relpermalink":"/zh/post/cf56e/","section":"zh","summary":"单调栈好题，非常独特的视角。\n","tags":["数据结构","单调栈"],"title":"题解 Codeforces 56E - Domino Principle","type":"zh"},{"authors":null,"categories":["题解"],"content":"非常好的学习dp的比赛。\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThere’s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define sz(x) int(x.size()) using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0, 1, \\dots , i - 1$ such that the last element is j and all the first i - 1 inequalities are fulfilled.\nTransition is:\nif(s[i]==\u0026#39;\u0026gt;\u0026#39;) $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; …","date":1593561600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593561600,"objectID":"69fb2e21ab48172f5f6e4f51a4755199","permalink":"https://tgc54.com/zh/post/abc_dp/","publishdate":"2020-07-01T00:00:00Z","relpermalink":"/zh/post/abc_dp/","section":"zh","summary":"非常好的学习dp的比赛。\n","tags":["动态规划"],"title":"部分题解 Atcoder Educational DP Contest","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s find $s_i$: the number of friends who love food $i$. For some food $i$, if $s_i\\leq w_i$, we can see that all the friends who love $i$ will have food to eat no matter what order you call them. So we want to call them as late as possible.\nThe solution is like doing a topological sort or BFS: we start from all the $i$ that $s_i\\leq w_i$. When visiting a new vertex $u$, decrease $s_u$ by one and then if $s_u\\leq w_u$, put $u$ in the queue and put it in the call list. Finally we reverse our call list and that’s the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1592956800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592956800,"objectID":"7c28005f85e98f787102d05237a3b396","permalink":"https://tgc54.com/post/cf1369e/","publishdate":"2020-06-24T00:00:00Z","relpermalink":"/post/cf1369e/","section":"post","summary":"","tags":["BFS","Greedy"],"title":"Tutorial for Codeforces 1369E - DeadLee","type":"post"},{"authors":null,"categories":["题解"],"content":"贪就完事了\n题解 首先先算出$s_i$：喜欢食物$i$的人的个数。对于食物$i$，如果$s_i\\leq w_i$，我们可以看出这些人无论你以什么顺序叫他们都有食物吃。所以我们尽可能的晚叫他们。\n整个过程有点像拓扑排序或者说是BFS：从所有满足$s_i\\leq w_i$的点开始，当访问新的点u时，$s_u$减1，如果$s_u\\leq w_u$的话，就把u加进队列并把u加到叫人的名单里。最后反转名单就得到答案了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1592956800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592956800,"objectID":"414bd4d3113fb876d3e86091f004645d","permalink":"https://tgc54.com/zh/post/cf1369e/","publishdate":"2020-06-24T00:00:00Z","relpermalink":"/zh/post/cf1369e/","section":"zh","summary":"贪就完事了\n","tags":["BFS","贪心"],"title":"题解Codeforces 1369E - DeadLee","type":"zh"},{"authors":null,"categories":["题解"],"content":"思考的角度很妙\n题解 答案的个数等于有多少个长度为$|S|+K$的字符串$T$使得$S$是他的一个子序列。\n设$S_i$在$T$中的下标为$a_1,a_2,\\dots,a_{|S|}$。 为了避免重复，我们在所有可能的$a+i$中取最小的。不难看出，$a_i$和$a_{i+1}$之间的字符有25种选择，$a_{|S|}$之后的有26种可能。\n所以我们可以枚举$a_{|S|}$之后的字符的个数，这样在字符选择方面我们有$25^{K-x}\\cdot 26^x$种可能。然后再考虑如何分配$K-x$个字符，根据插板模型，我们有${|S|-1+k-x \\choose |S|-1}$种方式，所以对于每个x，答案增加$25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592870400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592870400,"objectID":"e3b1d450fa5a09441d927e2be0b27930","permalink":"https://tgc54.com/zh/post/abc171f/","publishdate":"2020-06-23T00:00:00Z","relpermalink":"/zh/post/abc171f/","section":"zh","summary":"思考的角度很妙\n","tags":["组合学"],"title":"题解 Atcoder Beginner Contest 171F - Strivore","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution It’s obvious that the images we opened is a sub-segment of all images. We can loop over all the possible left endpoints and use two pointers to find the rightmost endpoint.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592784e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592784e3,"objectID":"3aba7fd7567ab1b721a71da866d618ef","permalink":"https://tgc54.com/post/cf650b/","publishdate":"2020-06-22T00:00:00Z","relpermalink":"/post/cf650b/","section":"post","summary":"","tags":["Two Pointers"],"title":"Tutorial for Codeforces 650B/651D Image Preview","type":"post"},{"authors":null,"categories":["题解"],"content":"有时候双指针会很简单\n题解 不难看出所有打开的图片是所有图片的一个子段。我们可以枚举所有左端点然后用双指针找到最右的端点。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592784e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592784e3,"objectID":"0acd9845bcddceada310abfdba17fdb6","permalink":"https://tgc54.com/zh/post/cf650b/","publishdate":"2020-06-22T00:00:00Z","relpermalink":"/zh/post/cf650b/","section":"zh","summary":"有时候双指针会很简单\n","tags":["双指针"],"title":"题解 Codeforces 650B/651D Image Preview","type":"zh"},{"authors":null,"categories":["题解"],"content":"其实并不难，官方题解给的dp做法太吓人了\n题解 首先定义一下“排了序的子序列”：它是一个原数组的子序列并且在排序之后的数组中是一个子数组。不难看出没用被移动过的元素会形成一个排了序的子序列。所以说如果我们找到最长的排了序的子序列那么答案就是最小的。\n因为我们只关注数字的相对大小，我们可以压缩一下数字，这样写起来会简单一些。然后每个数组开一个数组存改数字的所有下标。\n然后遍历所有数字，如果当前数字的最小下标大于之前数字的最大下标，那么这个数字的所有下标都可以加到当前的子序列里。否则我们需要重新开始一个子序列，以下两点需要注意：\n当前数字的一部分也是可以被加到刚才的子序列里的，比如说1,2,2,1,2，第二个2就可以加进去变成1,1,1,2。\n之前的数的一部分也可以被加到新的子序列里，比如1,2,2,1,2，我们可以把第一个1加进来变成1,2,2,2。\n但是还有一种特殊的情况：这个子序列只包含两个数的下标，并且这两个数的下标都是不完整的，比如2,1,1,2,2,1。不难看出我们要取第一个数的一个前缀，取第二个数的一个后缀，那么我们就可以枚举前缀的位置然后找到对应的后缀。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } ","date":1592438400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592438400,"objectID":"1381a5db45fa993bc75e742b5d116c40","permalink":"https://tgc54.com/zh/post/cf1367f2/","publishdate":"2020-06-18T00:00:00Z","relpermalink":"/zh/post/cf1367f2/","section":"zh","summary":"其实并不难，官方题解给的dp做法太吓人了\n","tags":["贪心","二分"],"title":"Codeforces 1367F2 - Flying Sort (Hard Version) 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Don’t be intimidated by the official solution.\nSolution First let’s introduce “sorted subsequence”: a sorted subsequence is a subsequence that is a subarray of the sorted array. It’s easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized.\nSince we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.\nNow let’s iterate over each number. If the smallest index of the current number is greater than the biggest index of the previous number, we can simply add all the index to our subsequence. Otherwise, we need to start a new subsequence. There are two things we should notice:\nPart of the indices of the current number can be added to the old subsequence. E.g. 1,2,1,1,2, the second 2 can be added so we have 1,1,1,2.\nThe new subsequence can also include part of the indices of the previous number. E.g. 1,2,2,1,2 we can add the first 1 to the front so we have 1,2,2,2.\nThere is one special case: the subsequence consists indices of two numbers and indices of both numbers are incomplete. E.g. 2,1,1,2,2,1, it’s easy to see that we need a prefix of the fist number the a suffix of the second number. So we can iterate over each prefix of the first number and find the corresponding suffix of the second number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } ","date":1592438400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592438400,"objectID":"2ac4beec5c23e6378f46ae1c3b0bc574","permalink":"https://tgc54.com/post/cf1367f2/","publishdate":"2020-06-18T00:00:00Z","relpermalink":"/post/cf1367f2/","section":"post","summary":"Don’t be intimidated by the official solution.\n","tags":["Greedy","Binary Search"],"title":"Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution The key observation is that if we fix $l$ then we have $\\max_{i=l}^ra_i-\\min_{i=l}^r b_i\\leq \\max_{i=l}^{r+1}a_i-\\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\\max_{i=l}^r a_i=\\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query.\nAlso this can be done using monotone queue but I haven’t figured it out.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; struct sparse{ int logn; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;f[i][0]; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;g[i][0]; for (int j = 1; j \u0026lt;= logn; j++) for (int i = 0; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt; n; i++){ f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); g[i][j] = min(g[i][j - 1], g[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } int geta(int x,int y){ int s = __lg(y - x + 1); return max(f[x][s], f[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } int getb(int x,int y){ int s = __lg(y - x + 1); return min(g[x][s], g[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; sparse st(n); ll ans=0; for(int i=0;i\u0026lt;n;i++){ int l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;st.getb(i,mid)) l=mid+1; else r=mid-1; } int left=r; l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;=st.getb(i,mid)) l=mid+1; else r=mid-1; } ans+=r-left; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592352e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592352e3,"objectID":"47429e23e3b5b6361990be440df46bf2","permalink":"https://tgc54.com/post/cf689d/","publishdate":"2020-06-17T00:00:00Z","relpermalink":"/post/cf689d/","section":"post","summary":"","tags":["Binary Search","Data Structure","Sparse Table"],"title":"Tutorial for Codeforces - Friends and Subsequences","type":"post"},{"authors":null,"categories":null,"content":"打乱\nB U2 R2 U2 L2 B\u0026#39; D2 R2 U2 R2 F2 R B\u0026#39; U R F U2 L2 R\u0026#39; B2 解法：\nU\u0026#39; R2\u0026#39; F\u0026#39; //cross y U\u0026#39; R\u0026#39; U R//first pair U\u0026#39; L\u0026#39; U L U2 R U\u0026#39; R\u0026#39;//second pair U2 L\u0026#39; U\u0026#39; L2 U L\u0026#39;//third pair y\u0026#39; U R U2 R\u0026#39; U2 R U\u0026#39; R\u0026#39;//fourth pair U r U R\u0026#39; U R U2 r\u0026#39;//OLL U\u0026#39; R\u0026#39; U\u0026#39; F\u0026#39; R U R\u0026#39; U\u0026#39; R\u0026#39; F R2 U\u0026#39; R\u0026#39; U\u0026#39; R U R\u0026#39; U R//PLL ","date":1591660800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591660800,"objectID":"560120146839b84df201220118b7d9d6","permalink":"https://tgc54.com/zh/post/33pb9.8/","publishdate":"2020-06-09T00:00:00Z","relpermalink":"/zh/post/33pb9.8/","section":"zh","summary":"","tags":["魔方"],"title":"9.80无跳3阶pb复盘","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"link\nSolution Let’s try to fix the right endpoint first and then find the longest subarray for each right endpoint.\nLet $pos_{x,i}$ be the index of the $i$-th occurrence of number $x$. Assume the current right endpoint is $r\\in[0,n)$, for each $x\\in[1,C]$ The left endpoint can’t fall in the interval $[pos_{x,m-k+1}+1,i]$ where $m$ is the occurrence of $x$ until $r$. This is because if left endpoint in that interval, the occurrence of $x$ would be larger than zero and smaller than $K$, which doesn’t satisfy the constrain. We could add 1 on those intervals and the leftmost endpoint is the smallest index whose value is 0.\nNow let’s consider how the intervals change when the right endpoint moves to $r+1$. It’s easy to see that only the interval for $a_{r+1}$ will change. The interval will change from $[pos_{a_{r+1},m-k}+1,pos_{a_{r+1},m-1}]$ to $[pos_{a_{r+1},m-k+1}+1,pos_{a_{r+1},m}]$. Note that in the implementation we don’t have to change the overlapped interval.\nIn conclusion, we need a data structure that supports range modification and global minimum value query, a.k.a. segment tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1591660800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591660800,"objectID":"2867bc62bf649e4b6a55d9fc98409e55","permalink":"https://tgc54.com/post/hdu6602/","publishdate":"2020-06-09T00:00:00Z","relpermalink":"/post/hdu6602/","section":"post","summary":"","tags":["Data Structure","Segment Tree"],"title":"Solution for HDU6602 - Longest Subarray","type":"post"},{"authors":null,"categories":["题解"],"content":"link\n题解 让我们先尝试固定右端点，然后对于每个右端点找到最长的子数组。\n令$ pos_ {x，i} $为第i个$x$的下标。假设当前的右端点是$ r \\in [0，n）$，对于每个$ x \\in [1，C] $,左端点不可能落在区间$ [pos_ {x，m-k + 1 } + 1，i] $，其中$ m $是直到$ r $为止$ x $的出现次数。这是因为如果左端点在这个区间内，则$ x $的出现将大于零且小于$ K $，不满足约束条件。我们可以在这些区间上加1，那么最左的端点是值为0的最小下标。\n现在让我们考虑一下当右端点移至$ r + 1 $时区间如何变化。显而易见，只有$ a_ {r + 1} $的区间会改变。 区间将从$ [pos_ {a_ {r + 1}，mk} + 1，pos_ {a_ {r + 1}，m-1}] $变为$ [pos_ {a_ {r + 1}，m- k + 1} + 1，pos_ {a_ {r + 1}，m}] $。请注意，在代码中，我们不必更改重叠的部分。\n综上所述，我们需要一个支持区间修改和全局最小值查询的数据结构,aka线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1591660800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591660800,"objectID":"98fd393a70936c8328ebfb92d3b23d5b","permalink":"https://tgc54.com/zh/post/hdu6602/","publishdate":"2020-06-09T00:00:00Z","relpermalink":"/zh/post/hdu6602/","section":"zh","summary":"","tags":["数据结构","线段树"],"title":"题解 HDU6602 - Longest Subarray","type":"zh"},{"authors":null,"categories":["题解"],"content":"好几天没更新了\n题解 首先，先定义这个函数$f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$，也就是从$i$开始往后连续$k$个数的和。\n然后我们证明如果k和一个答案那么2k也是一个答案：$f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$。因此我们从能找到一个大于$\\dfrac n 2$的答案。\n然后我们分类讨论，先考虑$x\\ge 0$的情况。如果k是答案，因为$f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$，所以k+1也是一个答案，因此我们只要判断$k=n$是不是答案就行了。\n最后，考虑$x\\leq 0$，我们需要借助以下前缀和，定义$pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ 并且 $pre_0=0$. 我们需要找到 $k$ 使得对于所有$0\\leq i\\leq n-k$:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\n因为$k\u0026gt;\\dfrac n 2$，“窗口”之后的所有数字都是$x$，所以上面的不等式可以写成这样：\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\n对于每一个$i$，对应的k是$n-1$，也就是说不等式左边的最大值如果小于$pre_n+x\\cdot (n-i)$，那么$k=n-i$是一个答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end() using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } ","date":1590451200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590451200,"objectID":"900efe416c0cf76529bac9cea604bad9","permalink":"https://tgc54.com/zh/post/cf1358e/","publishdate":"2020-05-26T00:00:00Z","relpermalink":"/zh/post/cf1358e/","section":"zh","summary":"好几天没更新了\n","tags":null,"title":"Codeforces 1358E - Are You Fired? 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution First, let’s define the function $f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$, i.e. the sum of $k$ consecutive months starting at $i$.\nNow, let’s prove that if $k$ is one answer and $k\\leq \\dfrac n 2$, then $2\\cdot k$ is also an answer: $f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$. Thus we can always find an answer greater than $\\dfrac n 2$.\nThen, consider the case where $x\\ge 0$. If $k$ is an answer, since $f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$, $k+1$ is also an answer. Thus it’s sufficient to check if $k=n$ is the answer.\nLastly, when $x\u0026lt;0$, we need the help of the prefix sum. Define $pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ and $pre_0=0$. We want to find a $k$ such that for each $0\\leq i\\leq n-k$, we have:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nSince $k\u0026gt;\\dfrac n 2$, the numbers after the window must be $x$, so the formula can be rewrite as:\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\nFor each $i$, the corresponding $k$ is $n-i$, this means if the max value of the LHS is smaller than $pre_n+x\\cdot (n-i)$, then $k=n-i$ is a answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end() using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } ","date":1590451200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590451200,"objectID":"91cc7b91e3337754cf2aa8fb8d819b77","permalink":"https://tgc54.com/post/cf1358e/","publishdate":"2020-05-26T00:00:00Z","relpermalink":"/post/cf1358e/","section":"post","summary":"","tags":null,"title":"Tutorial for Codeforces 1358E - Are You Fired?","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Consider the contribution to the answer of the each occurrence of each substring. Suppose this substring has appeared $c$ times. For a new occurrence of this substring, the answer would change from $c^2$ to $(c+1)^2$, that is to say, each new occurrence contributes $(c+1)^2-c^2=2\\cdot c+1$ to the answer. Since there are $\\dfrac {n\\cdot (n+1)} 2$ substrings, the answer is at least $\\dfrac {n\\cdot (n+1)} 2$ , now what we left is to focusing on finding the occurrence of the substrings. You will see why it’s more handy to do this.\nLet’s build the suffix array and the LCP array first. You will notice that the occurrence of some substring is a subsegment in the suffix array. so is it in the LCP array and the min value of the subsegment in the LCP array is the length of that substring. We can process each of the LCP value in the descending order. This is because each LCP value $lcp_i$ can represent $lcp_i$ substrings, so if we process them in the descending order, we can assure that all the substrings have appeared before.\n","date":1590451200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590451200,"objectID":"c1c172a3419190f7fa08fe11c2b1ec1c","permalink":"https://tgc54.com/post/cf802i/","publishdate":"2020-05-26T00:00:00Z","relpermalink":"/post/cf802i/","section":"post","summary":"","tags":["Suffix Array"],"title":"Tutorial for Codeforces 801I - Fake News (hard)","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Iterate over each frequency. Suppose now we are on frequency $i$. Put all stations with frequency $i$ in the $left$ vector and all radio stations with frequency $[i-k,i+k]$ into the $right$ vector.\nNow we want to calculate the number of pairs such that the left radio station is from the $left$ vector and the right station is from $right$ vector.\nSort the $left$ vector by position and sort the $right$ vector by the left bound of the stations’ range. Iterator the stations in the $left$ vector and put all the stations in the $right$ vector which can reach the current station in the axis(actually we need to put them in some data structure). Now we need to know how many stations in the axis can be reached by the current station. This can be done with some range-sum-query data structure(like fenwick tree): we add one on the position for each new station and use range query to find the stations we want. However, since the positions are up to $10^9$ we also need to compress the coordinate, which is really annoying, so a simpler way to do this is to use a balanced BST in pb_ds library to find the order directly.\nThe lesson learnt is that when we want to find the order, especially with coordinate compression, consider pb_ds.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; #include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt; using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} using ordered_set = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;pii\u0026gt; fre[10005]; forn(i,n){ int x,r,f; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;r\u0026gt;\u0026gt;f; fre[f].pb({x,r}); } ll ans=0; auto solve=[\u0026amp;](vector\u0026lt;pii\u0026gt;\u0026amp; left,vector\u0026lt;pii\u0026gt;\u0026amp; right){ sort(all(left)); sort(all(right),[](pii a,pii b){return a.F-a.S\u0026lt;b.F-b.S;}); ll res=0; int i=0; ordered_set tree; for(auto it:left){ while(i\u0026lt;right.size()\u0026amp;\u0026amp;right[i].F-right[i].S\u0026lt;=it.F){ tree.insert(right[i].F); i++; } res+=tree.order_of_key(it.F+it.S+1)-tree.order_of_key(it.F+1); } return res; }; for(int i=1;i\u0026lt;=1e4;i++){ if(fre[i].empty()) continue; vector\u0026lt;pii\u0026gt; left(all(fre[i])),right; for(int j=max(1,i-k);j\u0026lt;=i+k\u0026amp;\u0026amp;j\u0026lt;=10000;j++){ right.insert(right.end(),all(fre[j])); } ans+=solve(left,right); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1589932800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589932800,"objectID":"62e6df94c6591c5890e08a6dc67ffafb","permalink":"https://tgc54.com/post/cf762e/","publishdate":"2020-05-20T00:00:00Z","relpermalink":"/post/cf762e/","section":"post","summary":"","tags":["Data Structure"],"title":"Tutorial for Codeforces 762E - Radio stations","type":"post"},{"authors":null,"categories":["题解"],"content":"题解 这题如果不能往左走的话就是一个标准的dp题。所以我们要处理一下额外的情况。但是经观察我们可以发现我们不需要往左走超过两格，下面是一个简单的证明：\n所以我们只要额外考虑两种状态转移就行了，所有的状态转移如下：\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } ","date":1589846400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589846400,"objectID":"0451459e81ea67cadef9179526c113d4","permalink":"https://tgc54.com/zh/post/cf762d/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"/zh/post/cf762d/","section":"zh","summary":"","tags":["动态规划"],"title":"Codeforces 762D - Maximum Path 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution The problem would be a standard dp problem if we can’t go to the left. So we need to handle that extra case. However, we can observe that we don’t need to go more than one cell to the left. Here is a quick proof:\nSo we only need to consider two more transition. Here is all the transition:\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } ","date":1589846400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589846400,"objectID":"333b83d0d98b46960bf52717b4382ca9","permalink":"https://tgc54.com/post/cf762d/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"/post/cf762d/","section":"post","summary":"","tags":["DP"],"title":"Tutorial for Codeforces 762D - Maximum Path","type":"post"},{"authors":null,"categories":["算法笔记"],"content":"总结一下加深印象\n左边第一个比当前小 严格单调递增栈，如果求的是数字栈内就存数字，如果求距离栈内就存数字+下标或者数字+到栈内前一个元素的距离。\n举例 [2,1,6,4,5]\n[] 空栈，说明2之前没有比2小的元素，然后2入栈 [2]\n为了保持单调递增，需要把2弹出，变成空栈，说明1前面也没有比1小的，然后1入栈 [1]\n6比1大，直接入栈，[1, 6]\n先把比4大的元素弹出[1],然后入栈 [1, 4]\n5直接入栈 [1, 4, 5]\n求距离：\n{元素,到前一个的距离}\n[] -\u0026gt; [{2,1}]\n[] -\u0026gt; [{1,2}]\n[{1,2}] -\u0026gt; [{1,2},{6,1}]\n[{1,2}] -\u0026gt; [{1,2},{4,2}]\n[{1,2},{4,2}] -\u0026gt; [{1,2},{4,2},{5,1}]\n代码 求元素：\nstack\u0026lt;int\u0026gt; stk vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;stk.top()\u0026gt;=a[i]) stk.pop(); ans[i]=stk.top(); stk.push(a[i]); } 求距离:\nstack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ int res=1; while(!stk.empty()\u0026amp;\u0026amp;stk.top().first\u0026gt;=a[i]){ res+=stk.top().second; stk.pop(); } ans[i]=res; stk.push({a[i],res}); } 左边第一个大，第一个大于等于，第一个小于等于 严格单调递减栈，非严格递减栈，非严格递增\n右边第一个大等等 从右往左处理即可\n","date":1589846400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589846400,"objectID":"92cd82722c1b5e826e0d8d4f7744f506","permalink":"https://tgc54.com/zh/post/monotonic_stack/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"/zh/post/monotonic_stack/","section":"zh","summary":"总结一下加深印象\n","tags":["数据结构","单调栈"],"title":"单调栈常见模型","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s minimize the answer. The key observation is that at most one pair passes through the edge $(a,b)$. This is because if two or more pair pass that edge, we can pair two vertices in the same side of that edge and get a better answer.\nFurthermore, the number of pairs that pass through $(a,b)$ is $c_a\\bmod 2$, where $c_a$ the size of the component on a’s side.\nFor the maximized answer, the strategy is similar. The observation is that nodes of one component are paired with node of the other component. We can do the reversed thing in the minimized answer to prove this. Thus, each edge is counted $\\min(c_a,c_b)$ times.\nBoth the maximized answer and the minimized answer can be calculated at the same time in one DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; ll mx,mn; int n; int dfs(int u,int fa){ int sz=1; for(auto [to,w]:G[u]){ if(to==fa) continue; int csz=dfs(to,u); mx+=(ll)w*min(csz,2*n-csz); mn+=ll(w)*(csz%2); sz+=csz; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(2*n+1); mx=mn=0; forn(i,2*n-1){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; G[x].pb({y,z}); G[y].pb({x,z}); } dfs(1,0); cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; } return 0; } ","date":158976e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":158976e4,"objectID":"8fe3353cbedd6497e150dd52659b1530","permalink":"https://tgc54.com/post/cf1280c/","publishdate":"2020-05-18T00:00:00Z","relpermalink":"/post/cf1280c/","section":"post","summary":"","tags":["DFS"],"title":"Tutorial for Codeforces 1280C/1281E Jeremy Bearimy","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Firstly, let’s ignore the third condition for now. Consider the tree is rooted at node 1. Let $dp_i$ be the number of valid sets contain node $i$ and other nodes in the subtree of $i$. This can be easily calculated using a dfs: $dp_i=\\prod_{j\\in child(i)}(dp_j+1)$\nNow consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node $i$ and only visit nodes $j$ such that $a_i\\leq a_j \\leq a_i+d$. In this case, the third condition is satisfied so we can calculate the answer using the formula above. Also be careful with the duplicate counting, i.e. if $a_j=a_i$, only visit node $j$ such that $j\u0026gt;i$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; int d,n; const int mod=1e9+7; int dfs(int u,int root,int fa){ int sz=1; for(auto to:G[u]){ if(to==fa) continue; if(a[to]\u0026lt;a[root]||a[to]\u0026gt;a[root]+d) continue; if(a[to]==a[root]\u0026amp;\u0026amp;to\u0026lt;root) continue; sz=ll(sz)*(dfs(to,root,u)+1)%mod; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;d\u0026gt;\u0026gt;n; G.resize(n+1); a.resize(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int ans=0; for1(i,n){ ans=(ans+dfs(i,i,0))%mod; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1589500800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589500800,"objectID":"555d30d0da0f99a85f525e4079926910","permalink":"https://tgc54.com/post/cf486d/","publishdate":"2020-05-15T00:00:00Z","relpermalink":"/post/cf486d/","section":"post","summary":"","tags":["DFS","DP"],"title":"Tutorial for Cdoeforces 486D - Valid Sets","type":"post"},{"authors":null,"categories":["题解"],"content":"题解 题目本质是判断能否找到一对线段使得他们在一个维度上相交但不在另一维度上不相交。为了得到所有相交的线段，我们要知道对于所有时间点被哪些线段覆盖了。具体一点就是需要几个数组$open_i$和$close_i$，分别存的是以$i$开头和结尾的线段。那么我们如何知道是否有一对线段不相交呢？我们还需要维护两个multiset，一个存当前线段的起点，另一个存终点。如果最右边的起点大于最左边的终点那么就说明有两个线段没重叠。\n最后别忘了离散化并且两个维度都要检查一下。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } ","date":1589414400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589414400,"objectID":"1d92895bd53f22e695f3a57780a2f0f8","permalink":"https://tgc54.com/zh/post/cf1284d/","publishdate":"2020-05-14T00:00:00Z","relpermalink":"/zh/post/cf1284d/","section":"zh","summary":"","tags":["数据结构"],"title":"Codeforces 1284D - New Year and Conference 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution The problem can be described as checking if there exists a pair of conferences that overlap in one dimension but not in the other dimension. In order to get all the segments that overlap with each other, we should know for all time points, which segments cover it. Specifically, we need some arrays $open_i$ and $close_i$ which store the segments that start at $i$ and close at $i$. So how can we know if there’s a pair of segments that doesn’t overlap on another dimension? We can maintain two multisets, one is the starting points of the current segments, the other is the end points. If the rightmost starting is bigger than the leftmost end point, this means that there exists a pair of segments that doesn’t overlap.\nNote that we need to compress the time points and check both dimension.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } ","date":1589414400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589414400,"objectID":"519c9a81544aaddedb1cccaf7b3c8135","permalink":"https://tgc54.com/post/cf1284d/","publishdate":"2020-05-14T00:00:00Z","relpermalink":"/post/cf1284d/","section":"post","summary":"","tags":["Data Structure"],"title":"Tutorial for Codeforces 1284D - New Year and Conference","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Let’s call a cell bad if no adjacent cell has the same color, otherwise that cell is good.\nIf a good cell and a bad cell are adjacent, according to the definition, the good cell will change color in the next iteration while the bad cell not. As the result, the bad cell will turn into a good cell. Therefore, a bad cell won’t change if all the cells are bad cells, otherwise it will become good when the nearest good cell reaches it. The left thing is to find the nearest good cell for all cells. This can be done using multi-source bfs.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const vector\u0026lt;pii\u0026gt; dir{{1,0,},{-1,0},{0,1},{0,-1}}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t; vector\u0026lt;string\u0026gt; G(n); for(auto\u0026amp; it:G) cin\u0026gt;\u0026gt;it; queue\u0026lt;pii\u0026gt; q; auto cango=[\u0026amp;](int x,int y){ return x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;n\u0026amp;\u0026amp;y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;m; }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dis(n,vector\u0026lt;int\u0026gt;(m,-1)); forn(i,n){ forn(j,m){ bool ok=0; for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;G[x][y]==G[i][j]) ok=1; } if(ok){ dis[i][j]=0; q.emplace(i,j); } } } while(!q.empty()){ auto [i,j]=q.front(); q.pop(); for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;dis[x][y]==-1){ dis[x][y]=dis[i][j]+1; q.emplace(x,y); } } } while(t--){ int i,j; ll p; cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;j\u0026gt;\u0026gt;p; i--,j--; if(dis[i][j]==-1) cout\u0026lt;\u0026lt;G[i][j]\u0026lt;\u0026lt;endl; else if(dis[i][j]\u0026gt;=p) cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;))\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;)^((p-dis[i][j])\u0026amp;1))\u0026lt;\u0026lt;endl; } return 0; } ","date":1589241600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589241600,"objectID":"7d3df42e3e86a34c870a35a5f234e1b0","permalink":"https://tgc54.com/post/cf1349c/","publishdate":"2020-05-12T00:00:00Z","relpermalink":"/post/cf1349c/","section":"post","summary":"","tags":["BFS"],"title":"Solution for Codeforces 1349C/1350E - Orac and Game of Life","type":"post"},{"authors":null,"categories":["题解"],"content":"题解 观察易知，若想用最小的时间覆盖一段线段，那么结束时的位置一定在线段的左端点或右端点。那么我们的dp状态就可以设为$dp_{l,r,p}$，代表覆盖从l到r的线段所用的最短时间并且以左端点结尾（p=0），右端点结尾（p=1）。\n状态转移是不难想的，$dp_{l,r,0}$可以由$dp_{l+1,r,0}$或$dp_{l+1,r,1}$得到，同理$dp_{l,r,1}$可以由$dp_{l,r-1,0}$或$dp_{l,r-1,1}$得到，别忘了判断一下是否在规定的时间之内。具体转移看代码～\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); const int N=1005; int dp[N][N][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; p(n+1),t(n+1); ms(dp,INF); for1(i,n){ cin\u0026gt;\u0026gt;p[i]; dp[i][i][0]=dp[i][i][1]=0; } for1(i,n) cin\u0026gt;\u0026gt;t[i]; for(int len=2;len\u0026lt;=n;len++){ for(int l=1;l+len-1\u0026lt;=n;l++){ int r=l+len-1; int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]); int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]); if(t1\u0026lt;=t[l]) dp[l][r][0]=t1; if(t2\u0026lt;=t[r]) dp[l][r][1]=t2; } } int ans=min(dp[1][n][0],dp[1][n][1]); cout\u0026lt;\u0026lt;(ans==INF?-1:ans); return 0; } ","date":1589068800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589068800,"objectID":"b33bedb37551f33da39aeb83e93239d5","permalink":"https://tgc54.com/zh/post/nc5447c/","publishdate":"2020-05-10T00:00:00Z","relpermalink":"/zh/post/nc5447c/","section":"zh","summary":"","tags":["动态规划"],"title":"题解 Nowcoder 5447C - 张老师的旅行","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Tutorial A faster way to simulate the process is that instead of moving the hole array, we can add some extra space in front of the array and simply move the element to the extra space. For example, in the sample input:\n5 4 3 5 1 4 The process would look like\n_ _ _ _ 1 2 3 4 5 _ _ _ 3 1 2 _ 4 5 _ _ 5 3 1 2 _ 4 _ _ 1 5 3 _ 2 _ 4 _ 4 1 5 3 _ 2 _ _ _ We can use a fenwick tree to simulate the process: mark a position with 1 if it’s occupied by some number and the prefix sum is how many elements is in front of it (i.e. the real position in the simulator). In the end, don’t forget to update the position of all the elements in case some are not moved.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void wr(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void add(int i,int x){ for(i++;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int query(int i){ ll res=0; for(i++;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } int query(int l,int r){ return query(r)-query(l-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; l(n),r(n); iota(all(l),0); r=l; vector\u0026lt;int\u0026gt; pos(n); forn(i,n) pos[i]=i+m; fenwick tree(n+m+1); forn(i,n) tree.add(i+m,1); forn(i,m){ int x; cin\u0026gt;\u0026gt;x; x--; l[x]=0; r[x]=max(r[x],tree.query(pos[x]-1)); tree.add(pos[x],-1); pos[x]=m-i-1; tree.add(pos[x],1); } forn(i,n) r[i]=max(r[i],tree.query(pos[i]-1)); forn(i,n) wr(l[i]+1,r[i]+1); return 0; } ","date":1588982400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588982400,"objectID":"1f069561bc0aa9c5dbee54c82961b9fc","permalink":"https://tgc54.com/post/cf1288e/","publishdate":"2020-05-09T00:00:00Z","relpermalink":"/post/cf1288e/","section":"post","summary":"","tags":["Data Structure","Fenwick Tree"],"title":"Tutorial for Codeforces 1288E - Messenger Simulator","type":"post"},{"authors":null,"categories":["题解"],"content":"想明白了以后其实很简单\n题解 首先，如果$c_i$大于$i$的子树的大小，那么答案不存在。\n对于每个节点，我们建立一个数组，这个数组包含这个节点所有子树的节点，按照$a_i$的大小排序（虽然我们现在还不知道$a_i$的具体数值，我们只关心相对大小关系）。下一个问题就是如何组合子节点的数组，答案其实很简单：直接拼起来就可以了，因为每个子树是互相独立的。最后一步就是把当前的节点放进去，因为$c_i$是已知的所以数组的第$c_i$个数应该是$i$.\n现在我们有了包含所有节点的数组$order$，我们把$1,2,3,\\dots$ 赋给 $order_1,order_2,order_3,\\dots$就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1588809600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588809600,"objectID":"003732a1082882b35709f580056da6ef","permalink":"https://tgc54.com/zh/post/cf1286b/","publishdate":"2020-05-07T00:00:00Z","relpermalink":"/zh/post/cf1286b/","section":"zh","summary":"想明白了以后其实很简单\n","tags":["DFS"],"title":"CodeForces 1286B/1287D - Numbers on Tree 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution First, if $c_i$ is greater than the size of the subtree of node $i$, there’s no answer.\nFor each node we build an array containing all the nodes from the its subtree bottom-up, and these nodes are in ascending order of value written on them (i.e. $a_i$) even though we don’t know the exact value for now. We only care about their relative relationship. The next question is how to combine all the arrays of the children. The answer is quite simple: we can simply glue then together since each subtree is independent. The last step is to put the node in the array. Since we already know $c_i$, so $i$ should be put in the $c_i$-th position of the array.\nNow we have that array containing all the nodes. Let’s call it $order$. We can assign $1,2,3,\\dots$ to $order_1,order_2,order_3,\\dots$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1588809600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588809600,"objectID":"bd6c3976362e36c89bb2817f0fa40caa","permalink":"https://tgc54.com/post/cf1286b/","publishdate":"2020-05-07T00:00:00Z","relpermalink":"/post/cf1286b/","section":"post","summary":"","tags":["DFS"],"title":"Tutorial for Codeforces 1286B/1287D - Numbers on Tree","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First, let’s force Vasya to change tire on everyday with negative temperature (even on consecutive days) so she will change tire for $2\\cdot cnt$ time where $cnt$ is the number of days with negative temperature. If $cnt\u0026gt;k$ obviously the answer is -1, otherwise the winter tire can still last for some extra days. Now let’s see if we can use the winter tire on days with non-negative temperature. We can sort all the length of the consecutive days with non-negative temperature, so we can greedily use winter tires on those segments. For each segment we use, we save tire change twice. Finally let’s see if we can use the winter tire until the last day after the last negative-temperature day.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Ar\u0026gt; void wr(Ar... ar) {((cout\u0026lt;\u0026lt;ar\u0026lt;\u0026lt;\u0026#34; \u0026#34;),...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n),neg; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026lt;0) neg.push_back(i); } if(neg.empty()) return cout\u0026lt;\u0026lt;0,0; if(neg.size()\u0026gt;k) return cout\u0026lt;\u0026lt;-1,0; vector\u0026lt;int\u0026gt; xs; for(int i=1;i\u0026lt;(int)size(neg);i++) xs.push_back(neg[i]-neg[i-1]-1); sort(all(xs)); int ans=int(size(neg))*2; k-=size(neg); for(auto i:xs){ if(k\u0026gt;=i){ k-=i; ans-=2; }else break; } if(n-neg.back()-1\u0026lt;=k) ans--; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1588636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588636800,"objectID":"7ecd4fc91a7e3a9d28e740145fffa096","permalink":"https://tgc54.com/post/cf747d/","publishdate":"2020-05-05T00:00:00Z","relpermalink":"/post/cf747d/","section":"post","summary":"","tags":["Greedy"],"title":"Tutorial for Codeforces 747D - Winter Is Coming","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Very interesting problem.\nSolution The problem is not hard if you know to find the LIS in $O(n\\log n)$ time. Combining LIS and tree problem is quite interesting.\nThe key part of this problem is how to backtrack. I used vector so the backtrack part is a little bit more cumbersome than regular array’s since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set flag to -1 otherwise set flag to the old number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a,ans; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void dfs(int u,int fa,vector\u0026lt;int\u0026gt;\u0026amp; lis){ int flag; int pos=lower_bound(all(lis),a[u])-lis.begin(); if(pos==lis.size()) lis.push_back(a[u]),flag=-1; else flag=lis[pos],lis[pos]=a[u]; ans[u]=lis.size(); for(auto it:G[u]){ if(it==fa) continue; dfs(it,u,lis); } if(flag==-1) lis.pop_back(); else lis[pos]=flag; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a=ans=vector\u0026lt;int\u0026gt;(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } vector\u0026lt;int\u0026gt; v{}; dfs(1,-1,v); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } ","date":1588377600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588377600,"objectID":"2e08bc1cfc3133369e06afeb5df416b4","permalink":"https://tgc54.com/post/abc165f/","publishdate":"2020-05-02T00:00:00Z","relpermalink":"/post/abc165f/","section":"post","summary":"Very interesting problem.\n","tags":["DFS","DP"],"title":"Solution for AtCoder beginner contest 165F - LIS on Tree","type":"post"},{"authors":null,"categories":null,"content":"数学太垃圾\na写错了一个地方但样例过了也就没多想就交了，上来就吃一发wa……\nb题也差不多，简单想了想就开始写，也没考虑一些更复杂的情况，又吃一发wa。\nc题应该早点打表的，手动枚举还是费时间，而且还算错了一个，更加阻碍了发现规律。然后就是计数问题，算相等的情况确实没错，但有点过于想把公式一般化了，就应该按照自己的想法来，哪怕公式长一些，毕竟比赛追求的还是速度。\nd题贪心策略想错了，貌似经常犯这样的错误，一种策略是从大往小填。\n总结：还是应该即时决定取舍，重写往往比修改好（在卡题的时候），还有心态的问题。\n","date":1587945600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587945600,"objectID":"0340e769fb2d21df66fa5b9bc4355c88","permalink":"https://tgc54.com/zh/post/cf1432recap/","publishdate":"2020-04-27T00:00:00Z","relpermalink":"/zh/post/cf1432recap/","section":"zh","summary":"数学太垃圾\n","tags":null,"title":"Recap of Educational Codeforces round 86","type":"zh"},{"authors":null,"categories":["题解"],"content":"题解 我们可以做的最小的操作就是只排序相邻的两个元素，也就是说交换$a_i$和$a_{i+1}$如果$a_i\u0026gt;a_{i+1}$。通过这种操作，我们可以把$a_i$挪到位置$j,j\u0026lt; i$，如果所有$i$到$j-1$的数都比$a_i$小的话。\n明白了操作的本质之后我们就可以尝试从用a数组的数左往右构造b数组了。设当前的位置为$i$:\n首先找到最左的位置$j$使得$a_j=b_i$，如果找不到那么答案是no。我们可以用set或者很多个vector维护位置。\n判断$[1,j)$（最初的下标）中的最小值是否比$a_j$小，我们可以用线段树实现这一操作。\n将$a_j$设为无穷大。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r) int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } ","date":1587772800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587772800,"objectID":"e25e11c73bfcbf9affa3cdd580a520d9","permalink":"https://tgc54.com/zh/post/cf1187d/","publishdate":"2020-04-25T00:00:00Z","relpermalink":"/zh/post/cf1187d/","section":"zh","summary":"","tags":["数据结构","线段树"],"title":"Codeforces 1187D - Subarray Sorting 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"yysy这种题想出来真的爽。\n题解 这道题有很多不同的dp方法。这里我将描述一下我认为比较标准的方法。当然有更短的做法但是也看不懂啊QAQ。\n首先定义一下dp状态，设$dp_{i,j}$为前i个数的答案并且最后一个选的数的下标是$i-j$。\n通过观察不难发现如果$i$是奇数，那么j最大是2，否则j最大是1。这点可以通过取$1,3,5,\\dots$的数来验证。\n现在我们可以考虑状态转移了。如果$i$是奇数，那么选的数的个数和$i-1$是一样的。所以$dp_{i,j}$应该等于$dp_{i-1,j-1}$除了$dp_{i,0}$，因为$a_i$在计算$dp_{i-1,j}$的时候并没有被考虑到，所以$dp_{i,0}$应该从$dp_{i-2,j}$转移过来。以下是状态转移方程:\n$$ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,0}\\\\ dp_{i,2}\u0026amp;=dp_{i-1,1}\\end{align*} $$\n当$i$为偶数，要比$i-1$多选一个数，想法基本类似。状态转移如下：\n\\[ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{align*} \\]\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } ","date":1587686400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587686400,"objectID":"e4c85fb8ac73cbddb509902da3ed9947","permalink":"https://tgc54.com/zh/post/abc162f/","publishdate":"2020-04-24T00:00:00Z","relpermalink":"/zh/post/abc162f/","section":"zh","summary":"yysy这种题想出来真的爽。\n","tags":["动态规划"],"title":"Atcoder beginner contest 162F -  Select Half Select Half 题解","type":"zh"},{"authors":null,"categories":["杂项"],"content":"仅用做提醒自己，看不懂概不负责～\nLIS 和 LNDS int LIS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=lower_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } int LNDS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=upper_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } Maximum subarray sum int cur=0, max_sum=0;//max_sum=-1e8 if at least one element must be chosen for(auto it:a){ cur=max(cur+it,it); max_sum=max(max_sum,cur); } 整数三分 以求函数最大值为例\nwhile(l\u0026lt;r-2){ int m=(l+r)/2; if(cal(m)\u0026gt;cal(m+1)) r=m+1; else l=m; } int ans=max({cal(l),cal(l+1),cal(r)}); 把n分成k组 int sz=n/k 有n%k组有sz+1个，k-n%k组有sz个。\n快速范围判断 判断是否在[0, N)，常用于bfs/dfs边界判断\nif((unsigned)x\u0026lt;N) 判断是否在[l, r]内\nif((x-l|r-x)\u0026gt;=0) 根据两数之和和异或值反推两数 原理：a+b==(a^b)+2*(a\u0026amp;b)\n如果$sum-xor$是奇数，那么无解。\n否则$A=(sum-xor)/2$，根据A和xor的每一位填就行了，注意如果某一位两数都是1的话也是无解。\n优先队列模板参数自动推断 可以少写一点代码，需要比较新的g++版本。\npriority_queue q(greater{}, vector\u0026lt;int\u0026gt;{}); 精确计算$\\lceil\\log_2 x\\rceil$ x==1 ? 0 : __lg(x-1)+1; 用交换相邻元素的排序数组的最小操作次数 是数组中逆序对的数目\na个0，b个1组成的01字符串字典序第k小 先预处理i个0,j个1的字符串个数，然后从高位到底位枚举\nvector dp(a+1, vector(b+1, 0LL)); dp[0][0]=1; for (int i=0; i\u0026lt;=a; i++) { for (int j=0; j\u0026lt;=b; j++) { if (i\u0026gt;0) { dp[i][j]+=dp[i-1][j]; } if (j) { dp[i][j]+=dp[i][j-1]; } } } auto find_kth=[\u0026amp;](auto\u0026amp; find_kth, int A, int B, ll k) { if (A==0) return string(B, \u0026#39;b\u0026#39;); if (B==0) return string(A, \u0026#39;a\u0026#39;); if (k\u0026lt;=dp[A-1][B]) return \u0026#34;a\u0026#34;+find_kth(find_kth, A-1, B, k); return \u0026#34;b\u0026#34;+find_kth(find_kth, A, B-1, k-dp[A-1][B]); }; 位运算技巧 可以看这\n冒泡排序遍历的次数 创建一个复制数组b，其中$b[i]={a[i], i}$，然后排序b，排序后$b[i].second-i$的最大值就是答案，$b[i].second-i$本质上就是一个数向前移动的距离，不难想出每个会向前移动的数从第一轮遍历就会开始向前移动，直到到达排序后的位置，所以最大的向前移动距离就是遍历的轮数。\n","date":1587427200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587427200,"objectID":"6cb0340dac304b5bf65e398004c434fc","permalink":"https://tgc54.com/zh/post/cp_tricks/","publishdate":"2020-04-21T00:00:00Z","relpermalink":"/zh/post/cp_tricks/","section":"zh","summary":"仅用做提醒自己，看不懂概不负责～\n","tags":null,"title":"算法竞赛杂记","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; Time complexity is $O(q\\cdot \\log n\\cdot \\log n)$, which suffices but we can still optimize it.\nIn fact, the binary search part could be done during the query on the segment tree. First let’s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the segment tree, $s$ be the number of occurrence of numbers ranged in$(r,y]$. The sudo code of the query function would look like this:\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//the (mid,y] has more numbers than we need, so the answer must be in the right part return query(l,mid,s+cnt);//the numbers in the right part is not enough, so the answer is in the left part. } Now the time complexity is $O(n\\log n)$. Please refer to the code in the end for the better understanding of the implementation.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } ","date":1587168e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587168e3,"objectID":"1a8d66665f51a37125f3e18ebd58c870","permalink":"https://tgc54.com/post/hdu6278/","publishdate":"2020-04-18T00:00:00Z","relpermalink":"/post/hdu6278/","section":"post","summary":"","tags":["Data Structure","Segment Tree","Persistent Segment Tree","Binary Search"],"title":"Editorial for HDU6278 - Just h-index","type":"post"},{"authors":null,"categories":["题解"],"content":"主席树！\n题解 用主席树我们可以知道在给定区间里的所有数的出现次数。我们可以比较容易的想到一个二分做法：\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; 这种做法的时间复杂度是$O(n\\log n\\log n)$。足够通过本题，但还有优化的地方。事实上，二分部分可以在树上查询的时候完成。首先我们规定几个变量：$[x,y]$为当前询问的区间，$[l,r]$为当前在树上查询的区间，$s$为$(r,y]$里数字的出现次数。伪代码大概是这样：\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//(mid,y]中的数比mid大，也就是说答案在右边的区间 return query(l,mid,s+cnt);//(mid,y]的数不够多，答案在左边的区间 } Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } ","date":1587168e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587168e3,"objectID":"5fef7b902f45ca575547fc43ff81fbc1","permalink":"https://tgc54.com/zh/post/hdu6278/","publishdate":"2020-04-18T00:00:00Z","relpermalink":"/zh/post/hdu6278/","section":"zh","summary":"主席树！\n","tags":["数据结构","线段树","主席树","二分"],"title":"HDU6278 - Just h-index 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s factor $D$, so $D=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. According to the definition, to factors are connected iff they differ by only one prime factor. And the weight of the edge is $d(x)-d(y)$ where $d(i)$ is the number of factors of $i$. So the length of a path where $v_1\u0026lt;v_2\u0026lt;\\dots\u0026lt;v_k$ is $d(v_k)-d(v_i)$\nThere are only two types of paths between $x$ and $y$, one is $x \\rightarrow\\gcd(x,y)\\rightarrow y$ and the other is $x \\rightarrow \\operatorname{lcm}(x,y) \\rightarrow y$. The length of the path of the first type is\n$$d(x)-d(\\gcd(x,y))+d(y)+d(\\gcd(x,y))=d(x)+d(y)-2\\cdot d(\\gcd(x,y))$$\nThe length of the second type is\n$$d(\\operatorname{lcm}(x,y))-d(x)+d(\\operatorname{lcm}(x,y))-d(y)=2\\cdot d(\\operatorname{lcm}(x,y))-d(x)-d(y)$$\nIntuition tells us first type is always the shortest path.\nAll we need now is to calculate the number of shortest paths. Let $\\frac x {\\gcd(x,y)}=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. The number of shortest path between $x$ and $\\gcd(x,y)$ is\n$$\\dfrac {(e_1+e_2+\\dots e_k)!}{e_1!\\cdot e_2!\\cdot\\ldots\\cdot e_k!}$$\nSimilarly we can calculate the number of paths between $y$ and $\\gcd(x,y)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr ll mod=998244353; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; factor; for(ll f=2;f*f\u0026lt;=n;f++){ if(n%f==0){ factor.push_back(f); while(n%f==0) n/=f; } } if(n\u0026gt;1) factor.push_back(n); array\u0026lt;ll,1000\u0026gt; fac,inv; fac[0]=inv[0]=1; for(int i=1;i\u0026lt;1000;i++) fac[i]=fac[i-1]*i%mod; inv[999]=binpow(fac[999],mod-2); for(int i=998;i\u0026gt;0;i--) inv[i]=inv[i+1]*(i+1)%mod; auto count=[\u0026amp;](ll x,ll y){ x/=y; ll ret=1,sum=0; for(auto it:factor){ int tmp=0; while(x%it==0){ tmp++; x/=it; } ret=ret*inv[tmp]%mod; sum+=tmp; } ret=ret*fac[sum]%mod; return ret; }; int q; cin\u0026gt;\u0026gt;q; while(q--){ ll x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll g=gcd(x,y); cout\u0026lt;\u0026lt;count(x,g)*count(y,g)%mod\u0026lt;\u0026lt;endl; } return 0; } ","date":1586563200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586563200,"objectID":"cb5d68aaebdcc382a9e65bb26a97876f","permalink":"https://tgc54.com/post/cf1334e/","publishdate":"2020-04-11T00:00:00Z","relpermalink":"/post/cf1334e/","section":"post","summary":"","tags":["Math","Number Theory"],"title":"Editorial of Codeforces 1334E - Divisor Paths","type":"post"},{"authors":null,"categories":["题解"],"content":"题目本身就很好，同时又能带来对树状数组的一些思考。\n题解 我们要倒着处理，对于当前的$i$，会存在一个$k$，使得$k$个还没有用过的最小的数的和为$s_i$。那么当前$i$的答案就是$k+1$。可以用树状数组配二分找，也可以用树状数组配倍增黑科技求。\nCode 二分 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } 倍增 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1586476800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586476800,"objectID":"c15bf8fc0923820db60bf80729e1adbc","permalink":"https://tgc54.com/zh/post/cf1208d/","publishdate":"2020-04-10T00:00:00Z","relpermalink":"/zh/post/cf1208d/","section":"zh","summary":"题目本身就很好，同时又能带来对树状数组的一些思考。\n","tags":["二分","数据结构","树状数组"],"title":"Codeforces 1208D- Restore Permutation 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"妈个唧看错题了\nSolution If there’s only one element in the set, the graph is obvious bipartite. If there’s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\n题解 一点中文不写也不太好，万一有人看呢……简单写一下要点吧，这题关键在于理解环是怎么形成的，环的长度是多少，以及为什么当且仅当两个数包含相同2的幂的时候环的长度是偶数。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } 参考资料 https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n","date":1586390400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586390400,"objectID":"407c0730683fca4b40289f78d3a77935","permalink":"https://tgc54.com/zh/post/cf1220d/","publishdate":"2020-04-09T00:00:00Z","relpermalink":"/zh/post/cf1220d/","section":"zh","summary":"妈个唧看错题了\n","tags":["数学","数论"],"title":"Codeforces 1220D - Alex and Julian 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"优雅的解法。\n题解 首先我们可以忽略第一层方块。设$dp_{s,b}$表示把$b$个方块放在$s$堆上放法的数量。（有些堆可以是空的)\n现在我们考虑一下转移方程，有三种情况：\n第一层是满的 最左边的堆是空的 在右边的堆是空的 第一种情况我们可以忽略掉第一层，放置的方法就是$dp_{s,b-s}$. 第二，三种情况我们可以忽略掉空的那一堆，所以有$2\\cdot dp_{s-1,b}$种放法，但两种情况有重叠，因为有可能左右两堆都是空的，所以要减掉$dp_{s-2,b}$。综上所述，转移方程就是：\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}-dp_{s-2,b}$$\n这个可以用记忆化搜索来求。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } ","date":1586131200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586131200,"objectID":"39fa3dcde019e161583394792e577e6d","permalink":"https://tgc54.com/zh/post/gym102428f/","publishdate":"2020-04-06T00:00:00Z","relpermalink":"/zh/post/gym102428f/","section":"zh","summary":"优雅的解法。\n","tags":["动态规划"],"title":"Gym 102428F - Fabricating Sculptures 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Such an elegant and amazing solution.\nSolution First we can ignore first level of blocks. Let $dp_{s,b}$ be the number of ways to put $b$ blocks on $s$ stacks(some stacks could be empty).\nNow let’s consider transition, there are three cases:\nThe first level is full The leftmost stack is empty The rightmost stack is empty For the first case we can simply ignore the first level and the number of ways is $dp_{s,b-s}$. For the second and the third case, we can ignore the empty stack and the answer is $2\\cdot dp_{s-1,b}$. However, the two cases overlap, since the scenario where both the leftmost and the rightmost stacks are empty can be reached from both cases. So we need to subtract $dp_{s-2,b}$. Overall, the formula is:\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}+dp_{s-2,b}$$\nThis can be calculated recursively with memoization.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } ","date":1586131200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586131200,"objectID":"259cdce95a7a9f8479e1be1562fd11d9","permalink":"https://tgc54.com/post/gym102428f/","publishdate":"2020-04-06T00:00:00Z","relpermalink":"/post/gym102428f/","section":"post","summary":"Such an elegant and amazing solution.\n","tags":["DP"],"title":"Solution for Gym 102428F - Fabricating Sculptures","type":"post"},{"authors":null,"categories":["题解"],"content":"妙啊！\n题解 我们可以构造一个数组$L$使得第$x$个工作日不早于第$L_x$天，通过从前往后尽可能早的选择工作日。同样地，我们可以构造$R$数组使得第$x$个工作日不晚于$R_x$天，通过从后往前选择。他必须在第$i$天工作当且仅当存在$x$使得$L_x=R_x=i$。可以在$O(N)$的时间内解决。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } ","date":1586044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586044800,"objectID":"7bb895be81872da4d3950255318d4b39","permalink":"https://tgc54.com/zh/post/abc161e/","publishdate":"2020-04-05T00:00:00Z","relpermalink":"/zh/post/abc161e/","section":"zh","summary":"妙啊！\n","tags":["贪心"],"title":"AtCoder Beginner Contest 161E - Yutori 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution WLOG, assume $a\\leq b\\leq c$. If we choose only one stone, the diameter of the sphere is $\\frac a 2$. If we want to choose two stones, we should find another stone whose two of its edges are $b$ and $c$, since we must expand the shortest side to get a bigger sphere. We can use a set to maintain the length of the edge and the index.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; ans; int best=0; map\u0026lt;pii,pii\u0026gt; mp; for1(i,n){ int a[3]; forn(i,3) cin\u0026gt;\u0026gt;a[i]; sort(a,a+3); if(a[0]\u0026gt;best){ ans={i}; best=a[0]; } if(mp.count({a[1],a[2]})){ auto p=mp[{a[1],a[2]}]; int now=min({a[1],a[2],a[0]+p.F}); if(now\u0026gt;best){ best=now; ans={i,p.S}; } } mp[{a[0],a[1]}]=max(mp[{a[0],a[1]}],{a[2],i}); mp[{a[0],a[2]}]=max(mp[{a[0],a[2]}],{a[1],i}); mp[{a[1],a[2]}]=max(mp[{a[1],a[2]}],{a[0],i}); } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1585958400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585958400,"objectID":"ab3f83a898ca514ecf184aa486117956","permalink":"https://tgc54.com/post/cf733d/","publishdate":"2020-04-04T00:00:00Z","relpermalink":"/post/cf733d/","section":"post","summary":"","tags":null,"title":"Solution for CodeForces 733D - Kostya the Sculptor","type":"post"},{"authors":null,"categories":["题解"],"content":"现在看来当时是真的菜，不过还是能学到一些奇怪的知识233\n题解 最多有$10^6$对$(x,y)$，所以我们可以直接遍历所有的对。每一对有$\\dfrac 1 {n\\cdot k_x}$的概率被选中，所以一个合法的$(x,y,z)$的概率是$\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$，其中$cnt_y$是想要y礼物的孩子的个数。\n一个有意思的性质是$\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$，当$p$与分母互质的时候成立，所以我们在遍历的时候可以直接把概率转换成$cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$然后加到答案上。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1585785600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585785600,"objectID":"0230259dc32ec47ee65eb42c7a585531","permalink":"https://tgc54.com/zh/post/cf1279d/","publishdate":"2020-04-02T00:00:00Z","relpermalink":"/zh/post/cf1279d/","section":"zh","summary":"现在看来当时是真的菜，不过还是能学到一些奇怪的知识233\n","tags":["数学","概率"],"title":"CodeForces 1279D - Santa's Bot 题解","type":"zh"},{"authors":null,"categories":["Linux"],"content":"随缘更新，想到啥就记啥\n配置 触摸板 一开始发现触摸板右键和左键效果是一样的，双指轻按还是中键……\n解决方法：\n编辑 /etc/X11/xorg.conf.d/30-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; Option \u0026#34;ButtonMapping\u0026#34; \u0026#34;1 3 2\u0026#34; Option \u0026#34;TappingButtonMap\u0026#34; \u0026#34;lmr\u0026#34; EndSection 映射caps+hjkl为方向键 编辑~/.Xmodmap\nclear lock keycode 43 = h H Left H keycode 44 = j J Down J keycode 45 = k K Up K keycode 46 = l L Right L keycode 66 = Mode_switch Caps_Lock keycode 31 = i I KP_Home I keycode 32 = o O KP_End O Then update xmodmap:\n{% highlight shell %} xmodmap ~/.Xmodmap {% endhighlight %}\n解决挂起后失效的问题：\n{% highlight shell %} sudo touch /usr/lib/systemd/system-sleep/xkeyboard sudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard {% endhighlight %}\n编辑xkeyboard\n#!/bin/bash case $1 in pre) exit 0 ;; post) export DISPLAY=:0 sleep 10 xmodmap /home/thallium/.Xmodmap ;; esac 主题 arc\n{% highlight shell %} sudo pacman -S arc-gtk-theme {% endhighlight %}\n软件 vim配置 待更新\nfcitx码表 待更新\nAutojump 快速跳转文件夹，再也不用长长的cd了～\n安装 {% highlight shell %} yay autojump {% endhighlight %}\nSource the correct autojump file {% highlight shell %} echo “/usr/share/autojump/autojump.bash” » ~/.bashrc chmod 755 /usr/share/autojump/autojump.bash source ~/.bashrc {% endhighlight %}\n注意事项 快速跳转的文件夹需要正常访问一次。\n截图: Deepin screenshot 一开始用的是火焰截图，但是不能自动识别窗口，后来偶然发现deepin screenshot感觉挺不错的。\n{% highlight shell %} sudo pacman -S deepin-screenshot {% endhighlight %}\n如果不能正常复制到剪贴板，安装xfce4-clipman\n词典 Wudao dict\n安装：\n{% highlight shell %} git clone https://github.com/chestnutheng/wudao-dict cd ./wudao-dict/wudao-dict sudo bash setup.sh {% endhighlight %}\n问题解决 修改/etc/profile导致循环登录 2020.03.27\n一般的解决方法是从命令行登录然后恢复之前的修改，但我从命令行也是循环登录……于是想到能不能从windows修改然后发现有个软件叫linux file system for windows，然后问题就解决了。真的太不容易了，心态差点崩了……\nGnome-shell内存泄漏问题 gnome传统艺能，alt+F2再输入r可以重新启动shell。\n让gvim默认在新标签中启动 编辑/usr/share/applications/gvim.desktop\n把 {% highlight shell %} Exec=gvim -f %F {% endhighlight %} 改成 {% highlight shell %} Exec=gvim -p –remote-tab-silent %F {% endhighlight %}\ni3wm下运行QQ/TIM/Wechat 2020-04-13\n原作者\n{% highlight shell %} nohup /usr/lib/gsd-xsettings \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd /opt/deepinwine/apps/Deepin-TIM ./run.sh {% endhighlight %}\n最后将第一步添加到i3启动项里。\n","date":1585267200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585267200,"objectID":"faef6d08fe786e27c0c7729295e80e84","permalink":"https://tgc54.com/zh/post/manjaro-setup/","publishdate":"2020-03-27T00:00:00Z","relpermalink":"/zh/post/manjaro-setup/","section":"zh","summary":"随缘更新，想到啥就记啥\n","tags":["Linux"],"title":"Manjaro 折腾记录","type":"zh"},{"authors":null,"categories":["题解"],"content":"看了一上午才看明白大佬的代码\n题解 dp[i][j]表示前i个数里面序列和是j的答案，也就是说把题目要求改成前i个数，和是j时的答案。\n当我们处理新的数的时候，假设这个数是x，当前在第i位。很明显前面的序列可以重复使用。现在我们再考虑新的数对答案的贡献：\n首先，新数自己就可以作为一个序列，所以我们有dp[i][x]=i。其次，新的数还可以和前面的序列形成新的序列，所以对于所有$j\\ge x$，我们有dp[i][j]+=dp[i-1][j-x]。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1585094400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585094400,"objectID":"570186ca9331b3ef87824d0ab6180800","permalink":"https://tgc54.com/zh/post/abc159e/","publishdate":"2020-03-25T00:00:00Z","relpermalink":"/zh/post/abc159e/","section":"zh","summary":"看了一上午才看明白大佬的代码\n","tags":["动态规划"],"title":"AtCoder Beginner Contest 159E - Dividing Chocolate 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } ","date":1584835200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584835200,"objectID":"c80a7659cd08a6d27b3bfbabdc5c4327","permalink":"https://tgc54.com/zh/post/cf1037d/","publishdate":"2020-03-22T00:00:00Z","relpermalink":"/zh/post/cf1037d/","section":"zh","summary":"","tags":["BFS","图论"],"title":"CodeForces 1037D - Valid BFS? 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"我怎么连找环都不会\n题解 不论从哪开始，最终都会陷入循环（包括自环），所以把陷阱放在环上永远是最优的。所以这个题就是要找到所有环然后找出每个环上的最小花费。\n找环应该算是比基础的技巧了，但我是第一次遇到这种题（太菜了）。可以在这学如何找环。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1584748800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584748800,"objectID":"9534b5a2886e46013e674da0fb23be81","permalink":"https://tgc54.com/zh/post/cf1027d/","publishdate":"2020-03-21T00:00:00Z","relpermalink":"/zh/post/cf1027d/","section":"zh","summary":"我怎么连找环都不会\n","tags":["DFS","图论"],"title":"CodeForces 1027D - Mouse Hunt","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Link\nSolution The solution combines shortest paths and 0/1 knapsack algorithms:\nFirst step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in $O(n)$ using topological sort. Update the cost while doing topological sort:\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost cost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige pre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The next part is more familiar: using 0/1 knapsack algorithm to find the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort ms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack for1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } ","date":1584144e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584144e3,"objectID":"795058df00ec226b19984fa748279acb","permalink":"https://tgc54.com/post/swerc2017e/","publishdate":"2020-03-14T00:00:00Z","relpermalink":"/post/swerc2017e/","section":"post","summary":"","tags":["Graph Theory","Shortest Path","Topological Sort","DP","Knapsack"],"title":"Solution for SWERC2017 E - Ingredients","type":"post"},{"authors":null,"categories":["题解"],"content":"竟然一次就过了\nLink\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost cost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige pre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.\n题解 这个题结合了最短路和0/1背包算法。\n第一步是找到所有菜品的最小花费，也就是DAG上的最短路。这个可以用拓扑排序在$O(n)$的时间内解决，具体实现看上面的代码解释。\n第二步就是非常标准的0/1背包了，没什么好说的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort ms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack for1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } ","date":1584144e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584144e3,"objectID":"94d5d161665724f6afbb06d4d57bc0b4","permalink":"https://tgc54.com/zh/post/swerc2017e/","publishdate":"2020-03-14T00:00:00Z","relpermalink":"/zh/post/swerc2017e/","section":"zh","summary":"竟然一次就过了\n","tags":["图论","最短路","拓扑排序","动态规划","背包问题"],"title":"SWERC2017 E - Ingredients 题解","type":"zh"},{"authors":null,"categories":["Alg Notes"],"content":"Basic usage of Policy-Based Data Structure (PB_DS)\nHash Table Usage #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table Use it like a unordered_map.\nA slightly better hash Function struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; Unbeatable hash function struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; Balanced BST Declaration Header #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; Make a map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a multi-set tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Alternatively, you can use std::less_equal, but lower_bound and upper_bound will swap their functionality.\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Beyond std::set : ranking Your must use tree_order_statistics_node_update to get order statistic:\nsize_type order_of_key(key_const_reference);// returns the number of elements that are smaller than key iterator find_by_order(size_type order)// order starts from 0 Use lower_bound and upper_bound to find precursor and successor Find precursor:\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set Find successor\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); Priority Queue Prototype template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; Usage Just use the default parameter and you will get the best performance(must include the namespace):\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt; __gnu_pbds::priority_queue\u0026lt;int\u0026gt;; All the five tags:\nbinary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag What’s different from std::priority_queue point_iterator push(const_reference r_val);//return a iterator after push void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other)//clean other after join void split(Pred prd,priority_queue \u0026amp;other) void modify(point_iterator it,const key) begin(); end();//begin and end iterator Reference Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_ds库的一些常用方法\n用 pbds 过 luogu P3369【模板】普通平衡树\n","date":1584057600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584057600,"objectID":"1ebae1fea5c589e737fe38ad6f61c11e","permalink":"https://tgc54.com/post/pbds_basic_usage/","publishdate":"2020-03-13T00:00:00Z","relpermalink":"/post/pbds_basic_usage/","section":"post","summary":"Basic usage of Policy-Based Data Structure (PB_DS)\n","tags":null,"title":"Basic Usage of PB_DS","type":"post"},{"authors":null,"categories":["杂项"],"content":"Policy-Based Data Structure(PB_DS)的基础用法\n哈希表 用法 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table 可以像unordered_map一样用。\n稍微好一点的哈希函数 struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; 无敌哈希函数 struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; 平衡树 声明 头文件 #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; 用作std::map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 用作std::set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 用作std::multiset tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 也可以用std::less_equal，但lower_bound 和 upper_bound 函数会交换功能并且find会失效，所以谨慎使用。\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 比std::set更强的功能：排名 必须在声明里用tree_order_statistics_node_update以获得与排名相关的功能:\nsize_type order_of_key(key_const_reference);// 返回比key小的元素的个数 iterator find_by_order(size_type order) // 返回排名为order的元素的迭代器，排名从0开始 e.g. 求逆序对\n#include \u0026lt;bits/extc++.h\u0026gt; using namespace std; using namespace __gnu_pbds; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); // 注意此处用了less_equal以允许重复的元素 tree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; st; int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (auto\u0026amp; x : a) cin \u0026gt;\u0026gt; x; long long ans=0; for (int i=n-1; i\u0026gt;=0; i--) { ans += st.order_of_key(a[i]); st.insert(a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 使用 lower_bound 和 upper_bound 找前驱和后继 前驱：\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set 后继：\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); 优先队列 原型 template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; 用法 默认的模板参数就是性能最好的，注意必须要带上__gnu_pbds命名空间以区分std::priority_queue。\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt; __gnu_pbds::priority_queue\u0026lt;int\u0026gt;; 所有的5种tag:\nbinary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag 和 std::priority_queue的不同之处 point_iterator push(const_reference r_val); //push会返回指向插入后元素的point迭代器（和遍历迭代器不一样） void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other) //合并两个堆同时清空other void split(Pred prd,priority_queue \u0026amp;other) // 根据prd函数的返回值（true或false）分裂两个堆 void modify(point_iterator it,const key) // 某些堆支持快速修改堆中的元素，比如用在dijkstra中 begin(); end();//begin 和 end 迭代器 参考资料 Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_ds库的一些常用方法\n用 pbds 过 luogu P3369【模板】普通平衡树\n","date":1584057600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584057600,"objectID":"5e4fb43da4934734bbd1c902eec0ee92","permalink":"https://tgc54.com/zh/post/pbds_basic_usage/","publishdate":"2020-03-13T00:00:00Z","relpermalink":"/zh/post/pbds_basic_usage/","section":"zh","summary":"Policy-Based Data Structure(PB_DS)的基础用法\n","tags":["数据结构"],"title":"PB_DS的基础用法","type":"zh"},{"authors":null,"categories":["题解"],"content":"好题！\n题解 答案分两步dfs，第一个dfs用来计算$sub_i$： $i$的子树中的的子图的最大差值。稍微有点绕，其实题目中的“子树”应该叫子图比较合适，因为是无根树，说子图没什么意义。但我们dfs的时候其实是把图当成有根树，所以第一次dfs得到的答案只考虑了子树的贡献，剩余部分的贡献由第二个dfs算。其他部分的贡献看英文吧……懒得再写一遍了（逃）。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1583971200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583971200,"objectID":"1c06fafd295bcb7fb1d3ee0143cd04a3","permalink":"https://tgc54.com/zh/post/cf1324f/","publishdate":"2020-03-12T00:00:00Z","relpermalink":"/zh/post/cf1324f/","section":"zh","summary":"好题！\n","tags":["DFS","动态规划","树"],"title":"CodeForces 1324F - Maximum White Subtree 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS.\nThe second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let $v$ be the children of node $i$, if $sub_v\u0026gt;0$, the contribution is $ans_i-sub_v$ since we don’t want to count the contribution of subtree twice. If $sub_v\\leq 0$, we don’t need to subtract $sub_v$ since we didn’t count it in $ans_i$. If $ans_i-sub_v\u0026lt;0$, it’s useless for $ans_v$. Thus, the contribution of other part is $\\max(ans_i-\\max(sub_v,0),0)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1583971200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583971200,"objectID":"020fea8600bea1234d92d645d89049dd","permalink":"https://tgc54.com/post/cf1324f/","publishdate":"2020-03-12T00:00:00Z","relpermalink":"/post/cf1324f/","section":"post","summary":"","tags":["DFS","DP","Tree"],"title":"Solution for CodeForces 1324F - Maximum White Subtree","type":"post"},{"authors":null,"categories":["Solutions"],"content":"My math is sh!t.\nAdapted from the original tutorial.\nSolution First of all, there will be $n-1$ distinct elements in the array and there are $m\\choose{n-1}$ways to choose.\nNext, there are $n-2$ elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are $2^{n-3}$ ways to choose their positions.\nIn summary, the answer is ${{m}\\choose{n - 1}} (n - 2)2^{n - 3}$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int mod=998244353; ll bipow(ll a,int b){ ll ans=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) ans=ans*a%mod; a=a*a%mod; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; if(n==2) return cout\u0026lt;\u0026lt;0,0; ll ans=1,r=1; for1(i,m) ans=ans*i%mod; for1(i,n-1) r=r*i%mod; for1(i,m-n+1) r=r*i%mod; ans=ans*bipow(r,mod-2)%mod*(n-2)%mod; ans=ans*bipow(2,n-3)%mod; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1583798400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583798400,"objectID":"3fa273de67c3f66da4cbd758ac5d42b0","permalink":"https://tgc54.com/post/cf1312d/","publishdate":"2020-03-10T00:00:00Z","relpermalink":"/post/cf1312d/","section":"post","summary":"My math is sh!t.\n","tags":["Math","Combinatorics"],"title":"Solution for CodeForces 1312D - Count the Arrays","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s use BFS to find the distance from node $1$ and node $n$ to all nodes. Let $x_i$ be the distance to node $1$ and $y_i$ be the distance to node $n$.\nNow we want to choose two nodes $a$ and $b$ such that $\\min(x_a+y_b,x_b+y_a)$ is maximized. Without losing generality, assume $x_a+y_b\\leq x_b+y_a$. That is to say we want to maximize $x_a+y_b$ subject to $x_a+y_b\\leq x_b+y_a$. So we can sort by $x_i-y_i$ and iterate over $y$ while keeping the maximum value of $x_a$ before $y_b$.\nAlso note that the answer cannot be bigger than the distance between node $1$ and $n$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void bfs(vector\u0026lt;int\u0026gt;\u0026amp; dis,int s){ queue\u0026lt;int\u0026gt; q; q.push(s); dis[s]=0; while(!q.empty()){ int now=q.front(); q.pop(); for(int next:G[now]){ if(dis[next]==INF){ dis[next]=dis[now]+1; q.push(next); } } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; sp(k); for(auto\u0026amp; it:sp) cin\u0026gt;\u0026gt;it; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; dis1(n+1,INF),dis2(n+1,INF); bfs(dis1,1); bfs(dis2,n); vector\u0026lt;pii\u0026gt; data(k); forn(i,k) data[i]={dis1[sp[i]]-dis2[sp[i]],sp[i]}; sort(all(data)); int best=0,mx=-INF; for(auto it:data){ int a=it.S; best=max(best,mx+dis2[a]); mx=max(mx,dis1[a]); } cout\u0026lt;\u0026lt;min(dis1[n],best+1); return 0; } ","date":1583452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583452800,"objectID":"5ca7caafc8fc8edebd563e74ef379896","permalink":"https://tgc54.com/post/cf1307d/","publishdate":"2020-03-06T00:00:00Z","relpermalink":"/post/cf1307d/","section":"post","summary":"","tags":["BFS","Graph Theory"],"title":"Solution for CodeForces 1307D - Cow and Fields","type":"post"},{"authors":null,"categories":["题解"],"content":"题解 这个题有点贪心的意思，我们可以把每一个水箱看作是一些由连续水箱组成的组，每个组一开始的大小都是1。如果当前的组的平均值比左边的组的平均值小的话，就合并这两个组。用栈存储之前组的大小和水量的和。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582934400,"objectID":"1b854bb0672d95cb8a58f76be4ac3f90","permalink":"https://tgc54.com/zh/post/cf1300e/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"/zh/post/cf1300e/","section":"zh","summary":"","tags":["数据结构","单调栈"],"title":"Codeforces 1300E - Water Balance 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"妙啊\nProblem Link\n题解 我们用$A$表示输入，用$P$表示答案。$A_i-A_{i-1}$就是比$P_i$大的数字的个数因此我们也能知道比$P_i$小的数的个数。我们可以用权值线段树然后从后遍历$A$，这样我们就能得到所有没用过的比$P_i$小的数的个数，然后在线段树中找到对应的数并更新线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582934400,"objectID":"fc83c06ad614ad1009ed7076effc9cf9","permalink":"https://tgc54.com/zh/post/hdu5592/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"/zh/post/hdu5592/","section":"zh","summary":"妙啊\n","tags":["数据结构","线段树"],"title":"HDU 5592 - ZYB's Premutation 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Monotone stack is such an interest stuff.\nSolution To be honest, I don’t really know how to explain the solution clearly. It’s kind of a “greedy” solution: for each tank, you try to use this to reduce the water in previous tanks. Specifically, you can see water tanks as a succession of groups, if the current group has a smaller average value than the left one, then merge them. The stack is used to store the number of tanks and the sum of water.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582934400,"objectID":"15bae960ea2bc83b6d6bff076547ff3a","permalink":"https://tgc54.com/post/cf1300e/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"/post/cf1300e/","section":"post","summary":"Monotone stack is such an interest stuff.\n","tags":["Data Structure","Monotonic Stack"],"title":"Solution for CodeForces 1300E - Water Balance","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Problem Link\nSolution Let the input be $A$ and the answer be $P$. $A_i-A_{i-1}$ is the number of numbers that are greater than $P_i$, so we can also know the how many numbers are smaller than $P_i$. Now we build a segment tree which counts the occurrence of numbers in $1\\dots n$ and iterate $A$ reversely, we could know how many unused numbers are smaller than $P_i$ and then find the corresponding number in the segtree and decrease the occurrence of that number by one.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582934400,"objectID":"8fb8ef07b817fa60c36dc300c30fa881","permalink":"https://tgc54.com/post/hdu5592/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"/post/hdu5592/","section":"post","summary":"","tags":["Data Structure","Segment Tree"],"title":"Solution for HDU 5592 - ZYB's Premutation","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Problem link\nTranslation Given a sequence $a$ of length $n$ and $q$ queries in format $l,r,x$, find $\\max\\limits_{l\\leq i\\leq r}\\gcd(x,a_i)$.\nSolution Since $a_i$ is rather small, we can precalculate all the factors of all the numbers smaller than $1e5$. Then, for each factor, we store all the $i$ such that $a_i$ contains this factor in ascending order.\nFor each query, we iterate all the factors from biggest to smallest and see if we can find some number in $[l,r]$ that contains this factor. We could use binary search to achieve this.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; const int N=1e5+5; vector\u0026lt;int\u0026gt; p[N],fac[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for1(i,1e5){ for(int j=i;j\u0026lt;=1e5;j+=i) fac[j].pb(i); } for1(i,n){ int x; cin\u0026gt;\u0026gt;x; for(auto f:fac[x]) p[f].pb(i); } while(q--){ int l,r,x; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x; for(int i=fac[x].size()-1;i\u0026gt;=0;i--){ int f=fac[x][i]; if(p[f].empty()) continue; auto it=lower_bound(p[f].begin(),p[f].end(),l); if(it!=p[f].end()\u0026amp;\u0026amp;*it\u0026lt;=r){ cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; break; } } } return 0; } ","date":1582848e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582848e3,"objectID":"c6bc86bc7f5e1a0a0a21e7b97150bc53","permalink":"https://tgc54.com/post/nc4090e/","publishdate":"2020-02-28T00:00:00Z","relpermalink":"/post/nc4090e/","section":"post","summary":"Problem link\n","tags":["Math"],"title":"Solution for NewCoder 4090E - 最大GCD(max GCD)","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Time to learn monotone stack.\nSolution It’s quite obvious that the answer goes non-decreasing from the start and at some point turns to non-increasing. We want to find the optimal turning point.\nWe can build two arrays $pre$ and $suf$ of length n. The ith element of $pre$ represents the maximum sum of floors from 1 to i if the floors are non-decreasing. Similar definition for $suf$. The turning point t is where $pre_t+suf_t-m_t$ is maximum.\nFor example: let $m={1,2,3,2,1}$\n0 1 2 3 4 pre 1 3 6 7 5 suf 5 7 6 3 1 m 1 2 3 2 1 pre+suf-m 5 8 9 8 5 We can build the arrays by maintaining a mono-increasing stack stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; to find the rightest number smaller than m_i. The second element is the number of floors and first element is the number of buildings with the same height. You will understand it better in the detailed buildings process of $pre$:\ni=0\nnothing in the stack.\npre[0]+=1\nPush{1,1} to the stack and now the stack:{{1,1}}\ni=1\nFirst set pre[1]=pre[0]\nSince m[1]\u0026gt;stack.top().second, no pop.\npre[1]+=m[1]\nnow $pre_1=3$\nPush {1,2} to the stack and the stack is now:{{1,1},{1,2}}\ni=2\nSimilar to i=1.\npre[2]=6\n{{1,1},{1,2},{1,3}}\ni=3\nm[3]\u0026lt;stack.top().second which means that we need to change the height of previous buildings to keep the monotonicity. Keep popping out the bigger element and {1,3} is popped. The pre[3] should be decreased by 1*3 and is 3 now. Then the height of 2,3 should be 2 and pre[3]+=2*2. Finally we push {2,2} to the stack.\ni=4\nSimilarly, we pop out {2,2} and {1,2} and pre[4]-=2*2+1*2 and now pre[4]=1. Then the height of 1,2,3,4 should be 1 and pre[4]+=4*1. Finally push {4,1} to the stack.\nWe could build $suf$ in the similar way but go from right to left.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;ll\u0026gt; pre(n),suf(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; stk; forn(i,n){ int now=1; if(i) pre[i]=pre[i-1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; pre[i]-=stk.top().F*stk.top().S; stk.pop(); } pre[i]+=a[i]*now; stk.push({now,a[i]}); } stk=stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;(); ford(i,n){ int now=1; if(i!=n-1) suf[i]=suf[i+1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; suf[i]-=stk.top().F*stk.top().S; stk.pop(); } suf[i]+=a[i]*now; stk.push({now,a[i]}); } ll mx=0,pos; forn(i,n){ if(pre[i]+suf[i]-a[i]\u0026gt;mx){ mx=pre[i]+suf[i]-a[i]; pos=i; } } for(int i=pos-1;i\u0026gt;=0;i--){ a[i]=min(a[i+1],a[i]); } for(int i=pos+1;i\u0026lt;n;i++) a[i]=min(a[i-1],a[i]); for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1582588800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582588800,"objectID":"69da53fcd077d78c674e00512f4bb95d","permalink":"https://tgc54.com/post/cf1313c2/","publishdate":"2020-02-25T00:00:00Z","relpermalink":"/post/cf1313c2/","section":"post","summary":"Time to learn monotone stack.\n","tags":["Data Structure","Monotonic Stack"],"title":"Solution for CodeForces 1313C2 - Skyscrapers (hard version)","type":"post"},{"authors":null,"categories":["题解"],"content":"题解 我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。如果我们最后能剩下一堆的话答案就是yes。这题也可以用bfs，状态是dp是一样的，可能更好理解。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } ","date":1582329600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582329600,"objectID":"02f805cb573e0d5cec29659f0ada3eea","permalink":"https://tgc54.com/zh/post/cf208b/","publishdate":"2020-02-22T00:00:00Z","relpermalink":"/zh/post/cf208b/","section":"zh","summary":"","tags":["DFS","动态规划"],"title":"Codeforces 208B - Solitaire 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } ","date":1582329600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582329600,"objectID":"b5684ece9bae68b99c24c428d83b71cd","permalink":"https://tgc54.com/post/cf208b/","publishdate":"2020-02-22T00:00:00Z","relpermalink":"/post/cf208b/","section":"post","summary":"","tags":["DFS","DP"],"title":"Solution for Codeforces 208B - Solitaire","type":"post"},{"authors":null,"categories":["题解"],"content":"题解 这种题常见套路就是写一个求1到x答案的函数$F(x)$然后最终答案就是$F(r)-F(l-1)$。\n一种很妙的方法是我们可以通过在任意数字之后加一个第一位的数字从而得到题目要求的数字。所以如果x小于10那么答案就是x，否则答案就是去掉最后一位的x+9。如果最后一位小于第一位我们还要把答案减1。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } ","date":1582243200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582243200,"objectID":"dfdb138fc84755682102e66062d287ba","permalink":"https://tgc54.com/zh/post/cf205c/","publishdate":"2020-02-21T00:00:00Z","relpermalink":"/zh/post/cf205c/","section":"zh","summary":"","tags":["数学","组合学"],"title":"Codeforces 205D - Little Elephant and Interval 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution It’s kinda obvious that we need to write a function $F(x)$ which solves the problem $1\\dots x$ and the answer will be $F(r)-F(l-1)$.\nOne tricky way to write $F(x)$ is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What’s more, if the last digit is smaller than the first digit we have to decrease the answer by 1.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } ","date":1582243200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582243200,"objectID":"004b8d883b0b02a59fb7c008879f4e7b","permalink":"https://tgc54.com/post/cf205c/","publishdate":"2020-02-21T00:00:00Z","relpermalink":"/post/cf205c/","section":"post","summary":"","tags":["Math","Combinatorics"],"title":"Solution for Codeforces 205D - Little Elephant and Interval","type":"post"},{"authors":null,"categories":["算法笔记"],"content":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } ","date":1582070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582070400,"objectID":"0a8f1db16eea5ac2cfd83971fee2f674","permalink":"https://tgc54.com/zh/post/longestpathondag/","publishdate":"2020-02-19T00:00:00Z","relpermalink":"/zh/post/longestpathondag/","section":"zh","summary":"vector\u003cint\u003e G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; }","tags":["图论","动态规划","DFS"],"title":"DAG上最长路","type":"zh"},{"authors":null,"categories":["Alg Notes"],"content":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } ","date":1582070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582070400,"objectID":"14eafa60d96b3c7a8a3764baeaa1018e","permalink":"https://tgc54.com/post/longestpathondag/","publishdate":"2020-02-19T00:00:00Z","relpermalink":"/post/longestpathondag/","section":"post","summary":"vector\u003cint\u003e G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } ","tags":["Graph Theory","DP","DFS"],"title":"Finding the longest path on a DAG","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Learned a lot.\nIn this blog I would like to put emphasis on what I learned from other’s implementation. The idea is quite simple: for every edge E find the maximum number that appears in the paths that contain E and set that number for E, then check if there’s a contradiction. However, the implementation seems to be not easy.\nI want to talk about two techniques in this code.\nThe first one is how to find the index of the edge that we are visiting.\nInstead of using map\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt; the author uses the lower vertex of each edge to denote that edge and label them when doing the DFS. This reduces both time and space complexity.\nThe second one is how to find the path between two vertices.\nIn a rooted tree, we can find the path by finding the LCA of the two vertices. The algorithm is quite naive: jump up over and over until the two vertices meet. The author uses very short codes to achieve this:\nwhile (u != v) { if (dep[u] \u0026lt; dep[v]) swap(u, v); //do something... u = fa[u]; } Overall, the question is good and what I learned is also amazing which I think is worth writing a blog.\n","date":1580860800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580860800,"objectID":"5729bc5035fb1283230001e1a31b5013","permalink":"https://tgc54.com/post/cf1296f/","publishdate":"2020-02-05T00:00:00Z","relpermalink":"/post/cf1296f/","section":"post","summary":"Learned a lot.\n","tags":["DFS","Tree"],"title":"Solution for CodeForces 1296F - Berland Beauty and what I learned","type":"post"},{"authors":null,"categories":["题解"],"content":"FML\n题解 让$g= \\gcd(a,m)$，所以我们有$a=g\\cdot k， m=g\\cdot l,\\gcd(l,k)=1$，不难发现，如果我们想要使$\\gcd(a,m)=\\gcd(a+x,m)$， $x$必须是$g$的倍数，设$x=n\\cdot g$。 而且，$k+n$和$l$必须要互质，所以我们要找到从$k$到$k+l$中与$l$互质的数的个数。对于那些大于$l$的数，如果 $\\gcd(k+x,l)=1$那么$\\gcd((k+x)\\bmod l,l)=1$。又因为$(k+x)\\bmod l\u0026lt; l $，所以我们真正要算的是比$l$小并且与$l$互质的数的个数, 也就是$\\varphi(l)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } ","date":1580256e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580256e3,"objectID":"39d530f4d2b5ad5ed73b946c9ba8f8fb","permalink":"https://tgc54.com/zh/post/cf1295d/","publishdate":"2020-01-29T00:00:00Z","relpermalink":"/zh/post/cf1295d/","section":"zh","summary":"FML\n","tags":["数学","欧拉函数","数论"],"title":"Codeforces 1295D - Same GCDs 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"FML\nSolution Let $g= \\gcd(a,m)$, so we have $a=g\\cdot k, m=g\\cdot l,\\gcd(l,k)=1$,first observation is that if we want $\\gcd(a,m)=\\gcd(a+x,m)$, $x$ has to be a multiple of $g$, let $x=n\\cdot g$. Furthermore, $k+n$ and $l$ have to be coprime, so we need to find how many numbers ranging from $k$ to $k+l$ are coprime with $l$. For numbers bigger than $l$, if $\\gcd(k+x,l)=1$, then $\\gcd((k+x)\\bmod l,l)=1$. Since $(k+x)\\bmod l\u0026lt; l$, what we actually need to find is the number of numbers that are coprime with $l$ and smaller than $l$, i.e. $\\varphi(l)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } ","date":1580256e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580256e3,"objectID":"5b6c62af14c2d3a52fc331307d3dad86","permalink":"https://tgc54.com/post/cf1295d/","publishdate":"2020-01-29T00:00:00Z","relpermalink":"/post/cf1295d/","section":"post","summary":"FML\n","tags":["Math","Euler's totient function","Number Theory"],"title":"Solution for CodeForces 1295D - Same GCDs","type":"post"},{"authors":null,"categories":null,"content":"还是大佬的思路强啊。\n题解 我们可以得到所有模$x$相同的数通过加或减$x$所以我们只关注$a_i\\bmod x$。为了使mex最大化，我们需要从0开始尽可能长的连续的数。在模的意义下，也就是说$1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$。所以我们只需要保存同余类里的数的个数然后每次询问后尝试增加答案就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1579651200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579651200,"objectID":"19720984c09b95e248d3b51ee2b864a3","permalink":"https://tgc54.com/zh/post/cf1294d/","publishdate":"2020-01-22T00:00:00Z","relpermalink":"/zh/post/cf1294d/","section":"zh","summary":"还是大佬的思路强啊。\n","tags":["数学"],"title":"Codeforces 1294D - MEX maximizing 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Tutorial By adding $x$ or subtracting $x$, we can obtain any number in the same residue class so we only care about $a_i\\bmod x$. To maximize the mex, we need to obtain consecutive numbers starting from 0 as many as possible. In the perspective of modular, that means we need $1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$. Therefore, we should store the size of each residue class and try to increase the answer when we have a new number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1579651200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579651200,"objectID":"a10e14412f70ac1c2806d7683162d4b6","permalink":"https://tgc54.com/post/cf1294d/","publishdate":"2020-01-22T00:00:00Z","relpermalink":"/post/cf1294d/","section":"post","summary":"","tags":["Math"],"title":"Solution for CodeForces 1294D - MEX maximizing","type":"post"},{"authors":null,"categories":["题解"],"content":"题意： 定义如下序列的变换（由一个已知序列生成另一个序列）：\n如果序列是空的则停止，否则在新序列的最后加上当前序列所有元素的gcd，然后从原序列中移除一个元素。重复上述操作直到停止，问能得到的最大字典序的序列。\n题很简单，相信聪明的你一定能做出来。\n思路 很显然，前面几个数必然是1，所以要想让字典序尽量大就得尽快出现别的数，要想让一个数出现就得删掉全部不是它倍数的数，那么最快能出现的数就是2了，只要把所有奇数删掉就行了。然后就剩下了一堆偶数，是不是看起来似曾相识？没错他又变成了刚才的问题只不过所有数都乘了2（禁止套娃）。那啥时候停呢？当n小于3的时候，因为此时无法用刚才的规律。\n是不是很有意思呢？其实递归的题都挺有意思的。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); void solve(int x,int mul){ if(x==1) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;2*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==3) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;3*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else{ for(int i=1;i\u0026lt;=x;i+=2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; solve(x/2,mul*2); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; solve(n,1); return 0; } ","date":1578873600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578873600,"objectID":"e9dd7df4ccafc235848b75f28ac4fdef","permalink":"https://tgc54.com/zh/post/cf1059c/","publishdate":"2020-01-13T00:00:00Z","relpermalink":"/zh/post/cf1059c/","section":"zh","summary":"","tags":["构造"],"title":"Codeforces 1059C - Sequence Transformation 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"long long开小了，血的教训。\n题解 不难看出$a$和$b$必须是互质的，我们质因数分解X，最多有11个不同的质因数因为前12个质因数的积大于$1\\cdot 10^{12}$。我们可以暴力枚举所有的分配情况来得到最优的答案。\n另一种解法是遍历X的所有因数$p$然后判断$\\gcd(d,\\frac X d)$是否是1并更新答案。\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578614400,"objectID":"0e8817ccdba6defdcc03bd379d4c9f37","permalink":"https://tgc54.com/zh/post/cf1285c/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"/zh/post/cf1285c/","section":"zh","summary":"long long开小了，血的教训。\n","tags":["数学","数论"],"title":"Codeforces 1285C - Fadi and LCM 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"Almost\n题解 我们从最高位开始因为最高位对数的影响最大。我们需要把所有数分成两组，一组是当前位为1的数，另一组是当前位为0的数。如果其中一组是空的那么我们总是可以使这一位变成0然后到下一位。否则这一位总会有1，那么我们就需要对那两组解决同样的问题来知道这位是填1还是0，这很明显是个递归。设那两组的答案分别是$ans_1$和$ans_0$，当前在第$i$位，那么答案就是$2^i+\\min(ans_1,ans_0)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578614400,"objectID":"904cdc675a1330d600710388da62d2e1","permalink":"https://tgc54.com/zh/post/cf1285d/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"/zh/post/cf1285d/","section":"zh","summary":"Almost\n","tags":["构造","分治"],"title":"Codeforces 1285D - Dr. Evil Underscores 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Solution It’s quite obvious that $a$ and $b$ must be coprime. Now let’s prime factorize $X$ and there will be at most 11 distinct primes since the product of the first 12 primes is greater than $1\\cdot 10^{12}$. To find the answer we can simply distribute them between $a$ and $b$ with bruteforce.\nAnother solution is loop over all divisors $d$ of $X$, check if $\\gcd(d,\\frac X d)$ is 1 and minimize the answer.\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578614400,"objectID":"717769c0b8ad73c44465a3598af7f991","permalink":"https://tgc54.com/post/cf1285c/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"/post/cf1285c/","section":"post","summary":"","tags":["Math","Number Theory"],"title":"Solution for Codeforces 1285C - Fadi and LCM","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Almost\nSolution Let’s start with the highest bit since it’s the most significant. We need to divide elements into two groups, one with elements which is $1$ on this bit and the other with elements which is $0$ on this bit. If either group is empty, we can always assign 0 or 1 to this bit to make this bit 0 in the answer and we can just proceed to the next bit, otherwise this bit is always 1. In order to know which value to assign we will solve the same problem recursively for each of the groups for the next bit. Let the answer for the two groups be $ans_1$ and $ans_0$ and the current bit is $i$ the answer would be $2^i+\\min(ans_1,ans_0)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578614400,"objectID":"27e7e6e2f18acd2a29738fc3aebace78","permalink":"https://tgc54.com/post/cf1285d/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"/post/cf1285d/","section":"post","summary":"Almost\n","tags":["Constructive Algorithm","Divide and Conquer"],"title":"Solution for Codeforces 1285D - Dr. Evil Underscores","type":"post"},{"authors":null,"categories":["题解"],"content":"InTerEStinG.\n题解 首先我们可以用300个a和300个b来知道a和b的个数。同时答案的长度就是他们的和。\n然后假设答案都是a，如果我们把其中一位换成b那么答案要么是b个个数+1要么数b的个数-1，如果是-1那个那一位就是b否则是a。对所有位置重复上述操作就基本是答案了。\n注意此时我们用了$n+3$次询问，超过了限制，但其实最后一位不用询问，用前面的信息就能算出来。\n","date":1578268800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578268800,"objectID":"c8c73e10e096d41125ff203c7a422383","permalink":"https://tgc54.com/zh/post/cf1282d/","publishdate":"2020-01-06T00:00:00Z","relpermalink":"/zh/post/cf1282d/","section":"zh","summary":"InTerEStinG.\n","tags":["构造"],"title":"Codeforces 1282D - Enchanted Artifact 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"新年第一po！\n题解 这个题我们用并查集来合并集合并用std::list 或 std::vector来维护每个集合里面的元素。（理论上来说list应该快很多，但提交后的运行时间差不多）\n具体步骤就是：\n找到两个猫的祖先的id 合并两个集合，并且拼接两个链表（或者数组） Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"69fc2f5561ff26c71a573adc6c5d76ec","permalink":"https://tgc54.com/zh/post/cf1131f/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/zh/post/cf1131f/","section":"zh","summary":"新年第一po！\n","tags":["并查集"],"title":"Codeforces 1131F - Asya And Kittens 题解","type":"zh"},{"authors":null,"categories":null,"content":"转眼就到了2019年的最后一天了。看到了很多人的回顾和总结，又想到了今年发生的一些事情，心想我也可以写点流水账啊。\n2019发生的最大的事，莫过于我从中国来到了加拿大。当然也有很多别的事情值得回忆：学了自由泳、打了区域赛、桥式sub20、学会做菜……\n先说说留学，这个决定其实比较突然，但考虑到时间有点晚，所以准备的过程也是紧锣密鼓。对我来说最大的挑战就是考雅思，报了个网课，学一整个寒假的时间，但自己却没太努力，阅读和听力相对简单，自己最担心的还是写作和口语，尤其是口语，因为是最难练习的，再加上自己也没认真准备素材，以至于考试前夕异常紧张，果然最后成绩只有5.5。此时希望全都放在了下一次考试上面，两次考试中间的十几天也全用在了准备口语上，值得庆幸的是碰到了自己比较熟悉的话题，自我感觉良好。好歹达到了之前的目标（虽然只有6分）。从年初开始准备一直到4月中旬拿到成绩，再到4月底拿到约克的offer，这件事总算告一段落。 这一年也是acm起步的第一年，虽然中间经历了一些波折，但最后还是决定走在条路。寒假训练打开了算法进阶的门，学期刚开始训练还比较正常，考完雅思之后就开始放飞自我，天天泡在实验室，有段时间就是天天敲线段树，最后基本上做完了 “大可线段树26题”,当时感觉还是想当爽的~期间打了北交校赛，卡在了道题意不清的烂题上，被北交大佬吊打。还去了北工打了程序设计天梯赛，深刻体会到了什么叫“暴力碾标算”，最后混了个铜奖。放假前打了北林校赛，矮子里面拔高个，运气好出了6题混了第四还赚了200块，不得不说这奖金还是很大气的。\n转眼到了暑假，由于暑假集训前还有小学期，再加上在北京也没什么好待的了，于是就早早回了家，暑假集训也就不搞了，错过了一些算法，不过现在看来大部分也没机会用毕竟简单题还做不好。在家的时候考虑到了去了加拿大还要不要继续打acm，但又不知道那边的比赛情况，于是就先选择了暂时放下acm，等到了那边再说，于是一个暑假没怎么敲代码。\n到了约克没几天便收到了关于ecna regional contest选拔赛的邮件，可把我激动坏了，不出意外的拿到了参赛名额，最后6个人里面3个用C++的正好凑一个队，搞了一场训练发现队友并不强，那今年就当去玩玩熟悉比赛了。因为队友都不住在学校，一起训练不太方便，所以还是以个人训练为主，期间自己也开始打cf，码力有所恢复。\n比赛在温莎大学，教练开车带我们过去，下午到了先签到然后就等着热身赛，滑大没有放水很快就ak了，而我们最后1分钟才过了4题排第10，毕竟好多放水的，感觉状态还行，结束之后吃了点主办方提供的披萨然后我们就去宾馆了，教练定的宾馆离学校很近，条件也相当好（除了没有热水洗澡）本想早点睡的，结果和队友聊到12点多…… 第二天一早吃了早饭就赶赴赛场，虽说是来玩玩的，但比赛开始前还是相当紧张的，按照之前的计划，三个人分别读前中后，我可能是急于想快速找到签到题，读完反而没什么印象，以至于签到题也觉得比较难，而队友也读到了签到题但给我解释的时候没抓住重点，说了半天我才明白，就是在一个不单调的序列里强行二分，看是否能找到某个数，结果我用了lower_bound()wa了两发最后手写二分才过的，而此时已经52分钟了，和预计的节奏（1小时做完签到）严重不符，但还好也没拖太久，一个半小时的时候做完了所有三道签到。\n然后发现一个很多人过的dp题，但自己dp很差，写了一个wa了之后发现思路有问题，就开始怀疑是不是dp，想了很久也没什么想法就去看别的题了，看到一个中国剩余定理的板子题然而板子里并没有印，当时内心一下就凉了，也成为了这次最大的遗憾。队友说可以尝试推一下不过最后也没推出来，没过多就发现友对把那个dp题过了，然后队友就一再提醒我说那个题肯定不难因为友队不会图论，又想了好久突然开窍发现多加一个dp状态就行了，赶紧去写然而判定边界的函数没写好最后才发现，在还有半小时结束的时候过了……最后我们排34/120，友队排31，不好也不坏，反正教练挺高兴的。但我深知这绝对不是我们的水平。 回学校之后一切又回归正常，在寒假疯狂掉分之后发现之前在地大的训练非常有问题，非常不注重基本功，以至于经常卡在c题或d题，而事实上这些题都不需要多么高级的算法，于是自己开始练一些简单或中等难度的暴力和构造题，终于在2019最后一场止住了掉分同时也保住了正的净分数变化。\n最后再说说做饭吧，其实这挺神奇的，来之前完全不会做饭，感觉自己来了一下就会了哈哈，来的第二天就开始找能买菜的超市，还好学校西边有一个亚（中）洲（国）超市，这可真是太方便了。食材解决之后就是技术了，在老爸和网上的菜谱指导之下慢慢形成了自己的一套理论，其实也没什么麻烦，简单的家常菜就足够应付每日饮食了。对于学会做菜这件事自己真的是很开心的，既省钱又合自己口，这也算是一项重要的生活技能啊。\n2019真的是收获颇丰的一年，希望自己在2020能继续进步，立几个flag:\ncf1800分 区域赛进前20 成绩保持在A以上 三速至少sub15 加油，奥力给！\n","date":1577750400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577750400,"objectID":"6904d0893e15dff5f0260e06024e05cf","permalink":"https://tgc54.com/zh/post/2019summary/","publishdate":"2019-12-31T00:00:00Z","relpermalink":"/zh/post/2019summary/","section":"zh","summary":"转眼就到了2019年的最后一天了。看到了很多人的回顾和总结，又想到了今年发生的一些事情，心想我也可以写点流水账啊。\n","tags":null,"title":"我的2019","type":"zh"},{"authors":null,"categories":["题解"],"content":"这跟暴力又有什么区别呢？\n题解 我们先将所有线段的以pair\u0026lt;起点或终点的坐标,线段的序号\u0026gt;的形式存到数组里，然后再将数组排序，然后遍历数组。同时我们还需要维护一个“开放的线段”的右端点的集合。当我们添加一条新的线段时，遍历集合，然后找到比新线段早结束的线段。\n这看起来是不是很像暴力？如果要是处理完所有线段是肯定超时的，但是如果交点的个数已经大于$n-1$了，那么答案肯定是no，所以直接结束就行。\n最后还要检查一下图的连通性，用dfs或并查集都行。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } ","date":1576972800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576972800,"objectID":"ed75a179ef1b07132a752c2e9a2c51c4","permalink":"https://tgc54.com/zh/post/cf1278d/","publishdate":"2019-12-22T00:00:00Z","relpermalink":"/zh/post/cf1278d/","section":"zh","summary":"这跟暴力又有什么区别呢？\n","tags":["数据结构","并查集","树","DFS"],"title":"Codeforces 1248D - Segment Tree 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"Good DFS problem.\n题解 我们需要用DFS计算$sum_v$——$v$的子树里所有数的和，以及$m1_v$ 和 $m2_v$——v的子树里所有的$sum$里的最大和次大值(不包括$sum_v$). 计算完之后更新答案。具体实现可以看代码，挺好理解的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } ","date":1576972800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576972800,"objectID":"dcb582c0da32cc38d0d1059ec2f7ea27","permalink":"https://tgc54.com/zh/post/cf743d/","publishdate":"2019-12-22T00:00:00Z","relpermalink":"/zh/post/cf743d/","section":"zh","summary":"Good DFS problem.\n","tags":["DFS","动态规划"],"title":"Codeforces 743D - Chloe and pleasant prizes 题解","type":"zh"},{"authors":null,"categories":["Solutions"],"content":"Good DFS problem.\nSolution We need to calculate $sum_v$(sum of all the numbers in the subtree of vertex $v$) and $m1_v$ and $m2_v$ (the maximum and second maximum from all $sum$ in the subtree of vertex $v$ except $v$). Update answer after calculating $m1_v$ and $m2_v$ for each vertex. This can be done using one DFS, refer to my code for the detailed implementation.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } ","date":1576972800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576972800,"objectID":"1afe97ca3fe8b4e9ee3575b542952749","permalink":"https://tgc54.com/post/cf743d/","publishdate":"2019-12-22T00:00:00Z","relpermalink":"/post/cf743d/","section":"post","summary":"Good DFS problem.\n","tags":["DFS","DP"],"title":"Solution for Codeforces 743D - Chloe and pleasant prizes","type":"post"},{"authors":null,"categories":["题解"],"content":"越来越菜了\n题解 贪心的策略是：遍历所有点，当我们发现有被超过$k$条线段覆盖的点时，我们应该移除右端点最靠右的线段。\n为了实现我们的策略，我们需要一个数组$open_i$ 来存储以点$i$开始的线段，和数组$close_i$来存储以点$i$结束的线段。我们同时还需要维护覆盖当前点的集合，以及一个优先队列来寻找右端点最右的线段。\n具体来说，就是对于每个点，我们先往集合里插入从这个点开始的线段，然后找出应该删除的线段并删除，最后从集合里移除以这个点结束的线段。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1576713600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576713600,"objectID":"c2232501d5a506f9eeabc167c1e7395b","permalink":"https://tgc54.com/zh/post/cf1249d2/","publishdate":"2019-12-19T00:00:00Z","relpermalink":"/zh/post/cf1249d2/","section":"zh","summary":"越来越菜了\n","tags":["贪心"],"title":"Codeforces 1249D2 - Too Many Segments (hard version) 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"题解 很明显帐篷应该和学校挨着，所以我们可以用四个变量来记录学校的每一边有几个房子，最后输出最多的那一边即可。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } ","date":1576368e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576368e3,"objectID":"b6d2cd7fd272c36321d454411395f03e","permalink":"https://tgc54.com/zh/post/cf1271c/","publishdate":"2019-12-15T00:00:00Z","relpermalink":"/zh/post/cf1271c/","section":"zh","summary":"","tags":null,"title":"Codeforces 1271C - Shawarma Tent 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"题解 首先我们要计算在每个城堡通关所需要的最少勇士的数量($req_i$)， 这样我们就能知道在招募之后有多少自由支配的勇士($fr_i$)。$req_i$这么计算$req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$。$last_i$表示最后一个可以派勇士来守卫城堡$i$的城堡。现在问题就转化成了如何分配勇士来守卫这些城堡。我们用贪心的思路：按照城堡的重要程度来守卫，对于城堡$i$，如果我们能在$last_i$前面找到有空闲的勇士那么我们就可以守护这个城堡。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } ","date":1576368e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576368e3,"objectID":"d9fcffa5bcacbe065a8942007c2d71e5","permalink":"https://tgc54.com/zh/post/cf1271d/","publishdate":"2019-12-15T00:00:00Z","relpermalink":"/zh/post/cf1271d/","section":"zh","summary":"","tags":["贪心","动态规划"],"title":"Codeforces 1271D - Portals 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"比赛的时候太蠢了。\n题解 这题的关键在于答案的第一个数要么是最小的数要么是第二小的数，两种情况都试一下。填某一位的时候，要么是上一位加一，要么是上一位减一，先试减1，如果没有减1可以用了就试加1，如果加一也没有了那就可以停止去尝试以另一个数开头的情况了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } ","date":1575590400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575590400,"objectID":"ed98229eba4f9cb87c9cb4000f3b20b3","permalink":"https://tgc54.com/zh/post/cf1265d/","publishdate":"2019-12-06T00:00:00Z","relpermalink":"/zh/post/cf1265d/","section":"zh","summary":"比赛的时候太蠢了。\n","tags":["贪心"],"title":"Codeforces 1265D - Beautiful Sequence 题解","type":"zh"},{"authors":null,"categories":null,"content":"解法动画\n打乱 L2 R2 U L2 B2 F2 U R2 D’ U’ F’ R F2 D B2 D2 B’ F’ L B\n解法 y’ //inspection\nF’ D’ F2 U R B’ //FB\nr’ U’ r’ U2 r U M r’ U’ r M’ U’ R U R’ U’ R U R’ //SB\nU’ R U R’ U’ R’ F R F’ //CMLL\nM’ U M2’ U’ M U2 M’ U M U2 M’ U2 //LSE\n46 ETM, 3.7 TPS\n","date":1575504e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575504e3,"objectID":"d872361059331f99cd5f3e1567f1e867","permalink":"https://tgc54.com/zh/post/pbreconstruction/","publishdate":"2019-12-05T00:00:00Z","relpermalink":"/zh/post/pbreconstruction/","section":"zh","summary":"","tags":null,"title":"12.42 PB 复盘","type":"zh"},{"authors":null,"categories":["题解"],"content":"解法 首先，我们需要知道几点正确匹配的括号序列的性质：\n如果我们把左括号换成1，把右括号换成-1的话：\n序列的和为0\n任意前缀和不小于0\n前缀和中最大值就是嵌套最多的括号数\n根据这些性质，我们需要一个可以支持区间修改和查询最值的数据结构，很明显，就是线段树了。\n注意：整个序列的和可以通过查询最后一个元素的值来得到，query函数就是为了干这个的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } ","date":1575072e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575072e3,"objectID":"d5963aed945b1fea36d0f306f89fad4b","permalink":"https://tgc54.com/zh/post/cf1263e/","publishdate":"2019-11-30T00:00:00Z","relpermalink":"/zh/post/cf1263e/","section":"zh","summary":"","tags":["数据结构","线段树"],"title":"Codeforces 1263E - Editor 题解","type":"zh"},{"authors":null,"categories":["Miscellany"],"content":"Klee’s Algorithm origin\nint length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); vector\u0026lt;pair\u0026lt;int, bool\u0026gt;\u0026gt; x(n*2); for (int i = 0; i \u0026lt; n; i++) { x[i*2] = {a[i].first, false}; x[i*2+1] = {a[i].second, true}; } sort(x.begin(), x.end()); int result = 0; int c = 0; for (int i = 0; i \u0026lt; n * 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; x[i].first \u0026gt; x[i-1].first \u0026amp;\u0026amp; c \u0026gt; 0) result += x[i].first - x[i-1].first; if (x[i].second) c--; else c++; } return result; } One algorithm that I learnt from other’s code int length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); sort(a.begin(), a.end()); int result = 0; int rr = 0; for(pii it:a){ int l=it.fist,r=it.second; result+=max(0,r-max(rr,l)); rr=max(rr,r); } return result; } ","date":1575072e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575072e3,"objectID":"c3ad7fdc065ec526a6731e5e3230f5d6","permalink":"https://tgc54.com/post/segunion/","publishdate":"2019-11-30T00:00:00Z","relpermalink":"/post/segunion/","section":"post","summary":"","tags":["Misc"],"title":"Two Ways to Do Segment Union","type":"post"},{"authors":null,"categories":["算法笔记"],"content":"路径记录 我们开一个vector\u0026lt;int\u0026gt; pre[N]用来记录某个点的前一个点，在更新距离的时候，如果当前距离更短就舍弃掉之前的记录，将当前点作为被更新点的前一个点；如果当前距离和最短距离相等就在数组里加上这个点。\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } 最短路径的数量 和路径记录类似，如果更短就让数目等于1,如果一样就加1。\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } ","date":1573344e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1573344e3,"objectID":"e25073aafd736185a257daa4d7cd1d6c","permalink":"https://tgc54.com/zh/post/dijkextention/","publishdate":"2019-11-10T00:00:00Z","relpermalink":"/zh/post/dijkextention/","section":"zh","summary":"","tags":["最短路","图论"],"title":"Dijkstra的一些扩展","type":"zh"},{"authors":null,"categories":["Alg Notes"],"content":"Just as a reminder with simple explanatin.\nPath Reconstruction Use vector\u0026lt;int\u0026gt; pre[N] to record the previous vertices of all the vertices in the shortest path(s). When updating the distance to vetex $v$, if the current distance is better, discard the previous record and let the current vetex be the previous vetex of $v$. If the distance is the same, just add the current vertex to pre[v].\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } Number of shortest pathes Similar to recording the path, if the distance is better then let the number be one. If the same, plus 1.\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } ","date":1573344e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1573344e3,"objectID":"29d9afacece5d1037490c067c88c9a16","permalink":"https://tgc54.com/post/dijkextention/","publishdate":"2019-11-10T00:00:00Z","relpermalink":"/post/dijkextention/","section":"post","summary":"Just as a reminder with simple explanatin.\n","tags":["Shortest Path","Graph Theory"],"title":"Extension of Dijkstra","type":"post"},{"authors":null,"categories":["Solutions"],"content":"problem link\nTo solve this problem, we need to count for each prime factors, how many intervals include them.\nFirst, let’s assume that all factors are distinct i.e. all factors only appears at one position. In this case, it’s easy to count the intervals that include them. For all primes at $p$, there are $p\\cdot(n-p+1)$ intervals including them.\nHowever, one prime can appear multiple times so we need to substract the repeated intervals(interval contain the current position and last position). Formally, if a prime appears at $p$ and lastly appears at $q$, it adds $(n-p+1)\\cdot q$ to answer.\nSo our strategy is calculating all primes less than 1e6 first. Go through all the numbers and find their prime factors. Record the all appearance of each factor and calculate their contributions to the answer.\ncode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e6+5; int pri[MAXN],vis[MAXN],cnt=0; vector\u0026lt;int\u0026gt; pos[MAXN]; void init() { for (int i = 2; i \u0026lt; MAXN; ++i) { if (!vis[i]) pri[cnt++] = i; for (int j = 0; j \u0026lt;cnt; ++j) { if (1ll * i * pri[j] \u0026gt;= MAXN) break; vis[i * pri[j]] = 1; if (i % pri[j]==0) break; } } forn(i,cnt) pos[pri[i]].pb(0); } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; init(); for1(i,n){ for(int j=0;pri[j]*pri[j]\u0026lt;=a[i];j++){ if(a[i]%pri[j]==0){ pos[pri[j]].pb(i); while(a[i]%pri[j]==0) a[i]/=pri[j]; } } if(a[i]\u0026gt;1) pos[a[i]].pb(i); } ll ans=0; forn(i,cnt){ for(int j=1;j\u0026lt;pos[pri[i]].size();j++) ans+=ll(pos[pri[i]][j]-pos[pri[i]][j-1])*(n-pos[pri[i]][j]+1); }\tcout\u0026lt;\u0026lt;ans; return 0; } ","date":1572566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1572566400,"objectID":"d665bdde5cac6ea6591ceb464f80d58f","permalink":"https://tgc54.com/post/gym101981j/","publishdate":"2019-11-01T00:00:00Z","relpermalink":"/post/gym101981j/","section":"post","summary":"","tags":["Math"],"title":"Solution for Gym101981J  - Prime Game","type":"post"},{"authors":null,"categories":["Misc"],"content":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } ","date":1571097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571097600,"objectID":"5718e2920ab53d1f939ca52db50407b6","permalink":"https://tgc54.com/post/debugconfig/","publishdate":"2019-10-15T00:00:00Z","relpermalink":"/post/debugconfig/","section":"post","summary":"","tags":["VSCode"],"title":"VSCode C++ debug configurations","type":"post"},{"authors":null,"categories":["杂项"],"content":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } ","date":1571097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571097600,"objectID":"b231ab4f918d9d15710589c43038697f","permalink":"https://tgc54.com/zh/post/debugconfig/","publishdate":"2019-10-15T00:00:00Z","relpermalink":"/zh/post/debugconfig/","section":"zh","summary":"","tags":["VSCode"],"title":"VSCode C++ debug 配置","type":"zh"},{"authors":null,"categories":["Training Solutions"],"content":"Link\nA - Watching TV Gym - 101498A Use a map\u0026lt;int,int\u0026gt; to count the number of channels in each frequency. Iterate the map to find the frequency that displays the largest number of channels.\nB - Longest Prefix Gym - 101498B Swapping any two letters means that you can rearrange the second string so just count the number of each character in the second string and then iterate the first string to see if you can put the same in each position. When you stops, that’s the longest prefix.\nC - Lunch Break Gym - 101498C Just output which one is the smallest among the three numbers\nD - Counting Paths Gym - 101498D The first direction can be chosen arbitrarily. In the rest $a-1$ nodes we need to choose $b$ nodes where to change the direction so the answer is $\\dbinom{a-1}{b}\\pmod {10^9+7}$. As the $a$ and $b$ are large so we need to precalculate $n!\\pmod {10^9+7}$ and $(n!)^{-1}\\pmod {10^9+7}$ .\nE - Car Factory Gym - 101498E By drawing some sketchs you can find the answer is $n+k-1$.\nH - Palindrome Number Start from the first digit and try to fill every digits with the largest number. If the sum is less than $s$ or there is leading zero, the answer is -1 otherwise output the constructed number.\nI - Rock Piles Gym - 101498I At first I counldn’t find any pattern so I decided to get the sg function using brute force. Here is the pattern: only when both $N$ and $M$ are even the answer is “abdullah” otherwise the answer is hasan.\nJ - Split the String Gym - 101498J Enumerate all the possible disstance between two splitting point and check if all the splitting points are space. If you could find such a distance the answer is “YES” and vise versa.\n","date":1571011200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571011200,"objectID":"c14e4b74637c49e9214ea82be36bd490","permalink":"https://tgc54.com/post/cugb8/","publishdate":"2019-10-14T00:00:00Z","relpermalink":"/post/cugb8/","section":"post","summary":"Link\n","tags":["CUGBACM"],"title":"Solution for CUGBACM Training","type":"post"},{"authors":null,"categories":["Alg Notes"],"content":"What is Modular Multiplicative Inverse? If $a\\cdot x \\equiv 1\\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.\nThe use of Inverse The inverse is used when calculating the modulo of division. $$\\dfrac{a}{b} \\equiv a \\cdot b^{-1}\\pmod p$$\nThe ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\\cdot x \\equiv 1\\pmod p$ as $a\\cdot x +p\\cdot k\\equiv \\gcd(p,a)\\pmod p$ which can be solved using the Extended Euclidean algorithm.\nvoid exgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { if (b == 0) { x = 1, y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x; } The Fermat’s Little Theorem According to Fermat’s Little Theorem $a^{p-1} \\equiv 1\\pmod p$, thus $a\\cdot x \\equiv a^{p-1}\\pmod p$, $x \\equiv a^{p-2}\\pmod p$. We can calculate it using Exponentiation by squaring.\ninline int qpow(long long a, int b) { int ans = 1; a = (a % p + p) % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = (a * ans) % p; a = (a * a) % p; } return ans; } Calculate consecutive inverses in linear time inv[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p; Modulo of Combinations Calculate $\\dbinom{n}{m} \\bmod p$\nWhen n and m are not too big We can use the inverse to calculate $\\dfrac{n!}{m!\\cdot (n-m)!}\\equiv(n!\\mod p\\cdot (m!\\mod p)^{-1}\\cdot ((n-m)!\\mod p)^{-1})\\pmod p$\nCalculate the inverse of factorial $$\\because n!\\cdot(n!)^{-1}\\equiv 1 \\pmod p\\ \\therefore (n-1)!\\cdot (n\\cdot (n!)^{-1})\\equiv 1 \\pmod p$$\nTherefore$(n\\cdot (n!)^{-1})$is an inverse of $(n-1)!$.\nfact[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fact[i] = fact[i - 1] * i %mod; } inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i \u0026gt;= 0; i--) { inv[i] = inv[i + 1] * (i + 1) %mod; } When n and m are really big but p is not too big $$\\binom{n}{m}\\bmod p=\\binom{\\lfloor\\frac{n}{p}\\rfloor }{\\lfloor\\frac{m}{p}\\rfloor }\\binom{n\\bmod p }{m\\bmod p}\\bmod p$$\nlong long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } ","date":1570924800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570924800,"objectID":"3d93e84d605c61c34157e181d93e78f1","permalink":"https://tgc54.com/post/modular_mul_inverse/","publishdate":"2019-10-13T00:00:00Z","relpermalink":"/post/modular_mul_inverse/","section":"post","summary":"What is Modular Multiplicative Inverse? If $a\\cdot x \\equiv 1\\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.\n","tags":["Math","Number Theory","Modular Inverse","Combinatorics"],"title":"Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations","type":"post"},{"authors":null,"categories":["Solutions"],"content":"My first blog in English!\nSolution link to the problem\nI learnt Tarjan’s algorithm in this video. Very good visualization.\nFirst we find all the strongly conncted components in the given relationship graph. All the vetices in the same component can be treated as one point in the graph so we could get a DAG. The cows which is considered popular by all other cows are cows in the SCC with 0 out-degree. If there are more than one SCCs with 0 out-degree the answer is 0, otherwise the anser the number of cows in that SCC.\nSome details in the implementation:\nI used the $low$ value as the id of each vetices so all the vertices in the same SCC can be seen as one point.\n$low$ values are now consecutive so when you encounter one $low$ value with 0 out-degree, you have to change its out-degree to a none-zero value in case you count it again.\nCode #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cstring\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n,m; const int N=1e4+5; vector\u0026lt;int\u0026gt; vec[N]; int id=1; int ids[N],low[N]; bool onstack[N]; int stk[N],top=-1; int out[N]; void dfs(int x){ stk[++top]=x; onstack[x]=1; ids[x]=low[x]=id++; forn(i,vec[x].size()){ int to=vec[x][i]; if(ids[to]==-1) dfs(to); if(onstack[to]) low[x]=min(low[to],low[x]); } if(ids[x]==low[x]){ while(top\u0026gt;-1){ int node=stk[top--]; onstack[node]=0; low[node]=ids[x]; if(node==x) break; } } } void tarjan(){ for1(i,n) ids[i]=-1; for1(i,n){ if(ids[i]==-1) dfs(i); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; vec[u].pb(v); } tarjan(); for1(i,n){ forn(j,vec[i].size()){ int it=vec[i][j]; if(low[it]!=low[i]) out[low[i]]++; } } int cnt=0; int p; for1(i,n) if(out[low[i]]==0) { out[low[i]]=1; cnt++; p=low[i]; } if(cnt==1){ int ans=0; for1(i,n) if(low[i]==p) ans++; cout\u0026lt;\u0026lt;ans; }else cout\u0026lt;\u0026lt;0; return 0; } ","date":1570838400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570838400,"objectID":"bf777e8201d838ff6f81b635a2865f89","permalink":"https://tgc54.com/post/poj2186/","publishdate":"2019-10-12T00:00:00Z","relpermalink":"/post/poj2186/","section":"post","summary":"My first blog in English!\n","tags":["Graph Theory","Strongly Connected Components"],"title":"Solution for POJ 2186 - Popular Cows","type":"post"},{"authors":null,"categories":null,"content":"几个月前的笔记，才疏学浅，仅供参考~\n基本概念 PN点 什么是PN点 P点：前一个选手（previous person)将取胜的点，即必败点。\nN点：下一个选手（next person)将取胜的点，即必胜点。\n注意：PN点是相对于某个点的属性，与先后手无关，所以我们可以说先手的P点或后手的P点，也就是说无论是先手还时后手，走到P点都是必败的。\nPN点的属性 所有终结状态均为P点。\n从任何N点都至少有一种方法进入P点。（当前玩家的必胜点一定可以走到下一个玩家的必败点）\n从P点只能进入N点。（如果能走到P点的话就相当于胜负局势变化了，这样就不是必败的了）\n注意：这里说的都是走到最后状态的玩家获胜的游戏。\nSG函数 如果游戏条件比较复杂，为了判断每个点的胜负状态，就需要引入SG函数。\n定义： $$sg(u)=mex{sg(v)} $$\n其中v为u的后继状态，mex函数是作用于整数集合的函数，函数值是不属于该集合的最小自然数。\n$$mex(A)=min{k | k\\in\\complement_NA}$$\n那么，终止状态的SG值显然为0，并且SG值为0的状态就是P状态，SG值不为0的状态就是N状态。 证明则非常显然，SG值为0的状态，说明它的所有后继状态都不为0，也就是它只能转移到非0状态，而SG值不为0的状态则不一样，后继状态一定有0，可能有其他非负整数。那么SG值为0的状态就是必败状态的定义，SG值不为0的状态就是必胜状态的定。\n求法 从定义可以看出sg函数使用的递归定义，所以我们既可以从sg为0的状态递推，也可以采用递归的方法求。\n有些题目的sg函数的有规律的，通过打表或者思考可以发现规律;有些是没有规律的，需要自己写sg函数来打表。\n一般的sg函数打表模板： 注：需要打表的一般是简单的取石子游戏，且在取石子的数量上有限制。这种问题的状态方便用数字表示，所以实现简单。\nbool flag[N]; int sg[N]; void getsg(){ for1(i,N){ ms(flag,0); //枚举后继状态 for(int j=1;j\u0026lt;=K;j++){//K为能取不同个数石子的种类数 flag[sg[i-shizi[j]]]=1; } //找mex forn(j,N){ if(flag[j]==0){ sg[i]=j; break; } } } } 有规律的sg函数:HDU-1847\n打表可发现sg函数是0，1，2，0，1，2……变化的。\n稍微难一点找规律：LightOJ-1296\n规律：如果n是奇数gx(n)=gx(n/2),如果为偶数，gx(x)=x/2;\n需要打表的题：HDU-1848\n巴什博弈 题目描述 只有一堆n个石子，两个人轮流从这堆石子中取石子，规定每次至少取一个，最多取m个，最后取完的人获胜。\n分析 当n = m+1 的时候，由于先手最多取走m个，无论其取走多少个，剩下的后手均可以一次取完，显然后手胜。 根据以上分析，我们可以将n写成 $n=k(m+1)+r$ 的形式。对于先手玩家，我们可以取走r个，给对方造成剩下$k(m+1)$的情形。此时无论对手取走多少个，假设对手取走n个， 我们一定可以做到取走 $m+1-n$个，此时剩下$(k-1)(m+1)$个，那么留给对方又是(m+1)的整数倍，如此就可以保证先手取胜。 结论 当$n\\mod(m+1)!=0$时，先手胜，否则后手胜。\n威佐夫博弈 题目描述 有两堆各若干个石子，两个人轮流从某一堆或者两堆中取同样多的物品，规定每次至少取一个，多着不限，最后取完石子的人获胜。\n分析 我们用$(a_k,b_k),a_k \\leq b_k,k \\in[0,n] $ 表示一种局势，先手必输的局势我们称为奇异局势，显然$(0,0)$是一种奇异局势。那么$(0,k),(k,k)$必然是非奇异局势，因为可以通过一步到达奇异局势。我们可以发现$(1,2)$不论如何操作都将成为非奇异局势，所以$(1,2)$是下一个奇异局势，所以$(1+k,2),(1,2+k),(1+k,2+k)$也都是非奇异局势，以此类推我们可以发现之后的几个奇异局势是$(3,5),(4,7),(6,10)$。\n通过观察我们可以发现$a_0=b_0=0,a_k$为前面没出现过的最小正整数，$b_k=a_k+k$。\n奇异局势有以下三条性质\n任何正整数都包含在奇异局势中。\n任何操作都会将奇异局势变为非奇异局势。\n采取适当的操作可以将非奇异局势变为奇异局势。\n事实上，$a_n,b_n$是一对beatty数列。\nBeatty数列 取两个无理数$\\alpha,\\beta$使得$\\frac 1 \\alpha+\\frac1\\beta=1$。\n一对Beatty数列就是$a_n=\\lfloor n\\alpha\\rfloor,b_n=\\lfloor n\\beta\\rfloor$。\nRayleigh定理(Beatty定理) $a_n,b_n$划分正整数，也就是说每个正整数只在两个数列中出现一次。\n我们再回到这个问题， $$\\because a_n+n=\\lfloor n\\alpha\\rfloor+n=b_n=\\lfloor n\\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha \\rfloor+n= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha+n \\rfloor= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\beta = \\alpha+1$$\n根据$\\frac 1 \\alpha+\\frac 1 {\\alpha+1}=1$解得$\\alpha=\\frac {\\sqrt 5+1} 2=\\phi$。我们可得到通项$a_n=\\lfloor n \\phi \\rfloor,b_n=a_n+n$\n对于任意局势$(x,y),x\\leq y$我们只需判断$\\lfloor (y-x)\\phi\\rfloor\\stackrel{?}{=}x$\n常见的几类问题 给出局势判断是否是奇异局势。\n给出局势$(x,y),x\\leq y$，判断是否先手赢，若赢，给出第一步走法。\n例题：HDU-2177\n先把所有奇异局势求出来，然后判断是不是，如果不是：\n先判断能否两堆同时取，设$k=y-x$ 判断$x-a_k?=y-b_k(x-a_k\u0026gt;0)$如果成立就可以同时取到$(a_k,b_k)$。 判断取一堆的。先判断$x?=a_n\\land y?\u0026gt;b_n$,如果成立就可以取到$(a_n,b_n)$,如果不成立那么$a=b_n$，此时$y\u0026gt;a_n$，所以可以取到$(a_n,b_n)$。 Nim博弈 题目描述 有n堆石子，数量分别为$x_1,x_2,…,x_n$每人每次可在任意一堆中取走任意数量（不少于1）的石子。\n结论 Nim游戏中先手必败当且仅当$x_1XOR x_2XOR…XORx_n=0$时\n扩展 事实上，我们可以将Nim游戏视做多个子游戏的合集，根据Nim定理，总游戏的sg值等于所有子游戏的sg值的异或和。\n证明 异或有一条性质,$xXORy=xXORz \\implies y=z$，根据sg的定义，子游戏走一步，sg值必然发生改变，根据异或的性质所以总游戏的sg值也一定发生改变，0一定会变成非0，非0经过某一步可以变成0，所以当且仅当和游戏的sg为0时，先手必输，因为后手总可以控制sg值回到0。\n例题：HDU-2176\n","date":1570147200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570147200,"objectID":"23fe0a795afee75ba01c44a3d4164fc4","permalink":"https://tgc54.com/zh/post/game_theory/","publishdate":"2019-10-04T00:00:00Z","relpermalink":"/zh/post/game_theory/","section":"zh","summary":"几个月前的笔记，才疏学浅，仅供参考~\n","tags":["博弈论"],"title":"博弈论入门学习笔记","type":"zh"},{"authors":null,"categories":["题解"],"content":"long long爆的好啊！！\n题目链接\n我们把要求的式子展开 $$\\begin{align*}\u0026amp;f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\\\ =\u0026amp;g(1,p_1)\\cdot g(1,p_2)\\cdot \\ldots \\cdot g(1,p_n) \\\\ \u0026amp;g(2,p_1)\\cdot g(2,p_2)\\cdot \\ldots \\cdot g(2,p_n) \\\\ \u0026amp;g(3,p_1)\\cdot g(3,p_2)\\cdot \\ldots \\cdot g(3,p_n) \\\\ \u0026amp;\\vdots \\\\ \u0026amp;g(n,p_1)\\cdot g(n,p_2)\\cdot \\ldots \\cdot g(n,p_n)\\end{align*} $$\n然后每次计算一列，由于$p$是质数，当且仅当$n=k\\cdot p^j$时$g(n,p)=j$，否则$g(n,p)=1$。由于同一列中$p$都是相同的，所以只要计算指数之和就行了。直接分析代码：\nll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; n / tmp的结果就是对于当前的tmp，$1,2,3,\\ldots,n$中有几个可以整除tmp。 对于$1,2,\\ldots,n$每个数字都被筛过$g(n,p)$次，所以累加每一次的n / tmp就是指数之和了。注意tmp *= it可能会爆long long所以乘之前要先检查一下（做的时候被卡了，直接自闭）。\n完整代码：\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int mod = 1e9 + 7; long long binpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % mod; a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); vector\u0026lt;int\u0026gt; pr; ll x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; if (x % 2 == 0) { while (x % 2 == 0) x /= 2; pr.pb(2); } for (int i = 3; i * i \u0026lt;= x; i += 2) { if (x % i == 0) { pr.pb(i); while (x % i == 0) x /= i; } } if (x \u0026gt; 1) pr.pb(x); ll ans = 1; for (auto it : pr) { ll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } ","date":1569888e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569888e3,"objectID":"6e99124195e9cfbcca9f34d3d447187c","permalink":"https://tgc54.com/zh/post/cf1128c/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/zh/post/cf1128c/","section":"zh","summary":"long long爆的好啊！！\n","tags":["数学"],"title":"CodeForces 1128C - Primes and Multiplication 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"这哈希长见识了。\n这个是在CF题解的评论区里看到的解法，非常震惊，不禁想到了学长和我们说过的话:“哈希是一种思想”。这次真的是体会到了。\n思路：定义给了这么多，其实就是把完全二分图的概念扩展成了完全三分图。有一点很重要的性质，就是如果两个点的直接连接的点是一样的话那么这两个点必定属于同一个集合，这样就可以用哈希的方法快速判断两个点是否具有相同的邻居: 通过$pow_i=pow_{i-1}*p_1 \\bmod p_2$给每个点一个值，那么一个点的哈希值就是该点邻居的点$pow$值的和，如果两个点的哈希值一样，那么就大概率肯定两个点的邻居是一样的。\n代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; ll po[N],ha[N]; const int mod=1e9+7; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; po[0]=1; for1(i,n) po[i]=po[i-1]*29; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ha[x]+=po[y]; ha[y]+=po[x]; } map\u0026lt;ll,ll\u0026gt; mp; int idx=0; for1(i,n){ if(ha[i]==0){ cout\u0026lt;\u0026lt;-1; return 0; } if(mp[ha[i]]==0) mp[ha[i]]=++idx; } if(idx==3){ for1(i,n) cout\u0026lt;\u0026lt;mp[ha[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;-1; return 0; } ","date":1569888e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569888e3,"objectID":"f45fcc4acc5e8f419171f45d68cc8f83","permalink":"https://tgc54.com/zh/post/cf1128d/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/zh/post/cf1128d/","section":"zh","summary":"这哈希长见识了。\n","tags":["哈希","图论"],"title":"CodeForces1228D - Complete Tripartite 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"一开始做麻烦了，关键是写麻烦了还没过，好气哦。\n这题应该有很多不同的思路。我的想法是计算给出的数组中每一对相邻的数在之后的排列（Permutation）中距离的变化，然后只要以第一个排列的答案为基准，加上之后排列的距离变化就是后面排列的答案了。\n那么距离是如何变化的呢，我们设一对相邻的数中比较小的数是$l$，比较大的数是 $r$，那么他们在第一个排列中的位置就是这样的: $$1,2,\\ldots,l,\\dots,r,\\ldots,n-1,n$$ 在第一个一直到第$l-1$个排列中，$l$和$r$的位置都没有发生变化，自然距离也不变。但在第$l$个排列中，$l$成了第一个数： $$l,1,2,\\ldots,l-1,l+1,\\dots,r,\\ldots,n-1,n$$\n$l$与$r$的距离增加了$l-1$。\n在第$l+1$到$r-1$个排列中，$l$与$r$中的某一个数会在最前面，所以$l$与$r$的距离比最开始少1。\n在第$r$个排列中，r跑到了最前面： $$r,1,2,\\ldots,l-1,l,l+1,\\dots,r-1,r+1,\\ldots,n-1,n$$ 注意此时l的位置依然是$l+1$，所以距离的变化是$(l+1-1)-(r-l)=2\\cdot l-r$\n如果我们用一个数组a来保存所有排列中答案的变化，那么对于每一对$(l,r)$,我们应该做如下三个操作：\n$a_l := a_l+l-1$ $a_i:= a_i-1,i=l+1,\\ldots,r-1$ $a_r:= a_r +2\\cdot l-r$ 由于其中涉及到区间修改，所以我们可以用差分的思想来实现，并且由于只会查询一次，所以用最简单的数组就可以了，具体实现见代码:\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; ll sum[N]; int n,m; void rgadd(int l,int r,int x){ sum[l]+=x; sum[r+1]-=x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int x,last; cin\u0026gt;\u0026gt;last; ll ans=0; forn(i,m-1){ cin\u0026gt;\u0026gt;x; int mn=min(x,last),mx=max(x,last); ans+=mx-mn; last=x; if(mx==mn) continue; rgadd(mn,mn,mn-1); rgadd(mx,mx,(mn-mx+mn)); if(mx-mn\u0026gt;1) rgadd(mn+1,mx-1,-1); } for1(i,n){ ans+=sum[i]; cout\u0026lt;\u0026lt;an\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } ","date":1569888e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569888e3,"objectID":"5c0457f435dddc633158395f575bd8cd","permalink":"https://tgc54.com/zh/post/cf1234e/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/zh/post/cf1234e/","section":"zh","summary":"一开始做麻烦了，关键是写麻烦了还没过，好气哦。\n","tags":["差分"],"title":"CodeForces1234E - Special Permutations 题解","type":"zh"},{"authors":null,"categories":["训练题解"],"content":"A - Keywords Search HDU - 2222 题意： 给出单词和文章，问多少个单词在文章中出现过。\n思路： AC自动机板子题，之前也说过，不再赘述。\nB - 病毒侵袭 HDU - 2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\nC - Sliding Window POJ - 2823 题意： 数组长度为$n$,长度为$k$的窗户在数组上滑动，问每次滑动后的窗户中的最大和最小值。\n思路： 用线段树或者st表复杂度都是$O(nlogn)$，单调队列可以做到$O(n)$，如果求最大值就维护单调递增序列，方法如下：\n不断从队尾出列，直到队尾元素大于待入队的数，因为又小又靠前面的数自然比不上又大又靠后的数。 不断从队首出列，直到队首元素的下标在窗户的范围之内。 输出队首元素，为当前窗户的最大值。 求最小值步骤类似，实际维护的时候为了容易实现第二步，队列中存的是下标。\nD - Intersections Gym - 101853C 题意： 给出两行序列，连接相同的数，问产生交点的个数。\n思路： 如果两个数在上下两行中的相对位置发生了变化，连线的时候就会产生一个交点。\n在读入第一行的时候记录每个数在数组中的位置。在读入第二行的时候将其替换为该数在第一行的出现位置，那么问题就变成了求逆序对（$a_i\u0026gt;a_j,i\u0026lt;j$）个数的问题。\n有两种求法：归并排序和树状数组。这里介绍树状数组的做法：将所有的数的在第一行出现的位置和在第二行出现的位置作为数对保存在数组中，按照第一行出现的位置从大到小排序，这样每次插入一个数的时候前面数字的个数就是插入这个数产生新的逆序对的个数，因为数组是从大到小排序，此时已经插入的数都是比当前数大的数，而位置在前面的数就是符合逆序对定义的数。而这就可以用树状数组实现，计算前面数的个数就是算前缀和，插入就是在第二次出现的位置+1。\nE - 维护序列 Gym - 237040G 题意： 维护一个序列，支持以下操作：\n把数列中的一段数全部乘一个值； 把数列中的一段数全部加一个值； 询问数列中的一段数的和模 $P$ 的值。 思路： 线段树改板子题，需要动点脑子，乘的时候加和乘的lazy tag都要更新。因为$(val\\cdot lazy_{mul}+lazy_{add})\\cdot x=val\\cdot lazy_{mul}\\cdot x+lazy_{add}\\cdot x$ 其他貌似就忘 没 的 什 差 么 不 好 多 说 了 的了。\nF - Little Elephant and Array CodeForces - 220B 见我的另一篇文章\nG - Tourists Gym - 101002I 题意： 给出一棵树，计算所有两端其中一个是另一个倍数的路径长度和。\n思路： 计算树上路径自然要用到LCA，就是个倍增法板子题。\nI - 二维树状数组 ：单点修改，区间查询 Gym - 237040E 题意： 见题目。\n思路： 见题目。\nK - Jzzhu and Cities CodeForces - 449B 题意： 一个图中有$m$条道路和$k$条通往首都（标号为1的点）的铁路。问最多可以去掉多少铁路使得所有城市到首都的最短距离不变。\n思路： 把所有道路和铁路都放到图里，dijkstra是可以记录最短路路径条数的！（好像考试考过？），原理就是当更新距离的时候如果和当前最短路径一样长就路径条数+1，如果更短条数就置为1。最后遍历所有铁路，如果当前铁路比最短路长那么就可以去掉，如果和最短路一样的话就要看最短路还剩几条，如果大于1的话就可以去掉并且把最短路的条数-1。\nL - Alyona and the Tree CodeForces - 682C 题意： 给出一棵边权点权树，问最少去掉几个点使得不存在这样的点$u$：其子树上存在某点$v$，其点权$a_v$大于$v$到$u$的距离。\n思路： 计算树上所有的距离肯定超时，但是有这样一条性质，如果边权都是正数的话，如果$\\operatorname{dist}(u,v)\u0026gt; a_u,v\\not = root$那么$\\operatorname{dist}(u,root)\u0026gt;a_u$，也就是说我们可以只计算到根节点的距离就行了，但是边权如果有负数上述性质就不成立了，但是我们可以稍加改动：当我们dfs的时候，如果当前点到根节点的距离小于0，那么我们就应该将距离置为0，然后接着dfs,这样就避免了前面的负权路径产生的干扰。\n","date":1569715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569715200,"objectID":"66477573af39a47222304b4ee3e08e78","permalink":"https://tgc54.com/zh/post/cugb6/","publishdate":"2019-09-29T00:00:00Z","relpermalink":"/zh/post/cugb6/","section":"zh","summary":"","tags":["CUGBACM"],"title":"CUGBACM18级训练#6 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":"据说莫队更简单，然而不会啊\n题目链接\n考虑维护一个数组$D$，使得$D_l,D_{l+1},\\dots,D_{r-1},D_r$的和为询问$[l,r]$的答案。用线段树或树状数组都行（显然树状数组比较好写）。从左边开始遍历数组，当下标为$i$时，我们应该处理完所有$r=i$的询问。\n下面我们用一个最简单的例子来说明这个思路（下标从1开始）:\n$$A:3,3,3,3,3 \\D:0,0,0,0,0$$\n当$i=3$时，3这个数第一次出现3次，所以我们应让$D_1+1$，这样只有[1,3]这个询问才会得到1。\n当$i=4$时，按照刚才的想法，我们应让$D_2+1$:\n$$A:3,3,3,3,3 \\D:1,1,0,0,0$$\n但这时如果我们有$[1,4]$的询问，那么就会得到2，但答案应该为0，所以我们这时应将$D_1-2$：\n$$A: \\quad 3,3,3,3,3 \\D:-1,1,0,0,0$$\n这样就能正确处理$[1,4]$的询问了。\n现在$i=5$了，如果延续刚才的思路，现在应该是这样的:\n$$A: \\quad 3,\\enspace 3,3,3,3 \\D:-1,-1,1,0,0$$\n这样一来，$[1,5]$的询问又不对了，所以我们应该让$D_1+1$来抵消第二步。这就是这个题的基本思路。\n代码\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m, sqn; const int N = 1e5 + 5; struct node { int l, r, i; bool operator\u0026lt;(node a) { return r \u0026lt; a.r; } //按照询问的右边界从小到大排序 } itv[N]; int a[N], res[N], t[N]; int lowbit(int x) { return x \u0026amp; -x; } void change(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) t[i] += v; } int sum(int x) { int sum = 0; for (int i = x; i; i -= lowbit(i)) sum += t[i]; return sum; } vector\u0026lt;int\u0026gt; cnt[N];//记录每个数字每次出现时的下标 int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for1(i, n) cin \u0026gt;\u0026gt; a[i]; forn(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; itv[i] = node{a, b, i}; } sort(itv, itv + m); int l, r; int j = 0; for1(i, n) { int x = a[i]; if (x \u0026lt;= n) { cnt[x].push_back(i);//记录下标 int cntt = cnt[x].size();//这个数目前出现的次数 if (cntt \u0026gt;= x) {//对应前面i=3时的情况 change(cnt[x][cntt - x], 1); if (cntt \u0026gt; x)//对应i=4 change(cnt[x][cntt - x - 1], -2); if (cntt \u0026gt; x + 1)//对应i=5 change(cnt[x][cntt - x - 2], 1); } } while (j \u0026lt; m \u0026amp;\u0026amp; itv[j].r == i) { res[itv[j].i] = sum(itv[j].r) - sum(itv[j].l - 1); j++; }//处理所有r=i的询问 } forn(i, m) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; } ","date":1569456e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569456e3,"objectID":"9a85c01226237144be6a376a33071c18","permalink":"https://tgc54.com/zh/post/cf220b/","publishdate":"2019-09-26T00:00:00Z","relpermalink":"/zh/post/cf220b/","section":"zh","summary":"据说莫队更简单，然而不会啊\n","tags":["树状数组","数据结构"],"title":"Little Elephant and Array - CodeForces220B 题解","type":"zh"},{"authors":null,"categories":["比赛题解","题解"],"content":"还算顺利的一场\n题目链接\nA - 3D Printed Statues 题意： 你有1个3D打印机，打印机每天可以打印出1个打印机或者1个雕塑，你需要打印出n个雕塑，问最少需要几天。\n思路： 不难想出，只用一天打印雕塑就够了，因为如果要需要更多的天数，不如先打印打印机然后再打印雕塑，所以思路就是一开始疯狂打印打印机直到打印个数大于等于n，然后天数加一。\nB - Digital display 题意： 给出一个时间，用7段显示的方式输出（格式看题目就行）\n思路： 当时写麻烦了，其实可以把端点和中间的线合起来写成一个函数的，这样就只用写画横着和竖着的线的函数，用二维数组存整个图案，根据数字和第几位数确定横线和竖线的起点坐标，调用对应的画线函数就行了。最坑的是这个oj没有格式错误，当时少了一个空行却以为是别的错，wa了好几发……这个题耽误了贼长时间。\nC - Eight Queens 题意： 给出一个棋盘，判断是不是合法的八皇后放法。\n思路： 遍历棋盘，碰到皇后就进行判断其4个方向上有没有别的皇后。但是题目里有一点没说就是皇后的数量可能不为8，还好wa了一次就想到这个了，不然可能要自闭……\nD - Eko 题意： 给出$N$棵树的高度，你可以选择某一个高度，然后把所有在此高度之上的木头都砍掉，对于给出的$M$单位的树木，找出至少能获得这些数量的最高高度。\n思路： 因为随着高度从低到高，砍掉的树木的数量单调递增，所以可以用二分搜索。推荐一种二分的写法，很好记，可以对付各种类型的二分。\n代码\n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i,n) for(int i=0;i\u0026lt;int(n);++i) #define for1(i,n) for(int i=1;i\u0026lt;=int(n);++i) #define fore(i,a,b) for(int i=int(a);i\u0026lt;=b;++i) #define ms(a,x) memset(a,x,sizeof(a)); typedef long long ll; using namespace std; const int N=1e6+5; ll a[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ll r=0; forn(i,n) { cin\u0026gt;\u0026gt;a[i]; r=max(a[i],r); } ll l=0; while(l\u0026lt;=r){ ll tot=0; ll mid=(l+r)/2; forn(i,n){ if(a[i]\u0026gt;mid) tot+=a[i]-mid; } if(tot\u0026gt;=m) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r; return 0; } E - Election 题意： 有$N$个人投票，已经知道第一个人有$V_1$票，第二个人有$V_2$票，已知每个人投票都是随机的，判断是以下哪三种情况：1、第一个人的胜出的概率超过$W%$, 2、第一个人必输，3、剩下的情况。\n思路： 排列组合的问题，一直被卡到结束，到第二天才发现是算组合数的时候爆了因为用了最为弱智的算法。算$C_m^n$时应乘一个除一个，分子的部分应从$m-n+1$开始乘，分母的部分应从$1$开始除，如果最终结果在long long之内的话这样算就不会爆。还好最多只有50个人投票，最多只有$2^{50}$种情况。\n代码\n#include \u0026lt;iostream\u0026gt; typedef long long ll; ll calc(int a, int b) { if (a - b \u0026lt; b) b = a - b; ll ans = 1; for(int i=1,i\u0026lt;=b;i++) ans = ans*(a -b+ i)/i; return ans; } using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, v1, v2, w; int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; w; if (n - v2 \u0026lt;= v2) cout \u0026lt;\u0026lt; \u0026#34;RECOUNT!\\n\u0026#34;; else { ll ans = 0; int lef = n - v1 - v2; for (int i = 0; i \u0026lt;= lef; i++) { if (v1 + i \u0026gt; v2 + lef - i) { ans += calc(lef, i); } } if (ans * 100.0 / (1ll \u0026lt;\u0026lt; lef) \u0026gt; w) cout \u0026lt;\u0026lt; \u0026#34;GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;PATIENCE, EVERYONE!\\n\u0026#34;; } } return 0; ","date":1569456e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569456e3,"objectID":"fab6fcb62d7b0f176042ce145ee8e287","permalink":"https://tgc54.com/zh/post/york2tutr/","publishdate":"2019-09-26T00:00:00Z","relpermalink":"/zh/post/york2tutr/","section":"zh","summary":"还算顺利的一场\n","tags":null,"title":"York University programming contest 2 题解","type":"zh"},{"authors":null,"categories":["题解"],"content":" 经过长时间思考并解决调问题的感觉太好了 ——xls\n题目链接\n网上的题解比较少而且都讲的比较跳跃，不知道是他们太聪明还是我太笨了。于是本着刨根问底的精神我详细推导了下过程。如果想麻烦了欢迎指正。\n首先，farey数列的分母构成的数列一定是对称的，因为如果分子与分母互质，那么分母与分子的差也一定与分母互质，这个可以用反证法证明：设分母是$m$，分子是$n$，如果$m$与$n$不互质，那么可以写成$m=k \\cdot p,n=j \\cdot p$那么$m-n=(k-j)\\cdot p$与$m$也不互质，所以$ \\dfrac{n}{m}$与$\\dfrac{m-n}{m}$要么都在数列里要么都不在数列里。\n其次，设当前的order是$k$,那么当order增加到$k+1$时，将会有$\\varphi(k+1)$个数被插入，这个道理很简单：如果不是互质的话就被约掉了。\n下面我们看一下插入的这些数对farey sums有什么影响：\n设$\\dfrac{n}{m}$插到了$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之中，我看到的题解都直接给出了结论$m=a+b$这个结论看起来很神奇（事实上还有$n=c+d$），但我怎么也想不出来这个是怎么得到的，于是我上了维基百科得到了思路：\n首先要先证明$\\dfrac{c}{a}$与$\\dfrac{d}{b}$如果在order为$\\max(a,b)$中是相邻的两项（假设$\\dfrac{c}{a}$在后，写完才发现后面证明把两个弄反了，懒的改了……）那么有$\\dfrac{c}{a}-\\dfrac{d}{b}=\\dfrac{1}{a\\cdot b}$即$b\\cdot c-a\\cdot b=1$，这个维基上也没给出证明，不过比较好想，依然是反证法：如果两个数之间还有其他的数$\\dfrac{n}{m}$，那么$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b},\\dfrac{d}{b}-\\dfrac{n}{m}\u0026lt;\\dfrac{1}{a\\cdot b}$，如果$a\u0026lt; b$ 我们就看前面那个不等式$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b}$，通分得$\\dfrac{a\\cdot n-c\\cdot m}{a\\cdot m}\u0026lt;\\dfrac{1}{a\\cdot b}$，因为$a\\cdot n-c\\cdot m\\ge 1$所以$a\\cdot m\u0026gt;a \\cdot b$，但因为order为$b$所以m不能大于$b$，与假设矛盾。$a\\ge b$的情况与前面同理。\n有了这个我们就可以轻松证明当$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之间有新的数$\\dfrac{n}{m}$插入时那么有$a\\cdot n-c\\cdot m=d\\cdot m-b\\cdot n$移项得$n(a+b)=m(c+d)$，最终得到$\\dfrac{n}{m}=\\dfrac{c+d}{a+b}$\n明白了这关键的一步之后，原来farey sums中和$\\dfrac{a}{b}+\\dfrac{b}{a}$（数列中对称的两项）就变成了$\\dfrac{a}{a+b}+\\dfrac{a+b}{b}+\\dfrac{b}{a+b}+\\dfrac{a+b}{a}=3+\\dfrac{a}{b}+\\dfrac{b}{a}$，所以每插入两项，farey sums就增加3，一共插入了$\\varphi(k+1)$项，那么farey sums就增加了$\\dfrac{3\\cdot\\varphi(k+1)}{2}$，又因为order从0变成1的时候只增加了1,比$\\dfrac{3}{2}$少了$\\dfrac{1}{2}$，所以最终答案应为$\\sum_{i=1}^{n}{\\dfrac{3\\cdot \\varphi(i)}{2}}-\\dfrac{1}{2}$\n代码\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) using namespace std; const int N = 10005; int phi[N], phisum[N]; void phi_table(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) if (!phi[i]) for (int j = i; j \u0026lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; phi_table(10000); for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i]; for1(i, n) { int p, x; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (3 * phisum[p] - 1) \u0026lt;\u0026lt; \u0026#34;/2\\n\u0026#34;; } return 0; } ","date":1569369600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569369600,"objectID":"d120d6421010acc33a18eb4789f1fce7","permalink":"https://tgc54.com/zh/post/kattis_fareysums/","publishdate":"2019-09-25T00:00:00Z","relpermalink":"/zh/post/kattis_fareysums/","section":"zh","summary":" 经过长时间思考并解决调问题的感觉太好了 ——xls\n","tags":["数学","欧拉函数"],"title":"Kattis - Farey Sums题解","type":"zh"},{"authors":null,"categories":["训练题解"],"content":"B - Godfather Gym - 101649G 题意： 给出一个有n个点的树，问去掉哪个点后剩下的树中最大的节点数最小（如果有多个按从小到大的顺序输出）。\n思路： 一开始没看见“保证是一棵树”想复杂了，先跑一遍dfs序，这样就能知道每个点除了父节点之外所有的子树的大小了，父节点对应的“子树”的大小就是n减去所有子树的大小之和。遍历所有点，找出所有“子树”中最大的那个，将其大小和编号作为数对加入数组中，然后对所有点排序，输出最小的那几个就行了。\nE - Wow! Such Doge! HDU - 4847 题意： 给出一篇文章，问其中出现过多少个\u0026#34;doge\u0026#34;（不区分大小写）。\n思路： 先遍历文章，将所有大写之母转为小写，然后再用find或者暴力查找\u0026#34;doge\u0026#34;即可。\nG - Theme Section HDU - 4763 题意： 给出一个字符串n找出一个最长的子串（theme），使其出现在开头中间和结尾（不允许重叠）\n思路： 一开始被样例误导了，以为theme里面只能有一种字符，wa了几发感觉不对，所以应该先跑前缀函数，然后从从第二位遍历到倒数第二位，如果某一位前缀函数大于其到第一位距离的一半，则取一半，找出其中的最大值，这样就得到了出现在中间的theme的最大长度。然后再判断最后一位的前缀长度是否大于整个字符串长度的三分之一，如果大于则取三分之一，这样就是出现在后面的theme的长度，输出中间和后面中比较小的一个即可。\nI - Path HDU - 6582 不会网络流，有空再补。\n","date":1569110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569110400,"objectID":"2367167c9b241a2f1449879ffcdef13f","permalink":"https://tgc54.com/zh/post/cugb4tutr/","publishdate":"2019-09-22T00:00:00Z","relpermalink":"/zh/post/cugb4tutr/","section":"zh","summary":"","tags":["CUGBACM"],"title":"CUGBACM18级训练#4 题解","type":"zh"},{"authors":null,"categories":["训练题解"],"content":"1.HDU1686 题意： 给出两个串 $S_1,S_2$，问$S_1$在$S_2$中出现的次数。\n思路： kmp板子题，注意要用scanf。\n2.HDU2594 题意： 给出两个字符串$S_1,S_2$，求最长的既是$S_1$前缀又是$S_2$后缀的字符串。\n思路： 很明显就是把两个串拼起来然后求前缀函数，不过要注意的是拼起来的串的前缀函数有可能超过给出的串的长度，解决办法就是在两个串中间加一个符号。\n3.HDU6629 题意： 给出字符串$S$问用暴力算法求$S$的Z函数（一个长度为n的数组，其中第i个元素为满足从位置i开始且为s前缀的字符串的最大长度。）需要的比较次数。\n思路： 求每一个位置的比较次数都等于这个位置的z函数+1，因为要往后面多比较一次发现不匹配了才会终止（如果比较到字符串末尾了即i+z[i]\u0026gt;=n就不用加1），求和就是答案。\n4.Codeforces 1200E 题意： 给了你n个字符串，然后按照如下方式合并得到新串$S’$:\n如果$S’$为空串，则直接加入$S’$。 否则，每次比较$S’$的后缀与前缀，取失配位置之后的后缀加入$S’$中 求s′\n思路： 设答案串的长度为$L_{ans}$,需要合并的新串的长度为$L$,将“新串+#+答案串后面长$\\min(L_{ans},L)$的子串”作为整体跑前缀函数，设整个串的最长公共前后缀的长度为$len$,将新串下标为$len,len+1, \\cdots,L-1$的子串加到答案串之后。\n5.HDU3613 题意： 给出一字符串，其中每一种字符对应一个价值，将字符串切成两段，计算两段的价值和，方法如下：如果这一段是回文串，价值就是每一个字符对应的价值的和，否则该串价值为0。求两段价值之和的最大值。\n思路： 先跑一遍大可马拉车算法，然后遍历求出串的价值前缀和，然后枚举分割点，找到两个串的中心，判断中心的回文串是不是整个串，如果是就利用之前算的前缀和加那个串的价值，在枚举中不断更新答案即可。\n6. HDU2222 题意：给出n个单词和一个长串，问有几个单词在长串中出现过。\n思路：AC自动机板子题，好像没什么好说的……\n7.HDU2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\n","date":1569024e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569024e3,"objectID":"81a5d71b4b39849cf8d30f66c823a6e5","permalink":"https://tgc54.com/zh/post/cugbacm3tutr/","publishdate":"2019-09-21T00:00:00Z","relpermalink":"/zh/post/cugbacm3tutr/","section":"zh","summary":"","tags":["CUGBACM"],"title":"CUGBACM18级训练#3 题解","type":"zh"},{"authors":null,"categories":["比赛题解","题解"],"content":"这是一场关于身残志坚的比赛。那天晚上切菜时切着手了，去了医院，没想到挂个急诊还要等这么久，心想晚上的比赛肯定泡汤了，等待之余想起自己包里还有iPad和蓝牙键盘，虽然比赛已经开始半小时了，而且自己只有9根指头能用，就当玩玩吧，于是我连上键盘，打开koder，在iPad上打起了比赛，没想到最后出了三个题，排名第三，手指和比赛都保住了……\n题目链接\nA. Cold-puter Science 题意： 给出$n$个数问有几个数小于0。\n思路： 这就不用说了吧，基本上是我见过的最水的签到题了。\nB. Are You Listening? 题意： 给出自己的坐标$cx,cy$以及$n$个敌放监听点的坐标和监听半径$x,y,r$，对方最少需要3个点探测到你才能确定你的位置，问自己广播的最大半径是多少（答案可能是0，向下取整）。\n思路： 设监听点的与你的距离是$d$，半径是$r$，那么$d-r$就是不被检测到的最大广播半径。于是每读入一组监听点的数据就计算出$d-r$并存入数组中，最后对数组排序，如果第三个数小于0就输出0否则输出向下取整后的数。\nC. Chewbacca 题意： 给出一棵有$N$个节点的满树，每个节点最多有$K$个子节点，节点的需要从上往下、从左往右排列，给出$Q$个询问，问树上两个点的最短路径的长度。\n思路： 当时想到是求LCA了，但因为没学过而且排到我了就没做，其实这题很简单，因为题目很特殊：是一棵满树并且父亲与儿子之间的距离是1，所以可能采用比较暴力的算法，经过实验可以发现：如果一个节点的序号是$n$，那么$(n+K-2)/K$就是其父节点的坐标，由此我们就可以通过不断除得到两个节点的深度(其实好像也可以直接求$\\lceil \\log_Kn \\rceil$)，先使深度比较大的节点跳转到深度比较小的节点的深度，然后令两个点同时向上跳转直到重合。\nD. Bike Gears 题意： 给出自行车所有前变速轮和后变速轮的齿数，定义一组齿轮组合的gear值为前齿轮数除以后齿轮数，要求按照gear值从小到大输出所有齿轮的组合。\n思路： 由于齿轮数可大至$10^9$，即使是用long double来存gear值也会出现精度问题。所以只能存gear的最简分数，在排序的时候用通分来比较，注意虽然单个齿轮的值没有超过int但通分的时候相乘就可能爆，所以要用long long来存储。还有一点比较坑的就是题目里没说如果两组齿轮的gear相同怎么办，只能从样例里来推断是先输出小的。 solution: As the number of sprockets can be as large as $10^9$, even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first.\n","date":1568505600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568505600,"objectID":"00a64592883ad337b73c49ffb547cb49","permalink":"https://tgc54.com/zh/post/yorku1totr/","publishdate":"2019-09-15T00:00:00Z","relpermalink":"/zh/post/yorku1totr/","section":"zh","summary":"这是一场关于身残志坚的比赛。那天晚上切菜时切着手了，去了医院，没想到挂个急诊还要等这么久，心想晚上的比赛肯定泡汤了，等待之余想起自己包里还有iPad和蓝牙键盘，虽然比赛已经开始半小时了，而且自己只有9根指头能用，就当玩玩吧，于是我连上键盘，打开koder，在iPad上打起了比赛，没想到最后出了三个题，排名第三，手指和比赛都保住了……\n","tags":null,"title":"York Univeristy programming contest 第一场题解","type":"zh"},{"authors":null,"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"9a6cb9348361050ffbcc0117246adb56","permalink":"https://tgc54.com/tag/","publishdate":"2019-01-01T00:00:00Z","relpermalink":"/tag/","section":"","summary":"Tags","tags":null,"title":"Tags","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"050e88c5ba9d6ed7b1d1e92604648f8f","permalink":"https://tgc54.com/zh/tag/","publishdate":"2019-01-01T00:00:00Z","relpermalink":"/zh/tag/","section":"zh","summary":"Tags","tags":null,"title":"Tags","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"132307db5be65259d13c54046ba169ea","permalink":"https://tgc54.com/project/cf-plot/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/cf-plot/","section":"project","summary":"Get current ratings and plot rating changes of Codeforces with graph.js. Built with React.js.","tags":null,"title":"cf-plot","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"46a5eb6ad0bbd3e97c8267764bca0924","permalink":"https://tgc54.com/zh/project/cf-plot/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/zh/project/cf-plot/","section":"zh","summary":"画cf分数曲线图","tags":null,"title":"cf-plot","type":"zh"}]