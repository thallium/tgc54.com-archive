[{"authors":null,"categories":null,"content":" å–œæ¬¢å„ç§ä¸œè¥¿ï¼šå¼€å‘ã€æœåŠ¡å™¨ã€Linuxã€ç®—æ³•ç«èµ›ã€é­”æ–¹ã€æœºæ¢°é”®ç›˜ã€ä¹’ä¹“çƒã€‚ Thallium54 @ Codeforces ç§è¾£æ¡ @ bilibili ","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"å–œæ¬¢å„ç§ä¸œè¥¿ï¼šå¼€å‘ã€æœåŠ¡å™¨ã€Linuxã€ç®—æ³•ç«èµ›ã€é­”æ–¹ã€æœºæ¢°","tags":null,"title":"ç§è¾£æ¡","type":"authors"},{"authors":null,"categories":[],"content":"","date":1658544335,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1658544335,"objectID":"69807e372c83d163840d800fba09da6f","permalink":"https://tgc54.com/zh/post/manage-python-with-pyenv/","publishdate":"2022-07-22T22:45:35-04:00","relpermalink":"/zh/post/manage-python-with-pyenv/","section":"post","summary":"","tags":[],"title":"Manage Python With Pyenv","type":"post"},{"authors":null,"categories":[],"content":"ä½œä¸ºä¸€åç®—æ³•ç«èµ›é€‰æ‰‹ï¼Œæˆ‘ä¸€ç›´åœ¨å¯»æ‰¾é¿å…å¤åˆ¶ç²˜è´´æ¿å­çš„æ–¹æ³•ï¼Œè¿™æ ·æˆ‘å°±çš„æ¿å­åº“å°±èƒ½æ›´åŠ å¤æ‚ã€‚\nå—Egorçš„rust bundlerå¯å‘ï¼Œæˆ‘ä¸ç¦æƒ³C++ä¹Ÿæœ‰æ²¡æœ‰ç›¸ä¼¼çš„ä¸œè¥¿? äºæ˜¯æƒ³èµ·æ¥å¾ˆä¹…ä¹‹å‰çœ‹è¿‡è¿™ä¸ªåšå®¢ç„¶åæˆ‘å°±è¯äº†ç‚¹æ—¶é—´åˆæ‰¾åˆ°äº†é‚£ç¯‡åšæ–‡ï¼Œä½†å¹¶ä¸æ˜¯bundlerè€Œä¸”çœ‹èµ·æ¥å¾ˆå¤æ‚ã€‚è¯„è®ºåŒºé‡Œæœ‰äººæåˆ°ç”¨cppè¿™ä¸ªé¢„å¤„ç†å‘½ä»¤ã€‚ä¹Ÿè®¸ä½ çŸ¥é“ï¼Œ#includeåŸºæœ¬å°±æ˜¯å¤åˆ¶ç²˜è´´æ‰€ä»¥çœ‹èµ·æ¥å¥½åƒæœ‰æˆï¼Œä½†é—®é¢˜æ˜¯é¢„å¤„ç†ä¹Ÿä¼šå¤åˆ¶ç²˜è´´æ ‡å‡†åº“ï¼Œå¤§æ¦‚æœ‰20å¤šä¸‡è¡Œã€‚æ‰€ä»¥æˆ‘ç»§ç»­æœå¯»èƒ½ä¸èƒ½è·³è¿‡ç³»ç»Ÿå¤´æ–‡ä»¶ï¼Œç„¶åå°±æ‰¾åˆ°äº†è¿™ä¸ªï¼Œä½†åªæœ‰clangæ‰èƒ½ç”¨ï¼Œå› ä¸ºæˆ‘è‡ªå·±ä¹Ÿç”¨clangæ‰€ä»¥å°±æ²¡å†æ‰¾gccçš„è§£å†³åŠæ³•ã€‚\nå‘½ä»¤å¦‚ä¸‹\nclang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc main.cpp \u0026gt; bundled.cpp è§£é‡Šï¼š\n-E åªè¿›è¡Œé¢„å¤„ç† -P å…³é—­åœ¨é¢„å¤„ç†ä¸­ç”Ÿæˆè¡Œæ ‡è®° -nostdinc++ å…³é—­C++æ ‡å‡†åº“ -nobuiltininc å…³é—­å†…ç½®çš„#includeç›®å½•ï¼ˆä¸å¤ªçŸ¥é“ä»€ä¹ˆæ„æ€ï¼Œå¯èƒ½æ²¡ç”¨ï¼‰ å› ä¸ºç³»ç»Ÿå¤´æ–‡ä»¶ä¸ä¼šè¢«ä¿ç•™ï¼Œæ‰€ä»¥éœ€è¦å¦ä¸€æ¡å‘½ä»¤æŠŠä½“ç»Ÿå¤´æ–‡ä»¶åŠ ä¸Šï¼Œç„¶åæˆ‘å°±å†™äº†ä¸€ä¸ªshellå‡½æ•°ä¸€èµ·åšè¿™ä¸¤ä»¶äº‹ï¼š\nexpand_cpp () { clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc $1 \u0026gt; bundled.cpp gsed -i \u0026#34;1s/^/#include \u0026lt;bits\\/stdc++.h\u0026gt;\\n/\u0026#34; bundled.cpp } ","date":1658497915,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1658497915,"objectID":"2aaf534fcdf3f74676cef5dea201c42e","permalink":"https://tgc54.com/zh/post/bundle-cpp-code/","publishdate":"2022-07-22T09:51:55-04:00","relpermalink":"/zh/post/bundle-cpp-code/","section":"post","summary":"ä½œä¸ºä¸€åç®—æ³•ç«èµ›é€‰æ‰‹ï¼Œæˆ‘ä¸€ç›´åœ¨å¯»æ‰¾é¿å…å¤åˆ¶ç²˜è´´æ¿å­çš„æ–¹æ³•ï¼Œè¿™","tags":["Tricks"],"title":"ç”¨Clangæ‰“åŒ…C++ä»£ç ","type":"post"},{"authors":[],"categories":["æ›´æ–°"],"content":"å¥½ä¹…æ²¡å†™ä¸œè¥¿äº†ï¼Œè€ƒè¯•ä¹ŸåŸºæœ¬å®Œäº‹äº†ï¼Œå¤§æ¦‚è¯´ä¸€ä¸‹æœ€è¿‘çš„ä¸€äº›å˜åŒ–ï¼Œä¸»è¦å°±ä¸¤ä¸ªï¼š1. åšå®¢æ¢äº†ä¸ªä¸»é¢˜ï¼Œä¸»è¦æ˜¯æƒ³å§portfolioå’Œåšå®¢åˆå¹¶åˆ°ä¸€ä¸ªç½‘ç«™ä¸Šï¼Œè€Œä¹‹å‰é‚£ä¸ªä¸»é¢˜æ‰©å±•æ€§å¤ªå·®äº†ï¼Œè€Œä¸”è‡ªå·±åˆä¸å†™å‰ç«¯ä»£ç ï¼Œäºæ˜¯ç ”ç©¶äº†å…¶ä»–å„ç§è§£å†³æ–¹æ¡ˆã€‚å…¶å®notionæˆ‘è¿˜æŒºå–œæ¬¢çš„ï¼Œå¯æƒœä¸å¼€æºè€Œä¸”æ²¡æ³•å¯¼å‡ºæ•°æ®ã€‚Ghostçœ‹èµ·æ¥ä¸é”™ä½†åˆå¢åŠ æ–°çš„å­¦ä¹ æˆæœ¬ï¼Œè€Œä¸”æ„Ÿè§‰æ˜¯ç”¨æ¥åšè®¢é˜…æœåŠ¡çš„ã€‚æœ€åè¿˜æ˜¯å†³å®šç»§ç»­hugoï¼Œwowchemyçœ‹èµ·æ¥ä¸é”™ï¼Œæ‰©å±•æ€§å’Œå®šåˆ¶æ€§å…¼å…·ã€‚2. å‰æ®µæ—¶é—´å¼„äº†ä¸ªwikiå•ç‹¬è®°å½•ä¸€äº›ä»¥åå¯èƒ½ä¼šç»å¸¸æŸ¥é˜…çš„ä¸œè¥¿ï¼Œè¦æ˜¯å‘åœ¨åšå®¢é‡Œå°±ä¼šåˆ†æ•£åœ¨å„ä¸ªåœ°æ–¹ä¸æ–¹ä¾¿æ£€ç´¢ã€‚é“¾æ¥å°±åœ¨èœå•æ ä¸Šã€‚\n","date":1650987722,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1650987722,"objectID":"8a1f21748b54fd4dca9e9a3f1eebc4b2","permalink":"https://tgc54.com/zh/post/update-2022-04-26/","publishdate":"2022-04-26T11:42:02-04:00","relpermalink":"/zh/post/update-2022-04-26/","section":"post","summary":"å¥½ä¹…æ²¡å†™ä¸œè¥¿äº†ï¼Œè€ƒè¯•ä¹ŸåŸºæœ¬å®Œäº‹äº†ï¼Œå¤§æ¦‚è¯´ä¸€ä¸‹æœ€è¿‘çš„ä¸€äº›å˜åŒ–ï¼Œ","tags":[],"title":"ä¸€äº›æ›´æ–°","type":"post"},{"authors":null,"categories":null,"content":"","date":1647388800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1647388800,"objectID":"846a6d9a8dbf496181714ada857357e8","permalink":"https://tgc54.com/zh/project/mirai-cp/","publishdate":"2022-03-16T00:00:00Z","relpermalink":"/zh/project/mirai-cp/","section":"project","summary":"å›´ç»•ç®—æ³•ç«èµ›çš„Mirai QQæœºå™¨äººæ’ä»¶ã€‚","tags":null,"title":"Mirai-CP","type":"project"},{"authors":null,"categories":["LaTex"],"content":"å¦‚æœæ˜¯ä¸­æ–‡æ–‡æ¡£çš„è¯å¯ä»¥ç”¨ctexåŒ…ï¼š\n\\usepackage{ctex} \\setCJKmainfont{Source Han Sans SC} % è®¾ç½®é»˜è®¤ä¸­æ–‡å­—ä½“ \\setCJKfamilyfont{songti}{FZShuSong-Z01S} % è®¾ç½®é»˜è®¤å®‹ä½“å­—ä½“ % ä¸Šé¢çš„songtiä¹Ÿå¯ä»¥æ¢æˆåˆ«çš„ï¼Œé»˜è®¤å®šä¹‰äº†songtiã€heitiã€fangsong \\begin{document} ä½¿ç”¨é»˜è®¤å­—ä½“ {\\heiti ä½¿ç”¨ç‰¹å®šå­—ä½“} \\end{document} å¦‚æœåªåŠ å…¥å°‘é‡ä¸­æ–‡çš„è¯å¯ä»¥ç›´æ¥è°ƒç”¨ä¸­æ–‡å­—ä½“ï¼š\n\\usepackage{fontspec} \\newfontfamily{\\han}{Source Han Sans SC} \\begin{document} {\\han ä¸­æ–‡} \\end{document} é™„ï¼šmacOSä¸‹â€œThe font â€œKaitiSCâ€ cannot be found.â€è§£å†³æ–¹æ¡ˆ\nè¯¦ç»†æƒ…å†µè¯·çœ‹åŸæ–‡, Montereyä¸‹æ‰§è¡Œ\nsudo tlmgr conf texmf OSFONTDIR /System/Library/AssetsV2/com_apple_MobileAsset_Font7 ","date":1646527179,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1646527179,"objectID":"32ccd4bddbb1c294c860875492e80558","permalink":"https://tgc54.com/zh/post/luatex-chinese-guide/","publishdate":"2022-03-05T19:39:39-05:00","relpermalink":"/zh/post/luatex-chinese-guide/","section":"post","summary":"","tags":["LaTex"],"title":"åœ¨LuaTex/LuaLaTexä½¿ç”¨ä¸­æ–‡ï¼Œé™„Font KaitiSC not found.è§£å†³æ–¹æ³•","type":"post"},{"authors":null,"categories":["æ¯”èµ›é¢˜è§£"],"content":"A è¾“å‡º$s/(n^2)$å³å¯ã€‚\nä»£ç \nB çº¢è‰²çš„å’Œè¦å°½é‡å¤§è€Œä¸”ä¸ªæ•°è¦å°½é‡å°ï¼Œæ‰€ä»¥æ’åºä¹‹åçº¢è‰²çš„æ˜¯ä¸€æ®µåç¼€ã€è“è‰²æ˜¯ä¸€æ®µå‰ç¼€è€Œä¸”é•¿åº¦æ¯”çº¢è‰²å¤§1ã€‚æšä¸¾çº¢è‰²çš„ä¸ªæ•°å³å¯ã€‚\nä»£ç \nC ç”±äº$15!\u0026gt;10^{12}$ï¼Œæ‰€ä»¥æœ€å¤šæœ‰15ä¸ªé˜¶ä¹˜æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾æ¯ä¸ªé˜¶ä¹˜æ˜¯å¦è¢«ç”¨ï¼Œç„¶åå‰©ä¸‹çš„æ•°è®¡ç®—å…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸­1çš„ä¸ªæ•°ã€‚è®°å¾—næ˜¯long longï¼Œæ‰€ä»¥è¦ç”¨__builtin_popcountll()ã€‚\nä»£ç \nD é™¤äº†n=2çš„æƒ…å†µï¼Œä¸¤ä¸ªgoodèŠ‚ç‚¹å°±ä¸èƒ½ç›¸é‚»çš„ï¼Œæ‰€ä»¥é—®é¢˜å°±è½¬åŒ–æˆäº†æ ‘ä¸Šæœ€å¤§ç‹¬ç«‹é›†é—®é¢˜ï¼Œç”¨æ ‘ä¸Šdpå¯ä»¥è½»æ¾è§£å†³ï¼š $dp_{u, choose}$ä»£è¡¨ $u$çš„å­æ ‘ä¸­æœ€å¤§ç‹¬ç«‹é›†ï¼Œå…¶ä¸­chooseä¸º0æˆ–1ä»£è¡¨uæ˜¯å¦åœ¨ç‹¬ç«‹é›†å½“ä¸­ï¼Œè½¬ç§»ä¸º:\n$$\\begin{aligned} dp_{u,0}\u0026amp;=\\sum_{v\\in child(u)}\\max(dp_{v, 0}, dp_{v, 1})\\\\ dp_{u, 1}\u0026amp;=\\sum_{v\\in child(u)}dp_{v, 0} \\end{aligned}$$\nå½“ç„¶è¿™ä¸ªé¢˜è¿˜è¦æœ€å°åŒ–ç‚¹æƒä¹‹å’Œï¼Œæ‰€ä»¥è¿˜è¦è®°å½•$cost_{u, i}$åœ¨å½“$dp_{u,0}=dp_{u, 1}$çš„æ—¶å€™ç”¨ã€‚è¿˜è¦è¾“å‡ºæ–¹æ¡ˆæ‰€ä»¥è¿˜å¾—è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å„¿å­é€‰æˆ–ä¸é€‰ã€‚\nä»£ç \nE é‡å¤çš„æ•°åªä¼šå‘ç”Ÿåœ¨ä¸€ä¸ªæ•°ä»¥åŠå®ƒçš„å¹‚ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡å¤„ç†ä¸€ä¸ªæ•°å’Œå®ƒçš„æ‰€æœ‰å¹‚ï¼Œå…¸å‹çš„å®¹æ–¥é—®é¢˜ã€‚\nä»£ç \nå¤§ä½¬çš„polylogå¤æ‚åº¦è§£æ³•ï¼Œnå¯ä»¥åˆ°$10^{15}$ã€‚ï¼ˆè¿˜æ²¡æ—¶é—´ä»”ç»†ç ”ç©¶ï¼‰\n","date":1646519635,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1646519635,"objectID":"bd6186fdb30ccb1444097e0743fac575","permalink":"https://tgc54.com/zh/post/cf1646/","publishdate":"2022-03-05T17:33:55-05:00","relpermalink":"/zh/post/cf1646/","section":"post","summary":"","tags":["é¢˜è§£"],"title":"Codeforces Round #774 (Div. 2) A-E é¢˜è§£","type":"post"},{"authors":null,"categories":["æ¯”èµ›é¢˜è§£"],"content":"å·®ä¸å¤šæœ€åä¸€å¹´äº†ï¼Œæ˜å¹´é˜Ÿå‹ä¼°è®¡å°±éƒ½æ¯•ä¸šäº†ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ‰¾åˆ°å…¶ä»–äººå§ï¼Œæˆ–è€…soloä¹Ÿè¡Œï¼Ÿ\næ€»ç»“ ä»Šå¹´ç”±äºç–«æƒ…ä¾ç„¶ä¸èƒ½å»æ¸©èçº¿ä¸‹æ¯”èµ›ï¼Œä½†ç›¸æ¯”å»å¹´ä¸‰äººä¸‰æœºä»Šå¤©å˜æˆäº†æ›´åƒçº¿ä¸‹çš„ä¸‰äººä¸€æœºï¼Œä¸è¿‡æ˜¯åœ¨å„è‡ªå­¦æ ¡æ¯”èµ›ï¼Œä½†ä»¤äººä¸èƒ½ç†è§£æ˜¯çš„å±…ç„¶ä¸€ç‚¹ç›‘æ§æªæ–½éƒ½æ²¡æœ‰ï¼Œå…¨å‡­è‡ªå·±è‡ªè§‰å’Œæ•™ç»ƒç›‘ç£ã€‚ã€‚ã€‚ã€‚å¯ä»¥ç†è§£ä¸ºæ‘†çƒ‚å§ğŸ˜‚ã€‚æˆ‘ä»¬é˜Ÿç®—æ˜¯åšåˆ°äº†éµå¾ªè§„åˆ™ï¼Œé™¤äº†å¤šæ¥äº†ä¸€ä¸ªæ˜¾ç¤ºå™¨ç”¨æ¥çœ‹ä»£ç ï¼ˆè‡ªå·±ç”µè„‘æ²¡æ³•è¿æœºæˆ¿çš„æ‰“å°æœºï¼‰ï¼Œä»¥åŠæˆ‘è¿˜æ˜¯ç”¨çš„è‡ªå·±çš„é”®ç›˜ï¼ˆç”¨40%é…åˆ—å¤ªä¹…äº†æ”¹ä¸å›æ¥äº†ï¼‰ã€‚\næ’åæœ‰ç‚¹å‡ºä¹æ„æ–™ï¼Œè€ƒè™‘åˆ°é˜Ÿå‹å¿™äºå®ä¹ ä»ä¸è®­ç»ƒã€æˆ‘ä¸Šäº†å¤§ä¸‰ä¹‹åè¯¾ç¨‹éš¾åº¦å¢åŠ ï¼Œåªèƒ½é æ¯å‘¨cfç»´æŒä¸€ç‚¹åšé¢˜é‡ï¼Œè¿™ä¸ªæ’åå·²ç»å¾ˆæ»¡æ„äº†ï¼Œæ¯•ç«Ÿå¦‚æœæŒ‰NACæ™‹çº§è§„åˆ™æŒ‰å­¦æ ¡æ’åæ˜¯ç¬¬6ï¼Œæ ¡æ’åè¦æ˜¯ç¬¬5çš„è¯æ€»æ’åè¦ç¬¬6ï¼Œå®Œå…¨æƒ³peachğŸ˜‚ã€‚\næ•´åœºæ¯”èµ›è¿˜æ˜¯æ¯”è¾ƒæµç•…çš„ï¼ŒåŸºæœ¬æ²¡æœ‰å¡å¤ªé•¿æ—¶é—´ï¼ŒAé¢˜ä½œä¸ºæ¯”è¾ƒç®€å•çš„é¢˜å¡äº†æœ‰ç‚¹ä¹…ï¼Œæœ€åè¿˜æ˜¯é çŒœç»“è®ºè¿‡çš„ï¼ŒFè®¡ç®—å‡ ä½•æŸé˜Ÿå‹åˆ°æœ€åä¹Ÿæ²¡æå‡ºæ¥ï¼Œä¸è¿‡æ²¡å ç”¨å¤ªå¤šæ­£å¸¸æ—¶é—´ã€‚æ—¶é—´å†ç¨å¾®å¤šä¸€ç‚¹ä¹Ÿè®¸èƒ½ææIæˆ–è€…Kï¼Œä¸è¿‡åˆ°æœ€åä¹Ÿæ¯”æœ‰ç‚¹ç´¯äº†ï¼Œæ˜¨æ™šä¹Ÿåªç¡äº†5ä¸ªåŠå°æ—¶ã€‚\né¢˜ç›® é¢˜ç›®æ•´ä½“éš¾åº¦é€‚ä¸­ï¼Ÿæ¯”å»å¹´éš¾ä¸€ç‚¹ï¼Œï¼ˆè¯»äº†çš„é¢˜ï¼‰ä»¥æ€ç»´é¢˜ä¸ºä¸»ã€‚é™¤äº†Jé¢˜æ‘†çƒ‚å‡ºäº†æœ€å¤§å­çŸ©å½¢åŸé¢˜ï¼Œé¢˜ç›®è´¨é‡è¿˜å¯ä»¥ï¼Ÿ\nA ä¸€å¼€å§‹waæ˜¯å› ä¸ºå¿˜äº†è€ƒè™‘ç›¸åŠ çš„è½¬ç§»ã€‚è€ƒè™‘åŠ çš„è¯è¦éå†ä¸€éæ•´ä¸ªdpæ•°ç»„ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šå˜æˆ$O(n^2)$ï¼Œä½†å…¶å®ä¹Ÿèƒ½è¿‡å› ä¸ºæ—¶é—´ç»™äº†15sã€‚ã€‚ã€‚ï¼ˆæˆ‘tmå†™åšå®¢çš„æ—¶å€™æ‰å‘ç°ï¼‰ã€‚ä½†è²Œä¼¼åªè¦éå†å‰é¢ä¸€äº›æ•°å°±è¡Œäº†ï¼Œå› ä¸ºæ•°å¤§çš„æ—¶å€™ä¹˜è‚¯å®šæ¯”åŠ åˆ’ç®—ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; dp(n + 1, 1e9); dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = i; for (int j = 1; j \u0026lt;= min(i / 2 + 1, 1000); j++) dp[i] = min(dp[i], dp[j] + dp[i - j]); string s = to_string(i); for (int j = 1; j \u0026lt; (int)size(s); j++) { string s1 = s.substr(0, j), s2 = s.substr(j); if (s2[0] == \u0026#39;0\u0026#39;) continue; dp[i] = min(dp[i], dp[stoi(s1)] + dp[stoi(s2)]); } for (int f = 2; f * f \u0026lt;= i; f++) { if (i % f == 0) { dp[i] = min(dp[i], dp[f] + dp[i / f]); } } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; } B èµ›æ—¶æ— è„‘æ•²äº†ä¸ªlcaï¼Œä½†å…¶å®ç¨å¾®å†æƒ³æƒ³å°±æœ‰æ›´ç®€å•çš„åšæ³•ï¼šdfsæ—¶ç»´æŠ¤åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»ä»¥åŠæœ€çŸ­çš„ä¸¤æ¡åˆ°å¶å­çš„è·¯å¾„çš„ä¸¾ä¾‹å³å¯ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); vector\u0026lt;int\u0026gt; a(n); for (auto \u0026amp;x : a) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; indeg(n), sum(n), color(n); for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; g[u].push_back(v); indeg[v]++; } int c = 0; int ans = 1e9; auto dfs = [\u0026amp;](auto \u0026amp;slf, int u, int s) -\u0026gt; int { sum[u] = s + a[u]; color[u] = c; int mn0 = 1e9, mn1 = 1e9; for (auto v : g[u]) { auto res = slf(slf, v, s + a[u]); if (res \u0026lt; mn1) mn1 = res; if (mn1 \u0026lt; mn0) swap(mn0, mn1); } ans = min(ans, mn0 + mn1 + sum[u]); return (mn0 == 1e9 ? 0 : mn0) + a[u]; }; for (int i = 0; i \u0026lt; n; i++) { if (indeg[i] == 0) { dfs(dfs, i, 0); c++; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (g[i].empty() \u0026amp;\u0026amp; g[j].empty()) { if (color[i] != color[j]) { ans = min(ans, sum[i] + sum[j]); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } G ç­¾åˆ°é¢˜ï¼Œæšä¸¾æ‰€æœ‰å‰ç¼€ä»¥åŠäº¤æ¢é¡ºåºå³å¯\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string a, b, c; char op, _; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; op \u0026gt;\u0026gt; b \u0026gt;\u0026gt; _ \u0026gt;\u0026gt; c; auto check = [\u0026amp;](string a_, string b_, string c_) { __int128 a = stoll(a_), b=stoll(b_), c = stoll(c_); if (op==\u0026#39;+\u0026#39;) return a+b==c; else return a*b==c; }; for (int i=1; i\u0026lt;(int)size(a); i++) { for (int j=1; j\u0026lt;(int)size(b); j++) { for (int k=1; k\u0026lt;(int)size(c); k++) { string a1=a.substr(0, i), a2=a.substr(0+i); string b1=b.substr(0, j), b2=b.substr(0+j); string c1=c.substr(0, k), c2=c.substr(0+k); vector\u0026lt;string\u0026gt; s = {a1, b1, c1}; sort(begin(s), end(s)); do { if (check(s[0]+a2, s[1]+b2, s[2]+c2)) { cout \u0026lt;\u0026lt; s[0]+a2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; op \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s[1]+b2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; s[2]+c2; exit(0); } } while (next_permutation(begin(s), end(s))); } } } } J ç»å…¸æœ€å¤§å­çŸ©é˜µï¼Œå•è°ƒæ ˆææå³å¯ã€‚å…¶å®æˆ‘èµ›æ—¶å·²ç»åŸºæœ¬å¿˜äº†æ€ä¹ˆåšäº†ï¼Œåªè®°å¾—æ˜¯æ˜¯å•è°ƒæ ˆï¼Œæƒ³äº†åŠå¤©æ‰æƒ³å‡ºæ¥æ­£è§£ï¼Œè¿™ä¸‹åº”è¯¥ä»¥åå¿˜ä¸äº†äº†233\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; //}}} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a[i]; } stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; stk; ll ans = 0; int s = 1e9, e = 0; auto update = [\u0026amp;](ll cur, int curs, int cure) { if (cur \u0026gt; ans || (cur == ans \u0026amp;\u0026amp; curs \u0026lt; s)) { ans = cur; s = curs; e = cure; } }; for (int i = 0; i \u0026lt; n; i++) { int prev = i; while (!stk.empty() \u0026amp;\u0026amp; stk.top().first \u0026gt;= a[i]) { prev = stk.top().second; ll cur = ll(i - prev) * stk.top().first; update(cur, prev, i - 1); stk.pop(); } ll cur = ll(i - prev + 1) * a[i]; update(cur, prev, i); stk.push({a[i], prev}); } while (!stk.empty()) { auto [x, i] = stk.top(); stk.pop(); ll cur = ll(n - i) * x; update(cur, i, n - 1); } cout \u0026lt;\u0026lt; s + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; e + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } L æšä¸¾å››ä¸ªè§’ç„¶åæ’åºåˆ†å±‚æä¸€æï¼Œé˜Ÿå‹å†™çš„\nä»£ç  import collections import itertools import sys ints = lambda: list(map(int, sys.stdin.readline().split())) grid = [] gy, gx = ints() for y in range(gy): grid.append(ints()) statues = [] for row in grid: for cell in row: if ~cell: statues.append(cell) statues.sort() def levels(grid): ret1 = collections.defaultdict(set) ret2 = collections.defaultdict(set) for y in range(gy): for x in range(gx): cell = grid[y][x] if ~cell: ret1[y+x].add(cell) ret2[y-x].add(cell) return ret1, ret2 ret1, ret2 = levels(grid) keys1 = sorted(ret1.keys()) keys2 = sorted(ret2.keys()) import math moved = math.inf for keys, ret in (keys1, ret1), (reversed(keys1), ret1), (keys2, ret2), (reversed(keys2), ret2): this = len(statues) it = iter(statues) for key in keys: st = set() for _ in range(len(ret[key])): st.add(next(it)) this -= len(st \u0026amp; ret[key]) moved = min(moved, this) print(moved) M æœ€çŸ­è·¯è€ƒè™‘ç”¨bfsï¼ŒæŠŠæ‰€æœ‰å­—ç¬¦ä¸²æ”¾å…¥ä¸€ä¸ªtrieå°±å¯ä»¥å¾ˆå®¹æ˜“çŸ¥é“å“ªäº›æ–¹å‘å¯ä»¥èµ°äº†ï¼Œæ‰€ä»¥çŠ¶æ€å°±æ˜¯[x][y][trieä¸­çš„èŠ‚ç‚¹çš„ä½ç½®][ä¸Šä¸€æ­¥çš„æ–¹å‘]ã€‚é™¤äº†çŠ¶æ€å¤æ‚ç‚¹å…¶ä»–å°±æ˜¯æ­£å¸¸bfsçš„å¥—è·¯ï¼Œæ³¨æ„å¦‚æœå½“å‰åœ¨å•è¯ç»“å°¾çš„ä½ç½®ï¼Œä¸‹ä¸€æ­¥å³å¯ä»¥å›åˆ°trieçš„æ ¹ï¼Œåˆå¯ä»¥ â€¦","date":1645927637,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1645927637,"objectID":"03623e193d41ae318130d715e4c9b8dc","permalink":"https://tgc54.com/zh/post/2021-ecna/","publishdate":"2022-02-26T21:07:17-05:00","relpermalink":"/zh/post/2021-ecna/","section":"post","summary":"å·®ä¸å¤šæœ€åä¸€å¹´äº†ï¼Œæ˜å¹´é˜Ÿå‹ä¼°è®¡å°±éƒ½æ¯•ä¸šäº†ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ‰¾åˆ°å…¶ä»–äººå§ï¼Œæˆ–è€…soloä¹Ÿè¡Œï¼Ÿ\n","tags":[],"title":"2021 ECNAåŒºåŸŸèµ›æ€»ç»“ä¸é¢˜è§£","type":"post"},{"authors":null,"categories":["ç§‘æŠ€"],"content":"ç®€å•è®°å½•è‡ªå·±æœåŠ¡å™¨çš„é…ç½®è¿‡ç¨‹ï¼Œæ–¹ä¾¿éœ€è¦æ—¶æŸ¥çœ‹ä»¥åŠä½†æ„¿å¯¹ä½ æœ‰æ‰€å¸®åŠ©ã€‚\næœåŠ¡å™¨é…ç½® æ•´æœº Intel NUC CPU i7-10710U å†…å­˜ 16G ç¡¬ç›˜ 500Gè¥¿æ•°è“ç›˜+1TBå¸Œæ·æœºæ¢° OS Ubuntu 20.04.4 LTS é€šç”¨ è¿œç¨‹è®¿é—®ï¼šç«¯å£è½¬å‘ï¼ŒDDNSâ€¦\nSSLè¯ä¹¦ï¼š\nhttps://www.youtube.com/watch?v=c1t_OrIia1U\nhttps://certbot.eff.org/instructions?ws=apache\u0026amp;os=ubuntufocal\nè½¯ä»¶ Nextcloud å®‰è£…æ•™ç¨‹\nåå‘ä»£ç†\nPi-hole å®‰è£…ï¼šä½¿ç”¨å®˜æ–¹å®‰è£…è„šæœ¬å³å¯ã€‚æ³¨æ„ï¼šè„šæœ¬æœ‰ä¸ªbugï¼Œå³ä½¿ä½ å·²ç»è£…äº†å…¶ä»–web serverï¼ˆæ¯”å¦‚Apacheï¼‰ä¹Ÿè¦é€‰æ‹©è£…lighttdpï¼Œå¦åˆ™é‡å¯æœåŠ¡çš„æ—¶å€™è„šæœ¬ä¼šå´©æºƒã€‚ã€‚ã€‚ï¼ˆå½“ä½ çœ‹åˆ°æ­¤çš„æ—¶å€™ä¹Ÿè®¸å·²ç»ä¿®å¤äº†ï¼‰\né…ç½®Apacheä»¥è®¿é—®web UI\nä¸€äº›é»‘åå•ï¼š\nhttps://github.com/blocklistproject/Lists https://anti-ad.net/domains.txt Photoprism å®‰è£…\nåå‘ä»£ç†ï¼ŒæŠŠhttpä¸­çš„photoprismæ¢æˆlocalhost\nRSSHub docker composeéƒ¨ç½²\nMiniflux docker composeéƒ¨ç½²\nNavidrome docker-compose\nqBittorrent(-nox) åœ¨æœåŠ¡å™¨ç”±äºæ²¡æœ‰xorgæ‰€ä»¥è£…çš„æ˜¯noxç‰ˆæœ¬\n[å®‰è£…æ•™ç¨‹](https://github.com/qbittorrent/qBittorrent/wiki/Running-qBittorrent-without-X-server-(WebUI-only,-systemd-service-set-up,-Ubuntu-15.04-or-newer)\nä¸çŸ¥é“ä¸ºå•¥ç”¨å±€åŸŸç½‘ä¹Ÿè®¿é—®ä¸åˆ°ï¼Œä¸€ç§è§£å†³åŠæ³•æ˜¯åˆ©ç”¨sshå»ºç«‹é€šé“ï¼ˆæ•™ç¨‹)ï¼Œæˆ–è€…apacheåå‘ä»£ç†ã€‚\n","date":1645563342,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1645563342,"objectID":"21e44658bfc714e7c8c6524297ca6588","permalink":"https://tgc54.com/zh/post/home-server-guide/","publishdate":"2022-02-22T15:55:42-05:00","relpermalink":"/zh/post/home-server-guide/","section":"post","summary":"ç®€å•è®°å½•è‡ªå·±æœåŠ¡å™¨çš„é…ç½®è¿‡ç¨‹ï¼Œæ–¹ä¾¿éœ€è¦æ—¶æŸ¥çœ‹ä»¥åŠä½†æ„¿å¯¹ä½ æœ‰æ‰€å¸®åŠ©ã€‚\n","tags":["ç§‘æŠ€"],"title":"å®¶åº­æœåŠ¡å™¨æŠ˜è…¾è®°å½•","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æœ‰æ®µæ—¶é—´æ²¡åšéš¾ä¸€ç‚¹çš„æ€ç»´é¢˜äº†\næ€è·¯ é¦–å…ˆä¸éš¾å‘ç°å¯¹äºæ¯ä¸ªæ•°æ¥è¯´ï¼Œå®ƒçš„ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®æ˜¯æœ€é‡è¦çš„ï¼Œå› ä¸ºä½¿ç”¨å…¶ä»–ä½ç½®çš„æ“ä½œéƒ½å¯ä»¥ä½¿ç”¨ä¸¤ç«¯çš„ä½ç½®å®Œæˆè€Œä¸”ä¸­é—´çš„ä½ç½®çš„cå€¼å¯ä»¥è¢«ä¸¤ç«¯å˜æˆ1ã€‚æˆ‘ä»¬å°†æ¯ä¸ªæ•°$i$çš„ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡ä½ç½®è®°ä½œ$l_i, r_i$ï¼Œäºæ˜¯æˆ‘ä»¬å°±å¯ä»¥å°†æ¯ä¸ªæ•°è¡¨ç¤ºæˆä¸€ä¸ªçº¿æ®µ $[l_i, r_i]$ã€‚\nå¯¹äºä¸€ä¸ªçº¿æ®µçš„é›†åˆ$S$ï¼Œå¦‚æœè¿™äº›çº¿æ®µçš„å¹¶é›†ç­‰äºçº¿æ®µ$[\\min(l_i), \\max(r_i)]$ï¼Œæˆ‘ä»¬ç§°$S$æ˜¯è¿é€šçš„ã€‚ å¯¹äºæ‰€æœ‰çº¿æ®µæˆ‘ä»¬å¯ä»¥å°†å…¶åˆ’åˆ†ä¸ºæå¤§è¿é€šå­é›†å¯¹äºæ¯ä¸ªå­é›†å…¶äº’ä¸å½±å“æ‰€ä»¥æœ€ç»ˆçš„ç­”æ¡ˆå°±æ˜¯æ¯ä¸ªå­é›†çš„ç­”æ¡ˆä¹‹å’Œã€‚\nå¯¹äºæ¯ä¸ªæå¤§å­é›†$S$ï¼Œæˆ‘ä»¬å¯èƒ½æ‰¾åˆ°å…¶æœ€å°å­é›†$Sâ€™\\subseteq S$ä½¿å¾—$Sâ€™$ä¸­çš„çº¿æ®µçš„å¹¶ç­‰äº $S$ä¸­çº¿æ®µçš„å¹¶ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥å°†å°½é‡å¤šçš„çº¿æ®µçš„ç«¯ç‚¹çš„cå€¼å˜æˆ1.å¯¹äº $Sâ€™$ä¸­çš„çº¿æ®µæˆ‘ä»¬å¯ä»¥è¯æ˜æœ€å¤šå¯ä»¥å°† $|Sâ€™|-1$ä¸ªä½ç½®çš„cå€¼å˜æˆ1ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; l(n, n), r(n, -1); for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; x--; l[x] = min(l[x], i); r[x] = max(r[x], i); } vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; b, c; for (int i = 0; i \u0026lt; n; i++) { if (l[i] \u0026lt; r[i]) b.emplace_back(l[i], r[i]); } sort(begin(b), end(b)); for (auto [l, r] : b) { // å»é™¤åœ¨åŒ…å«åœ¨å…¶ä»–çº¿æ®µä¹‹å†…çš„çº¿æ®µ if (c.empty() || r \u0026gt; c.back().second) c.emplace_back(l, r); } int ans = 0, last = -1; int m = size(c); for (int i = 0; i \u0026lt; m; i++) { if (c[i].first \u0026gt; last) { // æ–°çš„å­é›†çš„ç¬¬ä¸€ä¸ªçº¿æ®µï¼Œç«¯ç‚¹çš„cå€¼æ— æ³•å˜æˆ1 ans += c[i].second - c[i].first - 1; last = c[i].second; } else if (i == m - 1 || c[i + 1].first \u0026gt; last) { // å­é›†ä¸­çš„å…¶ä»–çº¿æ®µï¼Œå·¦ç«¯ç‚¹cå€¼ä¼šå˜æˆ1ï¼Œä¼šåœ¨ä¹‹å‰è¢«è®°å…¥ç­”æ¡ˆ ans += c[i].second - last - 1; last = c[i].second; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","date":1643473246,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1643473246,"objectID":"59f0ad23dd9eebefcaa92712026e77d7","permalink":"https://tgc54.com/zh/post/cf1630c/","publishdate":"2022-01-29T11:20:46-05:00","relpermalink":"/zh/post/cf1630c/","section":"post","summary":"æœ‰æ®µæ—¶é—´æ²¡åšéš¾ä¸€ç‚¹çš„æ€ç»´é¢˜äº†\n","tags":["æ€ç»´"],"title":"Codeforces Round #768 Div1C/Div2E Paint the Middleé¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ æœ¬é¢˜è¦æ±‚çš„æ˜¯åœ¨æŸä¸€æ—¶åˆ»å‰kå°çš„ä¼˜å…ˆçº§çš„å’Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¦¨ä»¥ä¼˜å…ˆçº§ï¼ˆè¦å…ˆç¦»æ•£åŒ–ï¼‰ä¸ºä¸‹æ ‡å»ºç«‹å¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼ˆä¸»å¸­æ ‘ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ä»ä»»ä¸€æ ¹èŠ‚ç‚¹å‡ºå‘å¾—åˆ°çš„æ˜¯æŸä¸€æ—¶åˆ»æ­£åœ¨è¿è¡Œçš„æ‰€æœ‰ä»»åŠ¡ã€‚è¿™æ ·ä¸€ä¸ªä»»åŠ¡å¯ä»¥è¢«æ‹†åˆ†æˆä¸¤ä¸ªäº‹ä»¶ï¼š\nåœ¨Sç§’æ—¶åŠ å…¥æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡çš„é›†åˆï¼ˆä¹Ÿå°±æ˜¯åœ¨ä¸»å¸­æ ‘ä¸Šå¯¹åº”çš„ä¼˜å…ˆçº§ä¸Š+1ï¼‰ åœ¨E+1ç§’æ—¶ä»æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡çš„é›†åˆä¸­ç§»é™¤ï¼ˆä¹Ÿå°±æ˜¯åœ¨ä¸»å¸­æ ‘ä¸Šå¯¹åº”çš„ä¼˜å…ˆçº§ä¸Š-1ï¼‰ æˆ‘ä»¬æŠŠæ‰€æœ‰äº‹ä»¶æŒ‰æ—¶é—´é¡ºåºæ’åºå¹¶ä¾æ¬¡æ›´æ–°ä¸»å¸­æ ‘ï¼Œå¹¶è®°å½•å¯¹äºæ¯ä¸ªæ—¶åˆ»ï¼Œè¯¥æ—¶åˆ»å‰æœ€æ–°ç‰ˆæœ¬çš„çº¿æ®µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼ŒæŸ¥è¯¢æ—¶å°±ä»è¯¥æ ¹èŠ‚ç‚¹å‡ºå‘ã€‚\nçº¿æ®µæ ‘è¦ç»´æŠ¤ä¸¤ä¸ªä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯åŒºé—´å†…æ­£åœ¨è¿è¡Œä»»åŠ¡çš„æ•°é‡ï¼Œä¸€ä¸ªæ˜¯æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡çš„ä¼˜å…ˆçº§ä¹‹å’Œã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯æŸ¥è¯¢çš„æ˜¯å•ä¸€æ—¶åˆ»çš„ä¿¡æ¯ï¼Œä¸åƒæ±‚åŒºé—´ç¬¬kå°æ—¶è¦ä¸¤ä¸ªåŒºé—´ä¿¡æ¯ç›¸å‡ï¼Œæ‰€ä»¥å†™èµ·æ¥ä¹Ÿç®€å•ä¸€ç‚¹ã€‚\nä¸€ä¸ªéå¸¸å®¹æ˜“é”™çš„åœ°æ–¹æ˜¯æŸ¥è¯¢æ˜¯å½“èµ°åˆ°å¶å­èŠ‚ç‚¹æ—¶ï¼Œå¦‚æœè¯¥ä¼˜å…ˆçº§çš„ä»»åŠ¡æ•°é‡å¤§äºå½“å‰çš„kå€¼ï¼Œä¸èƒ½ç›´æ¥åŠ ä¸Šå¶å­èŠ‚ç‚¹ä¸­çš„ä¼˜å…ˆçº§ä¹‹å’Œï¼Œè¦å…ˆé™¤ä»¥ä»»åŠ¡æ•°é‡å†ä¹˜kå€¼ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; struct PST { int n, tot = 0; struct node { int lc, rc, cnt; ll sum; }; vector\u0026lt;node\u0026gt; t; vector\u0026lt;int\u0026gt; roots; // left child, right child PST(int n_) : n(n_), t(n \u0026lt;\u0026lt; 6), roots(1) { build(0, n - 1, roots[0]); } #define lc(rt) t[rt].lc #define rc(rt) t[rt].rc void pushup(int rt) { t[rt].sum = t[lc(rt)].sum + t[rc(rt)].sum; t[rt].cnt = t[lc(rt)].cnt + t[rc(rt)].cnt; } void build(int l, int r, int \u0026amp;rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc(rt)); build(mid + 1, r, rc(rt)); pushup(rt); } void update(int pos, int dcnt, int dsum, int l, int r, int old, int \u0026amp;rt) { rt = ++tot; t[rt] = t[old]; if (l == r) { t[rt].cnt = t[old].cnt + dcnt; t[rt].sum = t[old].sum + dsum; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, dcnt, dsum, l, mid, lc(old), lc(rt)); else update(pos, dcnt, dsum, mid + 1, r, rc(old), rc(rt)); pushup(rt); } int update(int pos, int dcnt, int dsum) { // return the root of the new version int new_root; update(pos, dcnt, dsum, 0, n - 1, roots.back(), new_root); roots.push_back(new_root); return new_root; } ll query(int v, int l, int r, int k) { if (l == r) return (t[v].cnt \u0026gt; k ? t[v].sum / t[v].cnt * k : t[v].sum); int mid = (l + r) / 2, x = t[lc(v)].cnt; ll sum = t[lc(v)].sum; if (k \u0026lt;= x) return query(lc(v), l, mid, k); return sum + query(rc(v), mid + 1, r, k - x); } ll query(int v, int k) { return query(v, 0, n - 1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; tasks(n); vector\u0026lt;int\u0026gt; p; // æ‰€æœ‰çš„ä¼˜å…ˆçº§ï¼Œç”¨äºç¦»æ•£åŒ– for (auto \u0026amp;[s, e, pp] : tasks) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; pp; p.push_back(pp); } sort(begin(p), end(p)); p.erase(unique(begin(p), end(p)), end(p)); // ç¦»æ•£åŒ– vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; events; for (auto [s, e, pp] : tasks) { int id = lower_bound(begin(p), end(p), pp) - begin(p); // ä¸¤ä¸ªäº‹ä»¶ï¼Œç”¨ä¼˜å…ˆçº§çš„æ­£è´Ÿæ¥è¡¨ç¤ºåŠ å…¥æˆ–è€…åˆ é™¤ events.emplace_back(s, id + 1); events.emplace_back(e + 1, -id - 1); } sort(begin(events), end(events)); PST tr(size(p)); vector\u0026lt;int\u0026gt; roots(n + 1); // root[i]ä»£è¡¨iæ—¶åˆ»å‰æœ€æ–°çš„çº¿æ®µæ ‘çš„ç‰ˆæœ¬ roots[0] = 1; for (auto [time, id] : events) { if (id \u0026gt; 0) { roots[time] = (tr.update(id - 1, 1, p[id - 1])); } else { id = -id - 1; roots[time] = (tr.update(id, -1, -p[id])); } } for (int i = 1; i \u0026lt;= n; i++) // å¯¹äºæ²¡æœ‰äº‹ä»¶å‘ç”Ÿçš„æ—¶åˆ»iï¼Œå…¶æœ€æ–°çš„ç‰ˆæœ¬ä¸ºä¸Šä¸€æ—¶åˆ»çš„æœ€æ–°ç‰ˆæœ¬ if (!roots[i]) roots[i] = roots[i - 1]; ll pre = 1; while (q--) { int x, a, b, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; auto k = 1 + (a * pre + b) % c; auto res = tr.query(roots[x], k); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pre = res; } } ","date":1642777956,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1642777956,"objectID":"52dbd014a2d13f0306d5b650f88a5790","permalink":"https://tgc54.com/zh/post/loj2097/","publishdate":"2022-01-21T10:12:36-05:00","relpermalink":"/zh/post/loj2097/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„","å¯æŒä¹…åŒ–çº¿æ®µæ ‘","ä¸»å¸­æ ‘"],"title":"ã€ŒCQOI2015ã€ä»»åŠ¡æŸ¥è¯¢ç³»ç»Ÿé¢˜è§£","type":"post"},{"authors":null,"categories":[],"content":"ç”¨PB_DSå®ç°ä¸€ä¸ªåªèƒ½å•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘ï¼Œä½†åˆèƒ½åŠ¨æ€æ’å…¥å’Œåˆ é™¤ï¼Œç°åœºèµ›çš„æ—¶å€™åœ¨å¯¹æ—¶é—´è¦æ±‚ä¸å¤§çš„æƒ…å†µä¸‹å¯ä»¥èŠ‚çº¦æ•²ä»£ç æ—¶é—´ã€‚\nåŸç† åŸç†å°±æ˜¯PB_DSé‡Œçš„treeçš„æœ€åä¸€ä¸ªæ¨¡æ¿å‚æ•°å®šä¹‰äº†èŠ‚ç‚¹å¦‚ä½•æ›´æ–°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è‡ªå®šä¹‰ç±»è®©èŠ‚ç‚¹ç»´æŠ¤é¢å¤–çš„ä¿¡æ¯ï¼ˆå­æ ‘å¤§å°ä¹‹ç±»çš„ï¼‰ã€‚éœ€è¦å®šä¹‰é¢å¤–ä¿¡æ¯ç±»ä¸ºmetadata_typeï¼Œç„¶åé‡è½½æ‹¬å·è¿ç®—ç¬¦æ¥å®šä¹‰èŠ‚ç‚¹å¦‚ä½•åˆå¹¶ã€‚é€šè¿‡æ ‘åˆ†è£‚å®ç°åŒºé—´æŸ¥è¯¢ï¼Œä½†æœ‰ä¸ªé—®é¢˜å°±æ˜¯åˆ†è£‚ä¹‹åçš„æ ‘çš„å¤§å°æ˜¯é€šè¿‡std::distance()æ¥è®¡ç®—çš„ï¼Œå¯¹äºtreeçš„è¿­ä»£å™¨æ¥è¯´æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜è¦é‡è½½ $std::distance$\nä¾‹å­ï¼šRMQ #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; struct Node { int size, min; }; template\u0026lt;typename node_const_iterator, typename node_iterator, typename cmp_fn, typename _Alloc\u0026gt; struct tree_max { typedef Node metadata_type; inline void operator() (node_iterator it, node_const_iterator null) const { auto\u0026amp; n = (Node\u0026amp;)it.get_metadata(); n.size=1; n.min=(*it)-\u0026gt;second; for (auto\u0026amp; c : {it.get_l_child(), it.get_r_child()}) { if (c != null) { n.size+=c.get_metadata().size; n.min=min(n.min, c.get_metadata().min); } } } }; using Tree = __gnu_pbds::tree\u0026lt;int, int, std::less\u0026lt;int\u0026gt;, __gnu_pbds::splay_tree_tag, tree_max\u0026gt;; using ti = Tree::iterator; Tree *other; namespace std { template\u0026lt;\u0026gt; iterator_traits\u0026lt;ti\u0026gt;::difference_type distance\u0026lt;ti\u0026gt;(ti a, ti b) { return other-\u0026gt;node_begin().get_metadata().size; } } void split(Tree\u0026amp; a, Tree\u0026amp; b, int x) { other = \u0026amp;b; a.split(x, b); } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; Tree tr; for (int i=0; i\u0026lt;n; i++) { int x; cin \u0026gt;\u0026gt; x; tr.insert({i, x}); } while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; Tree B, C; split(tr, C, r-1); split(tr, B, l-1); cout \u0026lt;\u0026lt; B.node_begin().get_metadata().min\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; tr.join(B); tr.join(C); } } éåˆ†è£‚åšæ³• å¯¹äºå¯é€†çš„ä¿¡æ¯ï¼ˆå¦‚åŒºé—´å’Œï¼‰æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨æ ‘ä¸Šè¡Œèµ°è·å¾—å‰ç¼€ä¿¡æ¯ï¼Œç„¶åé€šè¿‡å‰ä¸ªå‰ç¼€ä¿¡æ¯å¾—åˆ°åŒºé—´ä¿¡æ¯ã€‚ç›®å‰å…ˆè´´ä¸ªåˆ«äººçš„é“¾æ¥ï¼Œè¿˜æ²¡ç ”ç©¶å¦‚ä½•å†™çš„çŸ­ç‚¹ã€‚\n","date":1641696535,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1641696535,"objectID":"21b0d3e5a42523d5b7072b2386ffe801","permalink":"https://tgc54.com/zh/post/pb_ds-segment-tree/","publishdate":"2022-01-08T21:48:55-05:00","relpermalink":"/zh/post/pb_ds-segment-tree/","section":"post","summary":"ç”¨PB_DSå®ç°ä¸€ä¸ªåªèƒ½å•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘ï¼Œä½†åˆèƒ½åŠ¨æ€æ’å…¥å’Œåˆ é™¤ï¼Œç°åœºèµ›çš„æ—¶å€™åœ¨å¯¹æ—¶é—´è¦æ±‚ä¸å¤§çš„æƒ…å†µä¸‹å¯ä»¥èŠ‚çº¦æ•²ä»£ç æ—¶é—´ã€‚\n","tags":[],"title":"ç”¨PB_DSå®ç°ç®€å•çº¿æ®µæ ‘","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ä¸€ç§æ¯”å®˜æ–¹é¢˜è§£ç®€å•ä¸€ç‚¹çš„åšæ³•\nå‰ç½®çŸ¥è¯† ç¡®ä¿ä½ å·²ç»çŸ¥é“D1çš„åšæ³•\né¢˜è§£ ç”±äºæˆ‘ä»¬å·²ç»çŸ¥é“äº†åŒºé—´é•¿åº¦ä¸ºå¶æ•°çš„æ—¶å€™æœ€å¤šåªç”¨å»æ‰ä¸¤ä¸ªæ•°è€Œé•¿åº¦ä¸ºå¥‡æ•°çš„æ—¶å€™è¦å»æ‰ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥å¯¹äºåŒºé—´é•¿åº¦ä¸ºå¶æ•°çš„è¯¢é—®ï¼Œæˆ‘ä»¬å¯ä»¥å»æ‰æœ€åä¸€ä¸ªæ•°ä»è€Œå°†å…¶è½¬åŒ–ä¸ºé•¿åº¦ä¸ºå¥‡æ•°çš„è¯¢é—®ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦è€ƒè™‘å¦‚ä½•æ±‚é•¿åº¦ä¸ºå¥‡æ•°çš„è¯¢é—®å³å¯ã€‚\né¦–å…ˆè¿˜æ˜¯åƒD1ä¸€æ ·æ±‚å‡ºå‰ç¼€å’Œï¼Œå°†$l\\dots r$çš„åŒºé—´å’Œè®°ä½œ $S_{l, r}$ã€‚ä¸éš¾å¾—å‡ºå»æ‰ä¸€ä¸ªæ•°ä¹‹ååŒºé—´å’Œä¼šå˜æˆ$S_{l, i-1}-S_{i+1, r}$ã€‚ æˆ‘ä»¬æƒ³ä½¿å…¶ä¸º0ï¼Œæ‰€ä»¥è¦æ‰¾åˆ°ä¸€ä¸ª$i$ä½¿å¾—$S_{l, i-1}=S_{i+1, r}$ã€‚å°†ç­‰å¼åšå¦‚ä¸‹å˜æ¢ï¼š $$\\begin{align*} S_{l, i-1}\u0026amp;=S_{i+1, r}\\\\ S_{0, i-1}-S_{0, l-1} \u0026amp;= S_{0, r} - S_{0, i}\\\\ S_{0, i-1} + S_{0, i} \u0026amp;= S_{0, r} + S_{0, l-1} \\end{align*}$$\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥æç”¨æ‰€æœ‰$i$çš„ $S_{0, i-1}+S_{0, i}$çš„å€¼æ„å»ºåæŸ¥è¡¨ï¼ˆå³ç»™å‡º$S_{0, i-1}+S_{0, i}$çš„å€¼æŸ¥è¯¢ç¬¦åˆæ¡ä»¶çš„$i$ï¼‰ã€‚è¿™æ ·å°±å¯ä»¥åšåˆ° $O(\\log n)$å›ç­”è¯¢é—®äº†ï¼ˆlogæ¥è‡ªäºåœ¨åæŸ¥è¡¨ä¸­äºŒåˆ†ï¼‰ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void test_case() { int n, q; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; ps(n + 1); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(4 * n + 1); for (int i = 0; i \u0026lt; n; i++) { int x = (s[i] == \u0026#39;+\u0026#39; ? 1 : -1); ps[i + 1] = ps[i] + (i % 2 ? -x : x); } const int OFFSET = 2 * n; for (int i = 1; i \u0026lt;= n; i++) { pos[ps[i] + ps[i - 1] + OFFSET].push_back(i); } auto solve = [\u0026amp;](int l, int r) { int x = ps[l] + ps[r] + OFFSET; auto it = lower_bound(pos[x].begin(), pos[x].end(), l + 1); assert(it != end(pos[x]) \u0026amp;\u0026amp; *it \u0026lt;= r); return *it; }; while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--; if (ps[r] - ps[l] == 0) { cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; } else { if ((r - l) % 2) cout \u0026lt;\u0026lt; \u0026#34;1\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;2\\n\u0026#34; \u0026lt;\u0026lt; r-- \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; solve(l, r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; while (tt--) { test_case(); } } ","date":1640543778,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1640543778,"objectID":"47bcd131cb098ee61adede5570096441","permalink":"https://tgc54.com/zh/post/cf1562d2/","publishdate":"2021-12-26T11:36:18-07:00","relpermalink":"/zh/post/cf1562d2/","section":"post","summary":"ä¸€ç§æ¯”å®˜æ–¹é¢˜è§£ç®€å•ä¸€ç‚¹çš„åšæ³•\n","tags":["å‰ç¼€å’Œ"],"title":"Codeforces Round #741 D2(1562D2) - Two Hundred Twenty One (hard version) é¢˜è§£","type":"post"},{"authors":null,"categories":null,"content":"","date":1636848e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1636848e3,"objectID":"fe2f41546cc94fa45b68377537542160","permalink":"https://tgc54.com/zh/project/cp-parser/","publishdate":"2021-11-14T00:00:00Z","relpermalink":"/zh/project/cp-parser/","section":"project","summary":"ç”¨å‘½ä»¤è¡Œè·å–å„ç§ç®—æ³•ç«èµ›ç½‘ç«™çš„æ ·ä¾‹","tags":null,"title":"Competitive Programming Parser","type":"project"},{"authors":null,"categories":["é”®ç›˜"],"content":"ä¸€ç¯‡å¦‚ä½•ç”¨ä¸¤ä¸ªpro microå½“ä½œISP(In-System Programmer)äº’ç›¸ç»™å¯¹æ–¹åˆ·ä¸ŠDFU bootloader.\nä¼—æ‰€å‘¨çŸ¥ï¼Œä¸€èˆ¬pro microè‡ªå¸¦çš„bootloaderæ˜¯caterinaï¼Œæœ‰ä¸€ä¸ªæ¯”è¾ƒçƒ¦äººçš„ç¼ºç‚¹å°±æ˜¯ä¸€æ¬¡resetä¹‹ååªæœ‰8ç§’çš„æ—¶é—´åœ¨dfuæ¨¡å¼é‡Œã€‚è€Œdfu bootloaderå°±ä¸ä¼šæœ‰è¿™ä¸ªé—®é¢˜ã€‚\nå…è´£å£°æ˜ æœ¬äººå¹¶ä¸æ˜¯å­¦ç”µå­ä¸“ä¸šçš„ï¼Œåªæ˜¯ä»¥ä¸€ä¸ªå®¢åˆ¶åŒ–é”®ç›˜çˆ±å¥½è€…çš„è§’åº¦å†™çš„æ­¤æ•™ç¨‹ï¼Œå¦‚æœ‰ä¸æ…æˆ–æ„å¤–å¯èƒ½ä¼šå¯¼è‡´pro microå˜ç –ã€‚çº¯å°ç™½è¯·è°¨æ…è€ƒè™‘ã€‚æœ¬æ–‡å¦‚æœ‰é”™è¯¯æ¬¢è¿æŒ‡æ­£ã€‚\nå·¥å…· è½¯ä»¶ Arduino IDE QMK toolbox bootloaderæ–‡ä»¶ ç¡¬ä»¶ ä¸¤ä¸ª pro microï¼Œ6æ ¹å¯¼çº¿\næ­¥éª¤ ç»™ä¸¤ä¸ªpro microåˆ·bootloaderçš„æ­¥éª¤ç¨æœ‰ä¸åŒ\nç»™ç¬¬ä¸€ä¸ªpro microåˆ· æ‰“å¼€Arduino IDE, Tools -\u0026gt; Arduino Leonardo, Tools -\u0026gt; Port å¹¶è®°ä½ç«¯å£å·ï¼ŒFile -\u0026gt; Examples -\u0026gt; ArduinoISP -\u0026gt; ArduinoISP ç„¶åç‚¹uploadï¼Œè¿™æ ·ä¸€ä¸ªpro microå°±å˜æˆäº†ISPã€‚ æ¥çº¿ï¼š æ¯è¡Œå·¦å³ä¸¤ä¾§è„šä½ç›¸è¿:\nISP ç›®æ ‡ VCC VCC GND GND SCLK SCLK MISO MISO MOSI MOSI 10 RST åˆ·å…¥ Win+Rç„¶åè¾“å…¥cmdæ‰“å¼€å‘½ä»¤è¡Œï¼Œç„¶åè¿›åˆ°QMK Toolboxçš„ç›®å½•ï¼Œç”¨åˆ°çš„ç¨‹åºåœ¨è¿™ä¸ªç›®å½•é‡Œã€‚ä¸‹é¢çš„0.x.xè¦æ¢æˆä½ QMK Toolbox çš„ç‰ˆæœ¬å·(å†™è¿™ä¸ªæ•™ç¨‹æ—¶æœ€æ–°çš„ç‰ˆæœ¬ä¸º0.1.1)ï¼Œæ‰€ä»¥ä¸è¦ç›´æ¥å¤åˆ¶ç²˜è´´ã€‚\ncd AppData\\Local\\QMK\\QMK Toolbox\\0.x.x\\ ç„¶åè¿è¡Œåˆ·å…¥çš„å‘½ä»¤ï¼Œå…¶ä¸­\u0026lt;PORT\u0026gt;æ¢æˆç¬¬ä¸€æ­¥ä¸­çš„ç«¯å£å·ï¼Œ\u0026lt;PATH\u0026gt;æ¢æˆbootloaderæ–‡ä»¶çš„åœ°å€\navrdude.exe -c arduino -p atmega32u4 -P \u0026lt;PORT\u0026gt; -U flash:w:\u0026#34;\u0026lt;PATH\u0026gt;\u0026#34;:a -U hfuse:w:0xD9:m -U efuse:w:0xC3:m -U lock:w:0x3F:m å¦‚æœè¿è¡ŒæˆåŠŸçš„è¯ä½ å°±æˆåŠŸå°†dfu bootloaderåˆ·åˆ°pro microä¸Šäº†ã€‚\nç»™å¦ä¸€ä¸ªpro microåˆ· ç”±äºarduinoä¸æ”¯æŒdfuï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨å¦ä¸€ä¸ªç¨‹åºdfu-programmerï¼ˆä¹Ÿåœ¨QMK Toolboxçš„ç›®å½•ä¸‹ï¼‰æ¥å°†åˆ·å…¥dfuçš„é‚£ä¸ªpro microå†å˜æˆISPã€‚é¦–å…ˆè¦æ‰¾åˆ°ArduinoISPç¼–è¯‘åçš„hexæ–‡ä»¶:AppData\\Local\\Temp\\arduino_build_xxxxxx\\ArduinoISP.ino.hex(xxxxxxæ˜¯ä¸€ä¸²æ•°å­—ï¼Œæ¯ä¸ªäººçš„ä¸ä¸€æ ·)ã€‚æ¥ä¸‹æ¥å°±å‡†å¤‡åˆ·å…¥äº†ï¼Œè¿˜æ˜¯åœ¨QMK Toolboxçš„ç›®å½•ä¸‹ï¼Œæ‰§è¡Œä¸‹é¢3æ¡å‘½ä»¤ï¼š(å…¶ä¸­æ¢æˆåˆšæ‰æåˆ°çš„ArduinoISP.ino.hexçš„è·¯å¾„)\ndfu-programmer.exe atmega32u4 erase dfu-programmer.exe atmega32u4 flash \u0026lt;PATH\u0026gt; dfu-programmer.exe atmega32u4 reset æœ€åå†é‡å¤ä¸Šä¸€ä¸ªéƒ¨åˆ†çš„2ã€3æ­¥å³å¯ã€‚\nå‚è€ƒèµ„æ–™ https://www.reddit.com/r/olkb/comments/9ctx37/qmk_burn_dfu_bootloader_into_keyboard_with/ https://www.reddit.com/r/olkb/comments/8sxgzb/replace_pro_micro_bootloader_with_qmk_dfu/\n","date":1634102269,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1634102269,"objectID":"549827b65bcba7ef724ac044d57f14be","permalink":"https://tgc54.com/zh/post/pro-micro-dfu-bootloader/","publishdate":"2021-10-12T23:17:49-06:00","relpermalink":"/zh/post/pro-micro-dfu-bootloader/","section":"post","summary":"ä¸€ç¯‡å¦‚ä½•ç”¨ä¸¤ä¸ªpro microå½“ä½œISP(In-System Programmer)äº’ç›¸ç»™å¯¹æ–¹åˆ·ä¸ŠDFU bootloader.\n","tags":["é”®ç›˜","å®¢åˆ¶åŒ–"],"title":"ç”¨ä¸¤ä¸ªPro Microäº’ç›¸ç»™å¯¹æ–¹åˆ·ä¸ŠDFU bootloader","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ä»åŠ¨æ€è§„åˆ’çš„è§’åº¦è€ƒè™‘ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°çš„ä¸€ç§çŠ¶æ€æ˜¯å½“å‰ä½ç½®å‰$m$çš„å­—ç¬¦çš„çŠ¶æ€ï¼Œä½†è¿™æ ·çš„çŠ¶æ€æ•°ä¸º$2^m$ï¼Œæ˜¾ç„¶ä¸å¯è¡Œã€‚ä¸å¦¨è¿›ä¸€æ­¥æƒ³ï¼Œå½“å‰å­—ç¬¦ä¸²èƒ½å¯¹åé¢äº§ç”Ÿå½±å“çš„åªæœ‰ä¸å­—ç¬¦ä¸² $b$çš„å‰ç¼€åŒ¹é…çš„éƒ¨åˆ†ï¼Œ æ‰€ä»¥çŠ¶æ€å¯ä»¥è¢«ä¼˜åŒ–ä¸ºå½“å‰å­—ç¬¦ä¸²çš„åç¼€ä¸$b$çš„å‰ç¼€æœ€å¤§åŒ¹é…é•¿åº¦ã€‚æ•´ä¸ªdpçš„çŠ¶æ€$dp_{i, j, k}$ä¸ºå½“å‰ä½ç½® $i$, $b$ä½œä¸ºå­ä¸²å·²ç»å‡ºç°äº† $j$æ¬¡ï¼Œ æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ä¸º$k$ã€‚\nä¸ºäº†å®ç°$O(1)$è½¬ç§»ï¼Œæˆ‘ä»¬è¿˜éœ€è¦é¢„å¤„ç†å¯¹äº$b$çš„æ‰€æœ‰åç¼€ï¼Œåœ¨åé¢åŠ 0æˆ–è€…åŠ 1ä¹‹åå…¶åç¼€ä¸$b$çš„å‰ç¼€çš„æœ€å¤§åŒ¹é…çŠ¶æ€ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=500; short dp[N+1][N+1][N+1], nxt[N+1][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a=\u0026#39; \u0026#39;+a, b=\u0026#39; \u0026#39;+b; for (int i=0; i\u0026lt;=m; i++) { for (int x : {0, 1}) { string s=b.substr(1, i)+char(\u0026#39;0\u0026#39;+x); for (int j=min(m, (int)size(s)); j\u0026gt;=1; j--) { if (b.substr(1, j) == s.substr(size(s)-j)) { nxt[i][x]=j; break; } } } } auto ckmin=[](auto\u0026amp; a, auto b) { if (b\u0026lt;a) a=b; }; for (int i=0; i\u0026lt;=n; i++) for (int j=0; j\u0026lt;=n; j++) for (int k=0; k\u0026lt;=m; k++) dp[i][j][k]=20000; dp[0][0][0]=0; for (int i=0; i\u0026lt;n; i++) for (int j=0; j\u0026lt;=n; j++) for (int k=0; k\u0026lt;=m; k++) for (int x : {0, 1}) ckmin(dp[i+1][j+(nxt[k][x]==m)][nxt[k][x]], dp[i][j][k]+(a[i+1]!=\u0026#39;0\u0026#39;+x)); for (int i=0; i\u0026lt;=n-m+1; i++) { auto ans=*min_element(dp[n][i], dp[n][i]+m+1); cout \u0026lt;\u0026lt; (ans==20000 ? -1 : ans) \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n-m+1]; } } ","date":1634097019,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1634097019,"objectID":"a66aeeb06f82bb7737aae7fdb2d4eefa","permalink":"https://tgc54.com/zh/post/cf1575h/","publishdate":"2021-10-12T21:50:19-06:00","relpermalink":"/zh/post/cf1575h/","section":"post","summary":"","tags":["åŠ¨æ€è§„åˆ’"],"title":"COMPFEST 13 - Finals H. Holiday Wall Ornaments é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜ç›®é“¾æ¥\né¢˜è§£ é¦–å…ˆï¼Œä»¥ä¸‹ä¸¤ç‚¹ä¸éš¾æƒ³åˆ°ï¼š\næˆ‘ä»¬åªä¼šåœ¨æœ€å¤§ç”Ÿæˆæ ‘çš„è¾¹ä¸Šèµ°ï¼Œè¿™æ ·æˆ‘ä»¬å°±æŠŠå›¾å˜æˆäº†æ ‘ã€‚ å¯¹äºæ‰€æœ‰è¾¹ï¼Œæœ€ä¼˜ç­–ç•¥æ°¸è¿œæ˜¯å…ˆåƒæ ‘ä¸Šä¸€è¾¹çš„æ‰€æœ‰ç‚¹ç„¶åå†åƒå¦ä¸€è¾¹ã€‚ ç”±äºå®½åº¦å°çš„è¾¹ä¼šæœ€å…ˆä¸æ»¡è¶³æ¡ä»¶ï¼Œå› æ­¤è¦ä¼˜å…ˆè€ƒè™‘å®½åº¦å°çš„è¾¹ï¼Œä½†è¾¹ä¸¤ä¾§çš„è¿é€šå—çš„æƒ…å†µè¿˜ä¸çŸ¥é“ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å…ˆç»§ç»­å¤„ç†ä¸¤ä¾§çš„ä¿¡æ¯å†ç¡®å®šåƒçš„æ–¹å‘ï¼Œè€Œæ¯ä¾§çš„è¿é€šå—ä¸­æœ€çª„çš„è¾¹åˆä¼šæŠŠè¿é€šå—ä¸€åˆ†ä¸ºäºŒâ€¦â€¦è¿™æ ·ä¸€ç›´é€’å½’ä¸‹å»ç›´åˆ°æ¯ä¸ªè¿é€šå—åªå‰©ä¸€ä¸ªç‚¹ã€‚åˆå¹¶çš„é¡ºåºå°±æ˜¯ä»å®½è¾¹åˆ°çª„è¾¹ï¼Œè¿™æ­£å¥½ä¹Ÿæ˜¯æ±‚æœ€å¤§ç”Ÿæˆæ ‘çš„é¡ºåºï¼Œäºæ˜¯å¯ä»¥åœ¨æ±‚æœ€å¤§ç”Ÿæˆæ ‘çš„åŒæ—¶ç»´æŠ¤ç­”æ¡ˆã€‚å¯¹äºæ¯ä¸ªè¿é€šå—ï¼Œæˆ‘ä»¬ç»´æŠ¤è¿›å…¥è¿™ä¸ªè¿é€šå—æ—¶äººçš„æœ€å¤§å®½åº¦$mx$ã€‚å‡è®¾å¾…åˆå¹¶çš„ä¸¤ä¸ªè¿é€šå—ä¸º$u,v$ï¼Œæ¯ä¸ªå—çš„$c$å€¼çš„å’Œä¸º$sum_u, sum_v$ï¼Œ$u,v$ä¹‹é—´çš„è¾¹çš„å®½åº¦ä¸º$w$ï¼Œä»$u$åˆ°$v$è¦æ»¡è¶³$mx_u+sum_u\\le mx_v$å’Œ$mx_u+sum_u\\le w$ï¼Œå˜å½¢ä¸€ä¸‹å°±æ˜¯$mx_u=\\min(mx_v, w)-sum_u$ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœå…ˆåƒ$u$å†åƒ $v$çš„è¯ï¼Œè¿›å…¥åˆå¹¶ä¹‹åçš„è¿é€šå—æ—¶æœ€å¤§çš„å®½åº¦ä¸º $\\min(mx_v, w)-sum_u$ï¼Œå…ˆåƒ$v$å†åƒ$u$çš„æƒ…å†µç±»ä¼¼ï¼Œå–ä¸¤ç§æƒ…å†µä¸­å®½åº¦æ›´å¤§çš„æƒ…å†µã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(), (x).end() using ll = long long; constexpr ll INF = 1e18; struct UF { vector\u0026lt;int\u0026gt; fa, sz; vector\u0026lt;ll\u0026gt; mx, sum; UF(int n) : fa(n), sz(n, 1), mx(n, INF), sum(n) { iota(all(fa), 0); } int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } void join(int u, int v, ll w) { u = find(u), v = find(v); if (u == v) return; if (sz[u] \u0026gt; sz[v]) swap(u, v); ll fromV = -INF, fromU = -INF; if (sum[v] \u0026lt;= mx[u]) fromV = min(mx[u], w) - sum[v]; if (sum[u] \u0026lt;= mx[v]) fromU = min(mx[v], w) - sum[u]; mx[v] = max(fromU, fromV); sum[v] += sum[u]; fa[u] = v; sz[v] += sz[u]; return; } auto check() { return mx[find(0)]; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; edges(m); UF uf(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; uf.sum[i]; for (auto \u0026amp;[u, v, c] : edges) cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c, u--, v--; sort(begin(edges), end(edges), [\u0026amp;](auto\u0026amp; i, auto\u0026amp; j) { return i[2] \u0026gt; j[2]; }); for (auto \u0026amp;[u, v, c] : edges) uf.join(u, v, c); if (auto mx = uf.check(); mx \u0026lt; 1) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl; } ","date":1633138328,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1633138328,"objectID":"03ab5468a0ee3fd70c3dcc939c360987","permalink":"https://tgc54.com/zh/post/icpc-wf-2020-invitational-l/","publishdate":"2021-10-01T19:32:08-06:00","relpermalink":"/zh/post/icpc-wf-2020-invitational-l/","section":"post","summary":"","tags":["å›¾è®º","æœ€å¤§ç”Ÿæˆæ ‘","è´ªå¿ƒ"],"title":"ICPC WF Moscow Invitational Contest L - Labyrinth é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å‰ç½®çŸ¥è¯†ï¼šéœå°”å®šç†ï¼ˆHallâ€™s Theorem) ä¹Ÿå«éœå°”ç»“å©šå®šç†(Hallâ€™s marriage theorem)ã€‚åœ¨äºŒåˆ†å›¾ä¸­ï¼Œä»¤ä¸¤éƒ¨åˆ†ç‚¹é›†åˆ†åˆ«ä¸º$X, Y$, åˆ™å­˜åœ¨$X-$å®Œç¾åŒ¹é…ï¼ˆ$X$ä¸­çš„ç‚¹é›†å…¨éƒ¨è¢«åŒ¹é…ï¼‰çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯:å¯¹äº$X$çš„ä»»æ„å­é›†$W$,$|W|\\le|\\Gamma(W)|$ï¼Œå…¶ä¸­$\\Gamma(W)$ä¸ºä¸$W$ç›´æ¥ç›¸è¿çš„ç‚¹çš„é›†åˆã€‚\né¢˜è§£ æœ¬é¢˜æ˜¯è®©æˆ‘ä»¬æ±‚æœ€å¤§åŒ¹é…æ•°ï¼Œä½†ç›´æ¥è·‘åŒ¹é…ç®—æ³•è‚¯å®šä¸åˆé€‚ï¼Œæ­¤æ—¶æˆ‘ä»¬è€ƒè™‘éœå°”å®šç†ï¼šå‡è®¾æ‰€æœ‰äººçš„é›†åˆä¸º$X$,æˆ‘ä»¬è‡³å°‘è¿˜éœ€è¦$\\max_{W\\subseteq X}|W|-|\\Gamma(W)|$ã€‚ä½†æ˜¯$X$çš„å­é›†çš„ä¸ªæ•°æ˜¯æŒ‡æ•°çº§çš„æ‰€ä»¥ä¸èƒ½ç›´æ¥è€ƒè™‘å­é›†ã€‚\nä½†æ˜¯æˆ‘ä»¬å‘ç°$\\Gamma(X)$æ€»æ˜¯æ‰€æœ‰æ¤…å­çš„ä¸€ä¸ªå‰ç¼€åŠ ä¸€ä¸ªåç¼€ï¼Œä¹Ÿå°±æ˜¯$\\{i|i\\le l\\lor i\\ge r, l\u0026lt;r\\}$ã€‚äºæ˜¯æˆ‘ä»¬å¯ä»¥è€ƒè™‘æšä¸¾$l, r$ï¼Œé‚£ä¹ˆæ¤…å­çš„é›†åˆæ‰€å¯¹åº”çš„äººçš„é›†åˆ$W$ä¸º$\\{i|l_i\\le l\\land r_i\\ge r\\}$,æ­¤æ—¶$|W|-|\\Gamma(W)|=|W| -(l+m-r+1)$ã€‚ä½†å¾ˆæ˜¾ç„¶$(l, r)$çš„ä¸ªæ•°æ˜¯$O(N^2)$çš„ï¼Œè¿˜æ˜¯å¤ªæ…¢ï¼Œä¸è¿‡è¿™å·²ç»æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„è¿›æ­¥äº†ã€‚\næˆ‘ä»¬å†æƒ³è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œä»å°åˆ°å¤§æšä¸¾$l$ï¼Œé€šè¿‡æŸäº›æ•°æ®ç»“æ„ç›´æ¥æ±‚å¾—æ‰€æœ‰$r$ä¸­çš„æœ€å¤§å€¼ï¼šæˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘ç»´æŠ¤å¯¹äºæ¯ä¸€ä¸ª$r$,$|W|-(m-r+1)$çš„æœ€å¤§å€¼ã€‚å¯¹äºæ¯ä¸€ä¸ªäººçš„é™åˆ¶æ¡ä»¶$L_i, R_i$ï¼Œå½“æˆ‘ä»¬æšä¸¾åˆ°$l\\ge L_i$æ—¶ï¼Œå¦‚æœé€‰æ‹©çš„$r\\le R_i$çš„è¯ï¼Œé‚£ä¹ˆå¯¹åº”çš„äººçš„é›†åˆå°±ä¼šåŒ…å«$i$ï¼Œåæ˜ åˆ°ç»´æŠ¤çš„å€¼ä¸Šå»çš„è¯å°±æ˜¯æŠŠåŒºé—´$[l+1, R_i]$é‡Œçš„å€¼+1ã€‚ç„¶åç”¨$[l+1, m+1]$ä¸­çš„æœ€å¤§å€¼å‡å½“å‰çš„$l$æ¥æ›´æ–°ç­”æ¡ˆã€‚\næ³¨æ„å‡ ç‚¹ï¼š\næŒ‰lä»å°åˆ°å¤§çš„é¡ºåºå¯ä»¥ä¿è¯å‰é¢çš„$L_i$éƒ½æ˜¯ç¬¦åˆæ¡ä»¶çš„ï¼Œåªè¦è€ƒè™‘$r$çš„å–å€¼å³å¯ã€‚ ç»´æŠ¤çš„å€¼æ˜¯æŠŠ$l$é™¤å»çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªè€ƒè™‘ $r$çš„å–å€¼ã€‚ æ¯ä¸ªä½ç½®çš„$m-r+1$éƒ½æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥å»ºæ ‘çš„æ—¶å€™å°±å¯ä»¥åŠ è¿›å»ã€‚ ç‰¹æ®Šæƒ…å†µå½“$\\Gamma(X)$ä¸ºæ•´ä¸ªæ¤…å­çš„é›†åˆæ—¶ï¼Œ$|X|-\\Gamma(X)=n-m$ ä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; struct SegTree { int n, M; vector\u0026lt;T\u0026gt; t; SegTree(int n_, int _m) : n(n_), M(_m), t(4 * n) { build(1, 0, n - 1); } void pull(int node) { t[node] = t[node * 2] + t[node * 2 + 1]; } void build(int node, int l, int r) { if (l == r) { return t[node].apply(l, r, -M + r - 1); } int mid = (l + r) / 2; build(node * 2, l, mid); build(node * 2 + 1, mid + 1, r); pull(node); } void push(int p, int l, int r) { if (t[p].lazy) { int m = (l + r) / 2; t[p * 2].apply(l, m, t[p].lazy); t[p * 2 + 1].apply(m + 1, r, t[p].lazy); t[p].lazy = 0; } } void add(int node, int ql, int qr, int l, int r, int x) { if (r \u0026lt; ql || l \u0026gt; qr) return; if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node].apply(l, r, x); push(node, l, r); int mid = (l + r) / 2; add(node * 2, ql, qr, l, mid, x); add(node * 2 + 1, ql, qr, mid + 1, r, x); pull(node); } T get(int node, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node]; push(node, l, r); int mid = (l + r) / 2; if (qr \u0026lt;= mid) return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid); if (ql \u0026gt; mid) return get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid) + get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); } // wrapper void add(int l, int r, int x) { assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); add(1, l, r, 0, n - 1, x); } T get(int l, int r) { assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); return get(1, l, r, 0, n - 1); } }; struct node { int v = 0; // don\u0026#39;t forget to set default value (used for leaves), // not necessarily zero element int lazy = 0; void apply(int l, int r, int x) { lazy += x; v += x; } node operator+(const node \u0026amp;b) const { node res; res.v = max(v, b.v); return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; const int M = 200000; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; rs(M + 1); for (int i = 0; i \u0026lt; n; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; rs[l].push_back(r); } SegTree\u0026lt;node\u0026gt; tr(m + 2, m); int ans = n - m; for (int l = 0; l \u0026lt;= M \u0026amp;\u0026amp; l \u0026lt;= m - 1; l++) { for (auto r : rs[l]) { tr.add(l + 1, r, 1); } ans = max(ans, tr.get(l + 1, m + 1).v - l); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":1627489409,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1627489409,"objectID":"12df111c64d6ede710e96765c351e2d4","permalink":"https://tgc54.com/zh/post/arc076d/","publishdate":"2021-07-28T13:23:29-03:00","relpermalink":"/zh/post/arc076d/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„","çº¿æ®µæ ‘"],"title":"AtCoder Regular Contest (ARC) 076F - Exhausted? é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜ç›®é“¾æ¥\né¦–å…ˆæˆ‘ä»¬è¦çŸ¥é“å¯¹äºå›ºå®šçš„æ•°ç»„å¦‚ä½•æ±‚éå†è½®æ•°ï¼š åˆ›å»ºä¸€ä¸ªå¤åˆ¶æ•°ç»„bï¼Œå…¶ä¸­b[i]={a[i], i}ï¼Œç„¶åæ’åºbï¼Œæ’åºåb[i].second-içš„æœ€å¤§å€¼å°±æ˜¯ç­”æ¡ˆï¼Œb[i].second-iæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªæ•°å‘å‰ç§»åŠ¨çš„è·ç¦»ï¼Œä¸éš¾æƒ³å‡ºæ¯ä¸ªä¼šå‘å‰ç§»åŠ¨çš„æ•°ä»ç¬¬ä¸€è½®éå†å°±ä¼šå¼€å§‹å‘å‰ç§»åŠ¨ï¼Œç›´åˆ°åˆ°è¾¾æ’åºåçš„ä½ç½®ï¼Œæ‰€ä»¥æœ€å¤§çš„å‘å‰ç§»åŠ¨è·ç¦»å°±æ˜¯éå†çš„è½®æ•°ã€‚\nç°åœ¨è€ƒè™‘ä¿®æ”¹åŸæ•°ç»„åï¼Œæ•°ç»„bä»¥åŠb[i].second-içš„å€¼ä¼šæœ‰ä»€ä¹ˆæ”¹å˜ï¼Œä¸éš¾å‘ç°å…¶å®å°±æ˜¯åˆ æ‰äº†{a[x], x}ï¼Œç„¶åå†æ’å…¥{v, x}ï¼ˆxä¸vçš„å«ä¹‰ä¸é¢˜ç›®ç›¸åŒï¼‰ï¼Œbæ•°ç»„ä¸­åœ¨è€ä½ç½®ä¸æ–°ä½ç½®ä¸­é—´çš„å…ƒç´ ä¼šç§»åŠ¨ä¸€ä½ï¼Œæ‰€ä»¥ä»–ä»¬çš„b[i].second-iä¼š+1æˆ–è€…-1ï¼ˆç”±æ–°è€ä½ç½®çš„å…³ç³»è€Œå®šï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥æ’å…¥åˆ é™¤åˆèƒ½åŒºé—´åŠ çš„æ•°æ®ç»“æ„ï¼Œå¹¶ä¸”æ”¯æŒæŸ¥è¯¢å…¨å±€æœ€å¤§å€¼ï¼Œé‚£åªèƒ½æ˜¯å¹³è¡¡æ ‘äº†ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; auto seed=chrono::high_resolution_clock::now().time_since_epoch().count(); mt19937 gen(seed); template \u0026lt;typename T\u0026gt; struct Treap { struct node { int ch[2], sz; unsigned k; pair\u0026lt;int, int\u0026gt; d; T mx, lazy, dif; node(pair\u0026lt;int, int\u0026gt; d_, int dd, int z = 1) : sz(z), k((unsigned)gen()), d(d_), mx(dd), lazy(), dif(dd) { ch[0] = ch[1] = 0; } }; vector\u0026lt;node\u0026gt; nodes; int root=0, recyc=0; Treap(int size = 2e5) { nodes.reserve(size); nodes.emplace_back(pair{0, 0}, -1e9, 0); } inline int \u0026amp;ch(int rt, int r) { return nodes[rt].ch[r]; } int new_node(const pair\u0026lt;int, int\u0026gt; \u0026amp;d, int dd) { nodes.emplace_back(d, dd); return nodes.size()-1; } int pull(int rt) { node \u0026amp;n = nodes[rt]; n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz; n.mx = max({n.dif, nodes[n.ch[0]].mx, nodes[n.ch[1]].mx}); return rt; } void add(int rt, const T \u0026amp;d) { node \u0026amp;n = nodes[rt]; n.lazy += d; n.mx += d; n.dif+=d; } void pushdown(int rt) { node \u0026amp;n = nodes[rt]; if (n.lazy) { add(n.ch[0], n.lazy); add(n.ch[1], n.lazy); n.lazy = T(); } } int merge(int tl, int tr) { if (!tl) return tr; if (!tr) return tl; if (nodes[tl].k \u0026lt; nodes[tr].k) { pushdown(tl); ch(tl, 1) = merge(ch(tl, 1), tr); return pull(tl); } else { pushdown(tr); ch(tr, 0) = merge(tl, ch(tr, 0)); return pull(tr); } } void split(int rt, pair\u0026lt;int, int\u0026gt; k, int \u0026amp;x, int \u0026amp;y) { // split out element less than or equal to k if (!rt) { x = y = 0; return; } pushdown(rt); if (k \u0026lt; nodes[rt].d) { y = rt; split(ch(rt, 0), k, x, ch(rt, 0)); } else { x = rt; split(ch(rt, 1), k, ch(rt, 1), y); } pull(rt); } // interface void insert(pair\u0026lt;int, int\u0026gt; v, int d) { int rt = new_node(v, d); root = merge(root, rt); } void move_right(int old, int ne, int idx) { int a, b, c, d; split(root, {ne, idx}, c, d); split(c, {old, idx}, b, c); split(b, {old, idx-1}, a, b); if (c) add(c, 1); nodes[b]=node({ne, idx}, idx-(nodes[a].sz+nodes[c].sz)); root = merge(merge(merge(a, c), b), d); } void move_left(int old, int ne, int idx) { int a, b, c, d; split(root, {old, idx}, c, d); split(c, {old, idx-1}, b, c); split(b, {ne, idx}, a, b); if (b) add(b, -1); nodes[c]=node({ne, idx}, idx-(nodes[a].sz)); root=merge(merge(merge(a, c), b), d); } int query() { return nodes[root].mx; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;int\u0026gt; a(n); for (auto\u0026amp; x : a) cin\u0026gt;\u0026gt;x; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; b(n); for (int i=0; i\u0026lt;n; i++) { b[i]={a[i], i}; } sort(b.begin(), b.end()); Treap\u0026lt;int\u0026gt; tr; for (int i=0; i\u0026lt;n; i++) { tr.insert(b[i], b[i].second-i); } while (q--) { int x, v; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; if (a[x]\u0026lt;v) { // move right tr.move_right(a[x], v, x); } else { // move left tr.move_left(a[x], v, x); } a[x]=v; cout\u0026lt;\u0026lt;tr.query()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } ","date":1627173695,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1627173695,"objectID":"bb207ae2f8fad2d023af71519ea3a02a","permalink":"https://tgc54.com/zh/post/joioc18-bubblesort2/","publishdate":"2021-07-24T21:41:35-03:00","relpermalink":"/zh/post/joioc18-bubblesort2/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„","å¹³è¡¡æ ‘","treap"],"title":"JOI '18 Open P1 - Bubble Sort 2 é¢˜è§£","type":"post"},{"authors":null,"categories":["æ•™ç¨‹"],"content":"rimeè¾“å…¥æ³•æ¡†æ¶é…ç½®ç è¡¨è¾“å…¥æ³•çš„ç®€å•æ•™ç¨‹ï¼Œä»¥windowsä¸Šå°é¹¤éŸ³å½¢ä¸ºä¾‹ã€‚\næœ€è¿‘ç”±äºwaylandæœ‰ç‚¹å—ä¸äº†äº†ï¼Œå†³å®šæ¢æˆwindows+wslè¯•è¯•ï¼Œè™½è¯´windowsä¸Šæœ‰ç°æˆçš„å°é¹¤éŸ³å½¢ï¼Œä½†ç›¸ä¿¡å¤§å¤šæ•°ç è¡¨ç”¨æˆ·å’Œæˆ‘ä¸€æ ·åœ¨æ ‡å‡†è¯åº“ä¸Šæœ‰æ‰€åˆ å‡ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªè¾“å…¥æ³•æ¡†æ¶ã€‚ç”¨linuxçš„æ—¶å€™ä¹…é—»rimeä¹‹å¤§åï¼Œä½†å¹¶æ²¡æœ‰æ‰¾åˆ°å¾ˆå¥½é…ç½®ç è¡¨çš„æ•™ç¨‹ï¼Œè€Œå®˜æ–¹æ–‡æ¡£æœ‰ç‚¹é•¿å†åŠ ä¸Šæ˜¯ç¹ä½“å†™çš„è¯»èµ·æ¥æœ‰ç‚¹è´¹äº‹ï¼Œé‚å†³å®šè®°å½•ä¸€ä¸‹è‡ªå·±é…ç½®çš„è¿‡ç¨‹ä¾›å¤§å®¶å‚è€ƒã€‚\nå…¶å®ç è¡¨é…ç½®èµ·æ¥å¾ˆç®€å•ï¼Œä¸€å…±åªéœ€è¦ä¸¤ä¸ªæ–‡ä»¶ï¼šåä¸º\u0026lt;name\u0026gt;.schema.yamlçš„æ–¹æ¡ˆå®šä¹‰æ–‡ä»¶å’Œåä¸º\u0026lt;name\u0026gt;.dict.yamlçš„ç è¡¨æ–‡ä»¶ã€‚æ–¹æ¡ˆå®šä¹‰æ–‡ä»¶ä¸€èˆ¬éƒ½æœ‰ç°æˆçš„ï¼Œæ¯”å¦‚å°é¹¤éŸ³å½¢çš„åœ¨è¿™(æŒ‚æ¥ç¬¬ä¸‰æ–¹å¹³å°é‡Œ)ã€‚ç è¡¨æ ¼å¼è¦æ±‚çœ‹è¿™ï¼Œå¦‚æœä½ åƒæˆ‘ä¸€æ ·ä¹‹å‰æ˜¯ç”¨fcitxæ ¼å¼çš„ç è¡¨ï¼Œå¯ä»¥å¾ˆç®€å•çš„ç”¨awk \u0026#39;{ OFS=\u0026#34;\\t\u0026#34;; print $2, $1 }\u0026#39; flypy_rime.txt \u0026gt; flypy.dict.yamlä¿®æ”¹æ ¼å¼ã€‚ç„¶åå°†ä¸¤ä¸ªæ–‡ä»¶æ”¾å…¥é»˜è®¤æ–‡ä»¶å¤¹ï¼ˆwindowsä¸Šé»˜è®¤ä¸º%APPDATA%\\Rimeï¼‰ï¼Œå¹¶ä¿®æ”¹build/default.yaml:åœ¨schema_listé‡ŒåŠ ä¸€è¡Œ- schema: flypyã€‚æœ€åå³é”®è¾“å…¥æ³•å›¾æ ‡ç‚¹â€œé‡æ–°éƒ¨ç½²â€å³å¯ã€‚\n","date":1626834697,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1626834697,"objectID":"944aaa4d580fe30d5c43d5c95a913bbe","permalink":"https://tgc54.com/zh/post/rime-flypy/","publishdate":"2021-07-20T23:31:37-03:00","relpermalink":"/zh/post/rime-flypy/","section":"post","summary":"rimeè¾“å…¥æ³•æ¡†æ¶é…ç½®ç è¡¨è¾“å…¥æ³•çš„ç®€å•æ•™ç¨‹ï¼Œä»¥windowsä¸Šå°é¹¤éŸ³å½¢ä¸ºä¾‹ã€‚\n","tags":["å°é¹¤éŸ³å½¢","rime","è¾“å…¥æ³•"],"title":"Rimeé…ç½®ç è¡¨è¾“å…¥æ³•ï¼ˆä»¥å°é¹¤éŸ³å½¢ä¸ºä¾‹ï¼‰","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ–¹æ³•ä¸€ ä¸€ç§ç®€å•çš„dpæ˜¯ä»¤$dp_{i, j}$ä¸ºå°†å‰$i$ä¸ªæ•°åˆ†æˆ$j$ä¸ªå­æ•°ç»„çš„åˆ†æ³•çš„ä¸ªæ•°ã€‚æ¬¡è½¬ç§»è¦éå†$i$å‰çš„æ¯ä¸ªä½ç½®$k$ç„¶åå‰ç¼€å‰ç¼€å’Œåˆ¤æ–­$sum_i-sum_k$æ˜¯å¦æ˜¯$j$çš„å€æ•°ï¼Œå¦‚æœæ˜¯çš„è¯å°±åŠ ä¸Š$dp_{k, j-1}$ï¼Œæ‰€ä»¥è½¬ç§»æ˜¯ $O(n)$çš„ï¼Œæ€»çš„å¤æ‚åº¦æ˜¯$O(n^3)$ï¼Œä¼šTLEï¼Œäºæ˜¯æˆ‘ä»¬æƒ³å¦‚ä½•ä¼˜åŒ–ã€‚è€ƒè™‘åˆ°$$((sum_i-sum_k) \\bmod j =0)\\iff (sum_i\\equiv sum_k \\mod j)$$ ä¹Ÿè®¸æˆ‘ä»¬ä¸ç”¨éå†æ‰€æœ‰çš„$k$ï¼Œåªè¦è®°å½•å¯¹äºæ¯ä¸ªä½ç½®$k$, $sum_k\\bmod i=j$çš„$dp_{k, i-1}$çš„å’Œå°±è¡Œäº†ã€‚äºæ˜¯æˆ‘ä»¬çš„çŠ¶æ€$dp_{i, j}$çš„å®šä¹‰å°±å˜æˆäº†åœ¨kä½ç½®ç»“æŸçš„å­æ•°ç»„,åˆ†æˆ$i$ä¸ªå­æ•°ç»„å¹¶ä¸”$sum_k\\bmod i=j$çš„åˆ†æ³•çš„ä¸ªæ•°ã€‚ï¼ˆè¯´å®è¯ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼‰\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt \u0026amp;x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt \u0026amp;x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt \u0026amp;x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt \u0026amp;x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt \u0026amp;operator+=(const ModInt \u0026amp;x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt \u0026amp;operator-=(const ModInt \u0026amp;x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt \u0026amp;operator*=(const ModInt \u0026amp;x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt \u0026amp;operator/=(const ModInt \u0026amp;x) { return *this *= x.inv(); } // compare bool operator==(const ModInt \u0026amp;b) const { return val == b.val; } bool operator!=(const ModInt \u0026amp;b) const { return val != b.val; } // I/O friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, ModInt \u0026amp;x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const ModInt \u0026amp;x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint = ModInt\u0026lt;int(1e9 + 7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n), sum(n + 1); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; sum[i + 1] = sum[i] + a[i]; } vector dp(n + 2, vector\u0026lt;mint\u0026gt;(n + 2)); dp[1][0] += 1; mint ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = n; j \u0026gt;= 1; j--) { dp[j + 1][sum[i + 1] % (j + 1)] += dp[j][sum[i + 1] % j]; if (i == n - 1) ans += dp[j][sum[n] % j]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } æ–¹æ³•äºŒ è¿™ç§æ–¹æ³•å’Œæ–¹æ³•ä¸€çš„å‡ºå‘ç‚¹ä¸€æ ·ï¼Œä½†è½¬ç§»çš„æ—¶å€™æˆ‘ä»¬åªè€ƒè™‘æœ€å¤§çš„k,è¿™æ˜¯å› ä¸ºä¸¤ä¸ªå’Œä¸º$j$çš„çš„å€æ•°çš„å­æ•°ç»„æ‹¼èµ·æ¥å’Œä¾ç„¶æ˜¯$j$çš„å€æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¿æŒä¸€å¼€å§‹çš„dpçŠ¶æ€å®šä¹‰ï¼Œç„¶åç”¨$O(n^2)$çš„æ—¶é—´é¢„å¤„ç†å‡º$pre_{i, j}$ï¼Œå³å¯¹äºæ¯ä¸ªä½ç½®$i$ï¼Œå…¶å·¦è¾¹ç¬¬ä¸€ä¸ªä½ç½®ä½¿å¾—$sum_{pre_{i, j}}\\equiv sum_{i}\\mod j$ï¼Œè½¬ç§»æ—¶è€ƒè™‘ä¸¤ç§æƒ…å†µï¼špreçš„ä½ç½®è¢«åˆ†æˆäº†$j$æˆ–$j-1$ä¸ªå­æ•°ç»„ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt \u0026amp;x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt \u0026amp;x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt \u0026amp;x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt \u0026amp;x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt \u0026amp;operator+=(const ModInt \u0026amp;x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt \u0026amp;operator-=(const ModInt \u0026amp;x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt \u0026amp;operator*=(const ModInt \u0026amp;x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt \u0026amp;operator/=(const ModInt \u0026amp;x) { return *this *= x.inv(); } // compare bool operator==(const ModInt \u0026amp;b) const { return val == b.val; } bool operator!=(const ModInt \u0026amp;b) const { return val != b.val; } // I/O friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, ModInt \u0026amp;x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const ModInt \u0026amp;x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint = ModInt\u0026lt;int(1e9 + 7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); for (auto \u0026amp;x : a) cin \u0026gt;\u0026gt; x; vector pre(n, vector(n + 1, -1)); vector last(n + 1, vector(n, -1)); ll sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += a[i]; for (int j = 1; j \u0026lt;= n; j++) { pre[i][j] = last[j][sum % j]; last[j][sum % j] = i; } } vector dp(n, vector\u0026lt;mint\u0026gt;(n + 1)); dp[0][1] = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= n; j++) { int p = pre[i][j]; if (p != -1) { dp[i][j] = dp[p][j] + dp[p][j - 1]; } } } cout \u0026lt;\u0026lt; accumulate(dp[n - 1].begin(), dp[n - 1].end(), mint()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":1625756675,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1625756675,"objectID":"9b197b44712a522d973d769bf1098b00","permalink":"https://tgc54.com/zh/post/abc207e/","publishdate":"2021-07-08T11:04:35-04:00","relpermalink":"/zh/post/abc207e/","section":"post","summary":"","tags":["åŠ¨æ€è§„åˆ’"],"title":"AtCoder Beginner Contest(ABC) 207E - Mod ié¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"Tarjançš„è®ºæ–‡ä¸­æŒ‡å‡º\nLOWLINK(v) is the smallest vertex which is in the same component as v and is reachable by traversing zero or more tree arcs followed by at most one [back edge] or [cross edge].\nä¹Ÿå°±æ˜¯è¯´uçš„lowlinkæ˜¯åœ¨dfsæ ‘ä¸­uçš„å­æ ‘ä¸­çš„èŠ‚ç‚¹ç»è¿‡æœ€å¤šä¸€æ¡è¿”ç¥–è¾¹ï¼ˆback edge,ä¹Ÿå«åå‘è¾¹ï¼‰èƒ½åˆ°è¾¾æœ€ä½çš„dfsåºã€‚æ‰€ä»¥åœ¨dfsçš„æ—¶å€™å¯¹äºå·²è®¿é—®å’Œæœªè®¿é—®çš„èŠ‚ç‚¹è¦ç”¨ä¸åŒçš„æ›´æ–°ï¼šå¯¹äºæœªè®¿é—®çš„èŠ‚ç‚¹væˆ‘ä»¬ç”¨low[u]=min(low[u], low[v])ï¼Œå¯¹äºè®¿é—®è¿‡çš„èŠ‚vç‚¹ç”¨low[u]=min(low[u], order[v])ã€‚ä½†è¿™æ ·ä¹Ÿè®¸æœ‰ä¸€ç‚¹éº»çƒ¦ï¼Œå¢åŠ äº†è®°å¿†éš¾åº¦ï¼Œä¸€ä¸å°å¿ƒä¹Ÿå¯èƒ½å†™é”™ã€‚\nå¦‚æœæˆ‘ä»¬ç¨å¾®ä¿®æ”¹ä¸€ä¸‹å®šä¹‰ï¼Œå¿½ç•¥è¿”ç¥–è¾¹çš„æ•°é‡é™åˆ¶ï¼Œå¾—åˆ°çš„ç®—æ³•ä¾ç„¶æ˜¯å¯¹çš„ï¼å› ä¸ºæˆ‘ä»¬åªå…³å¿ƒlowlinkæ˜¯å¦æ˜¯uçš„ç¥–å…ˆï¼Œè‡³äºå“ªä¸ªç¥–å…ˆæ— æ‰€è°“ã€‚æ‰€ä»¥è¿™ç§å®šä¹‰åœ¨ä¿è¯æ­£ç¡®æ€§çš„åŒæ—¶ç®€åŒ–äº†ä»£ç ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ã€‚ä»£ç è§æ­¤\n","date":1625544250,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1625544250,"objectID":"343e13ef4bfb9463c170b1f06b06ed0d","permalink":"https://tgc54.com/zh/post/tarjan-lowlink/","publishdate":"2021-07-06T00:04:10-04:00","relpermalink":"/zh/post/tarjan-lowlink/","section":"post","summary":"","tags":["å¼ºè¿é€šåˆ†é‡","å‰²ç‚¹","æ¡¥"],"title":"å…³äºTarjanç®—æ³•ä¸­çš„low linkçš„å¦ç±»å®šä¹‰ä¸æ›´æ–°","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ³¨ï¼šä¸‹æ–‡çš„regular bracket sequence ç®€å†™ä¸ºRBS\né¦–å…ˆå¯¹äºæ¯ä¸ªå³æ‹¬å·ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸å…¶é…å¯¹çš„å·¦æ‹¬å·ï¼ˆä¹Ÿå°±æ˜¯è¯¥å³æ‹¬å·å¾€å·¦æœ€çŸ­çš„RBSï¼‰çš„ä½ç½®$l$ï¼ˆå¦‚æœæ²¡æœ‰é…å¯¹çš„å°±æ˜¯-1ï¼‰ï¼Œæ¯”å¦‚æ ·ä¾‹å¯¹åº”çš„ä½ç½®å°±æ˜¯\nä¸‹æ ‡ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 æ‹¬å· ) ( ( ( ) ) ) ) ( ( ) ( ) ) $l$ -1 3 2 1 -1 9 11 8 $l$æ•°ç»„å¯ä»¥å¾ˆå®¹æ˜“çš„ç”¨ä¸€ä¸ªæ ˆæ±‚å¾—ã€‚\né‚£ä¹ˆå¦‚ä½•æ±‚æœ€é•¿çš„RBSå‘¢ï¼Ÿå¦‚æœä¸¤ä¸ªRBSç›¸é‚»çš„è¯æˆ‘ä»¬å¯ä»¥å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ›´é•¿çš„RBSï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥å†éå†ä¸€é$l$æ•°ç»„å¹¶å°è¯•æ‰©å±•RBSçš„é•¿åº¦ï¼Œæˆ‘ä»¬ä¾¿å¾—åˆ°äº†ä»¥$i$ç»“å°¾çš„æœ€é•¿çš„RBSï¼Œç›¸åº”åœ°æ›´æ–°ç­”æ¡ˆå³å¯ã€‚æ›´æ–°å®Œä¹‹åçš„$l$æ•°ç»„å¦‚ä¸‹ï¼š(å¥½å§å…¶å®æ²¡ä»€ä¹ˆå˜åŒ–)\nä¸‹æ ‡ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 æ‹¬å· ) ( ( ( ) ) ) ) ( ( ) ( ) ) $l$ -1 3 2 1 -1 9 9 8 å®Œæ•´ä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; int n = (int)s.size(); vector\u0026lt;int\u0026gt; l(n, -1); vector\u0026lt;int\u0026gt; stk; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;(\u0026#39;) stk.push_back(i); // å¦‚æœæ˜¯å·¦æ‹¬å·å°±å…¥æ ˆ else if (!stk.empty()) { // å¦åˆ™å°±æ˜¯å³æ‹¬å·ï¼Œå¦‚æœæ ˆéç©ºå°±è¯´æ˜æœ‰å¯¹åº”çš„å·¦æ‹¬å· l[i] = stk.back(); stk.pop_back(); } } for (int i = 0; i \u0026lt; n; i++) { //å¦‚æœå½“å‰RBSå·¦è¾¹ä¹Ÿæœ‰ä¸€ä¸ªRBSå°±æ›´æ–°å·¦ç«¯ç‚¹ if (l[i] \u0026gt; 0 \u0026amp;\u0026amp; l[l[i] - 1] != -1) l[i] = l[l[i] - 1]; } int ans = 0, cnt = 1; for (int i = 0; i \u0026lt; n; i++) { if (l[i] == -1) continue; int len = i - l[i] + 1; if (len \u0026gt; ans) { ans = len; cnt = 1; } else if (len == ans) cnt++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":1625157699,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1625157699,"objectID":"e092f8eb191c6fb592541c29a82a70a7","permalink":"https://tgc54.com/zh/post/cf5c/","publishdate":"2021-07-01T12:41:39-04:00","relpermalink":"/zh/post/cf5c/","section":"post","summary":"","tags":["dp"],"title":"CodeForces 5C - Longest Regular Bracket Sequence é¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"ä¸åŒ…æ‹¬ç›¸åŒå­ä¸² åç¼€è‡ªåŠ¨æœºä¸­æ¯ä¸€ä¸ªè·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªå­ä¸²ï¼Œæ‰€ä»¥ç¬¬kå°å­ä¸²å°±å¯¹åº”ç¬¬kå°è·¯å¾„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆè®¡ç®—ä»æ¯ä¸ªçŠ¶æ€å¼€å§‹æœ‰å¤šå°‘æ¡è·¯å¾„ï¼Œç„¶åå†æ ¹æ®kåˆ¤æ–­èµ°å“ªæ¡è·¯å¾„ã€‚è®¡ç®—è·¯å¾„çš„æ–¹æ³•å¦‚ä¸‹ï¼š $$path_u=1+\\sum_{v\\in next}path_v$$\nåŒ…æ‹¬ç›¸åŒå­ä¸² ç”±äºæ ‡å‡†çš„åç¼€è‡ªåŠ¨æœºé‡Œæ˜¯ä½“ç°ä¸å‡ºé‡å¤è·¯å¾„çš„ä¿¡æ¯çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦åœ¨ä¸Šé—®çš„åŸºç¡€ä¸Šç»´æŠ¤æ¯ä¸ªçŠ¶æ€ä»£è¡¨çš„å­ä¸²ä»¬å‡ºç°çš„æ¬¡æ•°$occur$:\n$$occur_u=\\sum_{v\\in next}occur_v$$\nå¦‚ä½•ç†è§£ï¼Ÿå½“å‰çŠ¶æ€çš„å­ä¸²ä»¬éƒ½æ˜¯ä¸‹ä¸€ä¸ªçŠ¶æ€å­ä¸²ä»¬çš„å‰ç¼€ï¼Œæ‰€ä»¥ä¸‹ä¸€ä¸ªçŠ¶æ€çš„å‡ºç°æ¬¡æ•°åº”å½“åŠ åˆ°å½“å‰çŠ¶æ€ä¸Šã€‚ç‰¹åˆ«çš„ï¼Œå¦‚æœå½“å‰çŠ¶æ€æ˜¯ç»ˆæ­¢çŠ¶æ€ï¼Œå®ƒçš„å‡ºç°æ¬¡æ•°åº”ä¸º1ã€‚\nè·¯å¾„æ•°çš„è®¡ç®—ä¸å‰é¢ç±»ä¼¼ï¼š $$path_u=occur_u+\\sum_{v\\in next}path_v$$\nä¾‹é¢˜ï¼š[TJOI2015]å¼¦è®º\nä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int t; struct SAM { struct state { int len = 0, link = -1; unordered_map\u0026lt;char, int\u0026gt; next; bool is_term; ll occur = 0, path_cnt=0; }; // the index of the equivalence class of the whole string int last = 0; vector\u0026lt;state\u0026gt; st; void extend(char c) { int cur = (int)st.size(); st.emplace_back(); st[cur].len = st[last].len + 1; int p = last; while (p != -1 \u0026amp;\u0026amp; !st[p].next.count(c)) { st[p].next[c] = cur; p = st[p].link; } if (p == -1) st[cur].link = 0; else { int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) { st[cur].link = q; } else { int clone = (int)st.size(); st.push_back(st[q]); st[clone].len = st[p].len + 1; while (p != -1 \u0026amp;\u0026amp; st[p].next[c] == q) { st[p].next[c] = clone; p = st[p].link; } st[q].link = st[cur].link = clone; } } last = cur; } SAM() { st.emplace_back(); } SAM(const string \u0026amp;s) : SAM() { for (auto c : s) extend(c); int p = last; while (p != 0) { st[p].is_term = true; p = st[p].link; } } void dfs(int i) { if (st[i].occur) return; if (st[i].is_term) st[i].occur++; for (auto [_, v] : st[i].next) { dfs(v); st[i].occur += st[v].occur; st[i].path_cnt += st[v].path_cnt; } st[i].path_cnt += t ? st[i].occur : 1; } string query(ll k) { string ans; int cur = 0; while (k \u0026gt; 0) { for (char c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) { if (!st[cur].next.count(c)) continue; auto \u0026amp;nxt = st[st[cur].next[c]]; if (nxt.path_cnt \u0026lt; k) k -= nxt.path_cnt; else { ans += c; cur = st[cur].next[c]; k -= t ? st[cur].occur : 1; break; } } } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; k; int len = (int)s.size(); SAM sa(s); sa.dfs(0); if (sa.st[0].path_cnt\u0026lt;k) cout\u0026lt;\u0026lt; -1 \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; sa.query(k); return 0; } ","date":1625150624,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1625150624,"objectID":"80e73cf33af316586edb55b0cb364c5f","permalink":"https://tgc54.com/zh/post/k-th-smallest-substring/","publishdate":"2021-07-01T10:43:44-04:00","relpermalink":"/zh/post/k-th-smallest-substring/","section":"post","summary":"","tags":["åç¼€è‡ªåŠ¨æœº"],"title":"åç¼€è‡ªåŠ¨æœºåº”ç”¨ä¹‹æ±‚å­—å…¸åºç¬¬kå°å­ä¸²ï¼ˆåŒ…æ‹¬ä¸ä¸åŒ…æ‹¬ç›¸åŒå­ä¸²ï¼‰","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°","é¢˜è§£"],"content":"ä¾‹é¢˜ï¼š Another Substring Query Problem\nç”±äºæ¬¡é¢˜ä¸­æ¨¡å¼ä¸²æœ‰é‡å¤ï¼Œä¼šå½±å“æ—¶é—´å¤æ‚åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æå‰å¤„ç†ç›¸åŒçš„å­—ç¬¦ä¸²ã€‚ä¸‹é¢çš„æ–¹æ³•å‡å‡è®¾æ— é‡å¤æ¨¡å¼ä¸²ã€‚å¹¶ä»¥$n$ä¸ºæ¨¡å¼ä¸²çš„æ€»é•¿åº¦ï¼Œ$m$ä¸ºæ–‡æœ¬ä¸²çš„é•¿åº¦ã€‚\næ–¹æ³•ä¸€ï¼šå­—ç¬¦ä¸²å“ˆå¸Œ ç”±äºæ€»é•¿ä¸º$n$çš„æ¨¡å¼ä¸²æœ€å¤šåªæœ‰$O(\\sqrt{n})$ç§é•¿åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥éå†æ¯ç§é•¿åº¦$l$ç„¶åéå†æ¯ä¸ªä½ç½®$i$ç„¶ååˆ¤æ–­ä»$i$å¼€å§‹é•¿åº¦ä¸º$l$çš„å­ä¸²æ˜¯å¦æ˜¯æ¨¡å¼ä¸²ã€‚æ—¶é—´å¤æ‚åº¦ä¸º$O(\\sqrt{n}m)$ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using ull = unsigned long long; struct PolyHash { static constexpr int mod = (int)1e9 + 123; static vector\u0026lt;int\u0026gt; pow; static constexpr int base = 233; vector\u0026lt;int\u0026gt; pref; PolyHash(const string \u0026amp;s) : pref(s.size() + 1) { assert(base \u0026lt; mod); int n = (int)s.size(); while ((int)pow.size() \u0026lt;= n) { pow.push_back((ll)pow.back() * base % mod); } for (int i = 0; i \u0026lt; n; i++) { pref[i + 1] = ((ll)pref[i] * base + s[i]) % mod; } } int get_hash() { return pref.back(); } int substr(int pos, int len) { return (pref[pos + len] - (ll)pref[pos] * pow[len] % mod + mod) % mod; } }; vector\u0026lt;int\u0026gt; PolyHash::pow{1}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; int len = (int)s.size(); PolyHash ha(s); int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;string\u0026gt; qstr(q); vector\u0026lt;int\u0026gt; qk(q); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; lens(len + 1); vector\u0026lt;int\u0026gt; ans(q); for (int i = 0; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; qstr[i] \u0026gt;\u0026gt; qk[i]; if ((int)qstr[i].size() \u0026lt;= len) lens[qstr[i].size()].push_back(i); else ans[i] = -1; } for (int l = 1; l \u0026lt;= len; l++) { if (lens[l].empty()) continue; unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; mp, poss; for (auto i : lens[l]) { mp[PolyHash(qstr[i]).get_hash()].push_back(i); } for (int p = 0; p + l \u0026lt;= len; p++) { if (mp.count(ha.substr(p, l))) { poss[ha.substr(p, l)].push_back(p); } } for (auto \u0026amp;[h, v] : mp) { auto \u0026amp;pos = poss[h]; for (auto i : v) { if (pos.size() \u0026gt;= qk[i]) ans[i] = pos[qk[i] - 1] + 1; else ans[i] = -1; } } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } æ–¹æ³•äºŒï¼šACè‡ªåŠ¨æœº å…ˆå°†æ‰€æœ‰æ¨¡å¼ä¸²åŠ å…¥ACè‡ªåŠ¨æœºï¼Œç„¶åå†åŒ¹é…æ–‡æœ¬ä¸²ã€‚æ³¨æ„ACè‡ªåŠ¨æœºä¸­è¦ç»´æŠ¤output linkï¼ˆæ²¿fail linkè·³è½¬æ—¶ç¬¬ä¸€ä¸ªæ¨¡å¼ä¸²ï¼‰ã€‚æ—¶é—´å¤æ‚åº¦$O(n+m+m\\sqrt{n})$ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct AhoCorasick { enum { alpha = 26, first = \u0026#39;a\u0026#39; }; // change this! struct Node { // (nmatches is optional) int back, end = -1, nmatches = 0, output = -1; array\u0026lt;int, alpha\u0026gt; next; Node(int v = -1) { fill(next.begin(), next.end(), v); } }; vector\u0026lt;Node\u0026gt; N; AhoCorasick() : N(1) {} void insert(string \u0026amp;s, int j) { // j: id of string s assert(!s.empty()); int n = 0; for (char c : s) { int \u0026amp;m = N[n].next[c - first]; if (m == -1) { n = m = (int)N.size(); N.emplace_back(); } else n = m; } N[n].end = j; N[n].nmatches++; } void build() { N[0].back = (int)N.size(); N.emplace_back(0); queue\u0026lt;int\u0026gt; q; q.push(0); while (!q.empty()) { int n = q.front(); q.pop(); for (int i = 0; i \u0026lt; alpha; i++) { int pnx = N[N[n].back].next[i]; auto \u0026amp;nxt = N[N[n].next[i]]; if (N[n].next[i] == -1) N[n].next[i] = pnx; else { nxt.back = pnx; nxt.output = N[pnx].end == -1 ? N[pnx].output : pnx; q.push(N[n].next[i]); } } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; find(const string \u0026amp;text) { int n = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(text.size()); // ll count = 0; for (int i = 0; i \u0026lt; (int)text.size(); i++) { n = N[n].next[text[i] - first]; if (N[n].end != -1) { res[i].push_back(N[n].end); } for (int ind = N[n].output; ind != -1; ind = N[ind].output) { res[i].push_back(N[ind].end); } } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; AhoCorasick ac; int q; cin \u0026gt;\u0026gt; q; unordered_map\u0026lt;string, int\u0026gt; mp; vector\u0026lt;string\u0026gt; qstr(q); vector\u0026lt;int\u0026gt; qk(q), ans(q); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; same(q); for (int i = 0; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; qstr[i] \u0026gt;\u0026gt; qk[i]; if (!mp.count(qstr[i])) { mp[qstr[i]] = mp.size(); ac.insert(qstr[i], mp.size() - 1); } same[mp[qstr[i]]].push_back(i); } ac.build(); auto v = ac.find(s); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(mp.size()); for (int i = 0; i \u0026lt; (int)v.size(); i++) { for (auto p : v[i]) { pos[p].push_back(i); } } for (int i = 0; i \u0026lt; (int)mp.size(); i++) { for (auto qi : same[i]) { if (pos[i].size() \u0026gt;= qk[qi]) { ans[qi] = pos[i][qk[qi] - 1] - qstr[qi].size() + 2; } else { ans[qi] = -1; } } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } æ–¹æ³•ä¸‰ï¼šåç¼€æ•°æ®ç»“æ„ åç¼€æ•°æ®ç»“æ„ä¹Ÿèƒ½æ˜¯å¾ˆæ“…é•¿å­—ç¬¦ä¸²åŒ¹é…çš„ï¼Œåç¼€æ ‘å’Œåç¼€è‡ªåŠ¨æœºéƒ½å¯ä»¥è§£å†³æœ¬é¢˜ï¼Œç”±äºæ²¡å­¦è¿‡åç¼€æ ‘å°±åªå†™åç¼€è‡ªåŠ¨æœºçš„åšæ³•äº†ï¼š\nè‹±æ–‡åŸæ–‡\nä¸­æ–‡ç¿»è¯‘\næ³¨æ„åç¼€è‡ªåŠ¨æœºæ˜¯è¿™ä¸‰ç§åšæ³•ä¸­å”¯ä¸€å¯ä»¥åœ¨çº¿å¤„ç†è¯¢é—®çš„åšæ³•ï¼Œå¤„ç†å•æ¬¡è¯¢é—®çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(|s|+occurrence)$ï¼Œoccurrenceä¸ºå‡ºç°æ¬¡æ•°ã€‚æ•´ä½“æ—¶é—´å¤æ‚åº¦$O(m+n+m\\sqrt{n})$ã€‚\nä»£ç  #include \u0026lt;bits/extc++.h\u0026gt; using namespace std; struct SAM { struct state { int len = 0, link = -1; unordered_map\u0026lt;char, int\u0026gt; next; bool is_clone; int first_pos; vector\u0026lt;int\u0026gt; inv_link; }; int last = 0; // the index of the equivalence class of // the whole string vector\u0026lt;state\u0026gt; st; void extend(char c) { int cur = (int)st.size(); st.emplace_back(); st[cur].len = st[last].len + 1; st[cur].first_pos = st[cur].len - 1; int p = last; while (p != -1 \u0026amp;\u0026amp; !st[p].next.count(c)) { st[p].next[c] = cur; p = st[p].link; } if (p == -1) st[cur].link = 0; else { int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) { st[cur].link = q; } else { int clone = (int)st.size(); st.push_back(st[q]); st[clone].len = st[p].len + 1; st[clone].is_clone = true; while (p != -1 \u0026amp;\u0026amp; st[p].next[c] == q) { st[p].next[c] = clone; p = st[p].link; } st[q].link = st[cur].link = clone; } } last = cur; } SAM() â€¦","date":1625005546,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1625005546,"objectID":"c728e7cd43afed873876639d19849e53","permalink":"https://tgc54.com/zh/post/multi-pattern-matching/","publishdate":"2021-06-29T18:25:46-04:00","relpermalink":"/zh/post/multi-pattern-matching/","section":"post","summary":"","tags":["å“ˆå¸Œ","ACè‡ªåŠ¨æœº","åç¼€è‡ªåŠ¨æœº"],"title":"å¤šæ¨¡å¼ä¸²åŒ¹é…çš„3ç§æ–¹æ³•","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å¾ˆè€ƒéªŒæ€ç»´çš„ä¸€é“é¢˜\næ­¤é¢˜ä¸ºNorth American Invitational Programming Contest (NAIPC) 2014 Fé¢˜ï¼Œé¢˜ç›®é“¾æ¥ã€‚\né¢˜æ„ ç»™å‡ºä¸€å¼ å›¾ï¼Œæ¯ä¸ªé¡¶ç‚¹æœ‰$a_i$çš„é‡‘å­ï¼Œä½ è¦ä»é¡¶ç‚¹1æ²¿æœ€çŸ­è·¯åˆ°é¡¶ç‚¹2ï¼Œå†æ²¿ä»»æ„è·¯å¾„è¿”å›ã€‚å¯¹äºè·¯å¾„ä¸Šçš„æ¯ä¸ªé¡¶ç‚¹ï¼Œä½ å¯ä»¥é€‰æ‹©æŠ¢åŠ«ä»–ä»¬çš„é‡‘å­ï¼Œä½†å¦‚æœä½ æŠ¢äº†é‡‘å­ï¼Œè¿”å›çš„æ—¶å€™å°±ä¸èƒ½ç»è¿‡è¿™ä¸ªé¡¶ç‚¹ï¼Œé—®æœ€å¤šèƒ½æŠ¢å¤šå°‘é‡‘å­ã€‚\né¢˜è§£ ç”±äºnå¾ˆå°ï¼Œå¯ä»¥è€ƒè™‘æš´åŠ›æšä¸¾æ¯ä¸€æ¡æœ€çŸ­è·¯ã€‚æˆ‘ä»¬ä¸å¦¨æ¢ä¸ªè§’åº¦æ€è€ƒï¼šå»çš„æ—¶å€™å…ˆæŠŠè·¯å¾„ä¸Šçš„é‡‘å­éƒ½æŠ¢äº†ï¼Œå›æ¥çš„æ—¶å€™å†æŠŠç»è¿‡çš„é¡¶ç‚¹çš„é‡‘å­è¿˜å›å»ã€‚è¿™æ ·å›å»çš„è·¯å¾„å°±å¯ä»¥çœ‹ä½œæ˜¯æœ€çŸ­è·¯ï¼šå¦‚æœç»è¿‡åœ¨æ¥çš„è·¯å¾„ä¸Šçš„ç‚¹èŠ±è´¹å°±æ˜¯$a_i$æ²¡ï¼Œå¦åˆ™èŠ±è´¹å°±æ˜¯0.\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); for (int i = 2; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; g[u].push_back(v); g[v].push_back(u); } queue\u0026lt;int\u0026gt; q; q.push(0); vector\u0026lt;int\u0026gt; dep(n, -1); dep[0] = 0; while (!q.empty()) { auto u = q.front(); q.pop(); for (auto v : g[u]) { if (dep[v] == -1) { dep[v] = dep[u] + 1; q.push(v); } } } int ans = 0; vector\u0026lt;bool\u0026gt; vis(n); auto dijkstra = [\u0026amp;]() { vector\u0026lt;int\u0026gt; dis(n, -1); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; q; dis[0] = 0; q.emplace(0, 0); while (!q.empty()) { auto [d, u] = q.top(); q.pop(); if (d != dis[u]) continue; for (auto v : g[u]) { int nd = d + (vis[v] ? a[v] : 0); if (dis[v] == -1 || nd \u0026lt; dis[v]) { dis[v] = nd; q.emplace(nd, v); } } } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { if (vis[i]) sum += a[i]; } ans = max(ans, sum - dis[1]); }; auto dfs = [\u0026amp;](auto \u0026amp;me, int u) -\u0026gt; void { vis[u] = true; for (auto v : g[u]) { if (v == 1) dijkstra(); else if (dep[v] == dep[u] + 1 \u0026amp;\u0026amp; dep[v] \u0026lt; dep[1]) me(me, v); } vis[u] = false; }; dfs(dfs, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":1624494507,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1624494507,"objectID":"4ece8a823200f9779f86cdb7dd211234","permalink":"https://tgc54.com/zh/post/kattis-goldbandits/","publishdate":"2021-06-23T20:28:27-04:00","relpermalink":"/zh/post/kattis-goldbandits/","section":"post","summary":"å¾ˆè€ƒéªŒæ€ç»´çš„ä¸€é“é¢˜\n","tags":["BFS","æœ€çŸ­è·¯","å›¾è®º"],"title":"NAIPC2014 F - Gold Bandits é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜ç›®é“¾æ¥\næ€è·¯ä¸éš¾ä½†çº¿æ®µæ ‘ç»´æŠ¤çš„å†…å®¹éœ€è¦ä¸€å®šçš„æŠ€å·§ã€‚\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬çœ‹å¦‚ä½•å–lå’Œræ‰èƒ½ä½¿å¾—ç­”æ¡ˆæœ€å¤§ã€‚å¦‚æœ$l=r=i$çš„è¯ï¼Œ$a_i$åœ¨æ­£ä¸­é—´ï¼Œå¦‚æœåŠ å…¥ä¸€ä¸ªå°äºç­‰äº$a_i$çš„æ•°ä¼šè®©$a_i$å¾€å³åï¼Œåä¹‹ï¼ŒåŠ å…¥å¤§äºç­‰äºçš„æ•°ä¼šå¾€å·¦åï¼Œæ‰€ä»¥è®¾[l, r]ä¸­å¤§äº $a_i$ çš„æ•°çš„ä¸ªæ•°ä¸º$x$ï¼Œå°äº$a_i$çš„æ•°çš„ä¸ªæ•°ä¸º$y$ï¼Œï¼ˆç­‰äº$a_i$çš„æ•°å¯ä»¥ç®—å…¥$x$æˆ–$y$å…¶ä¸­ä¹‹ä¸€ï¼‰æˆ‘ä»¬è¦è°ƒæ•´$l,r$æ‰¾åˆ° $x-y$çš„æœ€å¤§å’Œæœ€å°å€¼ï¼ˆåˆ†åˆ«å¯¹åº”$a_i$åœ¨æœ€å·¦å’Œæœ€å³ï¼‰, æ­¤æ—¶çš„ç­”æ¡ˆä¸º$\\max(\\frac{x-y+1}{2}, \\frac{y-x}{2})$ã€‚ç”±äº$l, r$äº’ç›¸ç‹¬ç«‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ†åˆ«çœ‹$[1, i], [i, n]$ä¸¤ä¸ªåŒºé—´ï¼Œæ‰¾åˆ°$l\\in[1, i], r\\in [i, n]$, ä½¿å¾—$[l, i-1], [i+1, r]$ä¸­çš„$x-y$æœ€å¤§æˆ–æœ€å°ã€‚\nå¦‚æœåªæ‰¾ä¸€ä¸ª$a_i$çš„ç­”æ¡ˆçš„è¯ï¼Œå¯ä»¥éå¸¸è½»æ¾çš„ç”¨çº¿æ®µæ ‘è§£å†³ã€‚ä½†æ˜¯å¯¹äºæ•´ä¸ªæ•°ç»„çš„ç­”æ¡ˆå°±è¡Œä¸é€šäº†ï¼Œå¯¹äºå¤„ç†å¤§å°å…³ç³»çš„é¢˜ç›®ä¸€ç§å¸¸ç”¨çš„æŠ€å·§æ˜¯å°†æ•´ä¸ªæ•°ç»„æ’åºï¼Œä»å°åˆ°å¤§è¿›è¡Œå¤„ç†ï¼Œè¿™æ ·å°±èƒ½ä¿è¯ä¹‹å‰çš„æ•°éƒ½æ¯”å½“å‰æ•°å°ï¼Œå¤„ç†èµ·æ¥å°±ä¼šç®€å•å¾ˆå¤šã€‚å¯¹äºæœ¬é¢˜æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­å¤§äº$a_i$çš„ä½ç½®è®¾ä¸º$1$ï¼Œå°äº $a_i$çš„ä½ç½®è®¾ä¸º $-1$ï¼Œå¯¹äºæ¯ä¸ªä½ç½® $i$ï¼Œæˆ‘ä»¬åªè¦æ‰¾åˆ°$sum(l, i-1), l\\in [1, i]$ä¸$sum(i+1, r), r\\in [i, n]$çš„æœ€å¤§å€¼ä¸æœ€å°å€¼ã€‚ç”±äºæˆ‘ä»¬æ˜¯ä»å°åˆ°å¤§å¤„ç†çš„æ‰€ä»¥æ¯æ¬¡åªæ”¹åŠ¨ä¸€ä¸ªä½ç½®(å°†1å˜æˆ-1)ï¼Œè¿™æ ·æ•°ç»„å°±å˜å¾—éå¸¸æ˜“äºç»´æŠ¤ã€‚\nç»´æŠ¤æ•°ç»„çš„é¢˜æˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°ç”¨çº¿æ®µæ ‘ï¼Œä½†è¿™é¢˜çš„è¯¢é—®æ¯”è¾ƒç‰¹åˆ«ï¼Œçœ‹ä¼¼æ˜¯åŒºé—´æœ€å€¼ä½†$sum$å‡½æ•°å¯¹äºä¸åŒçš„iä¹Ÿä¼šæœ‰ä¸åŒçš„å€¼ã€‚è¿™é‡Œæˆ‘ä»¬ç”¨åˆ°ä¸€ç§åœ¨æœ€å¤§å­æ®µå’Œçš„é€’å½’å®ç°ä¸­ç”¨åˆ°çš„æŠ€å·§ï¼Œå³å¯¹äºçº¿æ®µæ ‘ä¸­çš„æ¯ä¸ªåŒºé—´ï¼Œç»´æŠ¤åŒºé—´å’Œï¼Œä»å·¦/å³ç«¯ç‚¹å¼€å§‹çš„æœ€å¤§/æœ€å°å­æ®µå’Œmnl, mnr, mxl, mxrï¼Œç”¨æ•°å­¦è¯­è¨€æè¿°å°±æ˜¯:ä»¤å½“å‰ç»´æŠ¤çš„åŒºé—´æ˜¯$[l, r]$\n$$\\begin{align*}mnl\u0026amp;=\\min_{l\\le i\\le r}(\\operatorname{sum}(l, i))\\\\ mnr\u0026amp;=\\min_{l\\le i\\le r}(\\operatorname{sum}(i, r))\\\\ mxl\u0026amp;=\\max_{l\\le i\\le r}(\\operatorname{sum}(l, i))\\\\ mxr\u0026amp;=\\max_{l\\le i\\le r}(\\operatorname{sum}(i, r))\\end{align*} $$\näº†è§£äº†å®šä¹‰ä¹‹åï¼Œå¦‚ä½•åˆå¹¶åŒºé—´ä¹Ÿå°±å¾ˆå®¹æ˜“æƒ³åˆ°äº†ï¼ˆå…·ä½“çœ‹ä»£ç ï¼‰ï¼Œæ­¤å¤–ä¸ºäº†æ–¹ä¾¿å®ç°ï¼Œæˆ‘ä»¬åœ¨ä»£ç ä¸­å…è®¸æœ€å¤§/æœ€å°å­æ®µä¸åŒ…å«ä»»ä½•æ•°ã€‚è¿˜æœ‰ï¼Œç”±äºç›¸ç­‰çš„æ•°å¯ä»¥éšæ„æ’åˆ—ï¼Œæ‰€ä»¥æ—¢å¯ä»¥ç®—ä½œå¤§çš„æ•°åˆå¯ä»¥ç®—ä½œå°çš„æ•°ï¼Œæ‰€ä»¥è¦è¯¢é—®ä¸¤éä¸€æ¬¡å½“ä½œå°çš„æ•°ï¼Œä¸€æ¬¡å½“ä½œå¤§çš„æ•°ã€‚\nä»£ç ï¼š #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; struct SegTree { int n; vector\u0026lt;T\u0026gt; t; SegTree(int n_) : n(n_), t(4 * n) { build(1, 0, n - 1, vector(n, T())); } template \u0026lt;typename U\u0026gt; SegTree(const vector\u0026lt;T\u0026gt; \u0026amp;v) : SegTree((int)v.size()) { build(1, 0, n - 1, v); } void pull(int node) { t[node] = t[node \u0026lt;\u0026lt; 1] + t[node \u0026lt;\u0026lt; 1 | 1]; } template \u0026lt;typename U\u0026gt; void build(int node, int l, int r, const vector\u0026lt;U\u0026gt; \u0026amp;v) { if (l == r) { t[node] = T(v[l]); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(node \u0026lt;\u0026lt; 1, l, mid, v); build(node \u0026lt;\u0026lt; 1 | 1, mid + 1, r, v); pull(node); } void set(int node, int i, T x, int l, int r) { if (l == r) { t[node] = x; return; } int mid = (l + r) / 2; if (i \u0026lt;= mid) set(node \u0026lt;\u0026lt; 1, i, x, l, mid); else set(node \u0026lt;\u0026lt; 1 | 1, i, x, mid + 1, r); pull(node); } T get(int node, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (qr \u0026lt;= mid) return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid); if (ql \u0026gt; mid) return get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid) + get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); } // wrapper void set(int i, T x) { assert(i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; n); set(1, i, x, 0, n - 1); } T get(int l, int r) { // assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); if (l \u0026gt; r) return T(); return get(1, l, r, 0, n - 1); } }; struct node { int sum = 0; int mxl = 0, mxr = 0, mnl = 0, mnr = 0; node(int x = 0) : sum(x), mxl(max(0, x)), mxr(mxl), mnl(min(0, x)), mnr(mnl) {} node(int a, int b, int c, int d, int e) : sum(a), mxl(b), mxr(c), mnl(d), mnr(e) {} node operator+(const node \u0026amp;b) const { return { sum + b.sum, max(mxl, sum + b.mxl), max(b.mxr, b.sum + mxr), min(mnl, sum + b.mnl), min(b.mnr, b.sum + mnr), }; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(n + 1); SegTree\u0026lt;node\u0026gt; st(n); for (int i = 0; i \u0026lt; n; i++) { st.set(i, node(1)); } for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; pos[x].push_back(i); } vector\u0026lt;int\u0026gt; ans(n); for (int i = 1; i \u0026lt;= n; i++) { for (auto p : pos[i]) { auto r = st.get(p + 1, n - 1); auto l = st.get(0, p - 1); ans[p] = max(ans[p], (r.mxl + l.mxr + 1) / 2); } for (auto p : pos[i]) st.set(p, node(-1)); for (auto p : pos[i]) { auto r = st.get(p + 1, n - 1); auto l = st.get(0, p - 1); ans[p] = max(ans[p], (-r.mnl - l.mnr) / 2); } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } ","date":1624201329,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1624201329,"objectID":"89c3f60b50af22c3d9b5340013c02f63","permalink":"https://tgc54.com/zh/post/cf1539f/","publishdate":"2021-06-20T11:02:09-04:00","relpermalink":"/zh/post/cf1539f/","section":"post","summary":"é¢˜ç›®é“¾æ¥\næ€è·¯ä¸éš¾ä½†çº¿æ®µæ ‘ç»´æŠ¤çš„å†…å®¹éœ€è¦ä¸€å®šçš„æŠ€å·§ã€‚\n","tags":["æ•°æ®ç»“æ„","çº¿æ®µæ ‘"],"title":"CodeForces 1539F - Strange Array é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å½“æ—¶æœ‰ä¸ªç»†èŠ‚æ²¡æƒ³åˆ°ï¼Œç›´æ¥fst\né¦–å…ˆä¸éš¾è¯æ˜æœ€ç»ˆçš„å­—ç¬¦ä¸²ä¸€å®šæ˜¯ç”±sçš„ä¸€ä¸ªå‰ç¼€ä¸æ–­é‡å¤å¾—åˆ°çš„ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æšä¸¾å‰ç¼€çš„ä½ç½®i,å¦‚æœä»iå¼€å§‹é‡å¤èƒ½ä½¿å¾—æ–°å­—ç¬¦ä¸²æ¯”åŸå­—ç¬¦ä¸²å°çš„è¯è¿™ä¸ªä½ç½®å°±æ˜¯æœ‰åˆ©çš„ï¼ŒåŒæ—¶æ ¹æ®å­—å…¸åºçš„è§„åˆ™ï¼Œiè‚¯å®šæ˜¯è¶Šé å‰è¶Šå¥½ï¼Œäºæ˜¯æˆ‘ä»¬å°±å¾—åˆ°äº†ç­–ç•¥ï¼šå°†$s_{i\\dots n}$ä¸$s$æ¯”è¾ƒï¼Œä»æ¯”$s$å¤§çš„ä¸­æ‰¾å‡ºiæœ€å°çš„é‚£ä¸ªã€‚æˆ‘æ¯”èµ›çš„æ—¶å€™ä¸€çœ‹è¿™ä¸å°±æ˜¯åç¼€æ•°ç»„å˜›ï¼Œè¿‡äº†pretestå¿ƒé‡Œç¾æ»‹æ»‹ï¼Œç»“æœsystem testçš„æ—¶å€™ï¼š é‚£ä¹ˆé—®é¢˜å‡ºåœ¨å“ªäº†å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹è¿™ä¸ªä¾‹å­$s=bab$ã€‚å½“$i=2$æ—¶ï¼Œ$s_{2\\dots 2}=b$æ˜¯$s$çš„ä¸€ä¸ªå‰ç¼€ï¼Œçœ‹ä¼¼$b$æ¯”è¾ƒå°ï¼Œä½†ç”±äºå­—ç¬¦ä¸²æ˜¯å¾ªç¯çš„æ‰€ä»¥è¡¥ä¸Šä¸€ä¸ª$s$ä¹‹åå˜ä¸º$bbab$å°±æ¯”så¤§äº†ã€‚æ‰€ä»¥è¿™ç§æƒ…å†µä¹Ÿå°±æ˜¯è¯´$s$çš„æŸä¸ªåç¼€ç­‰äºå‰ç¼€ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥è¯´æ˜æ‰”æ‰è¿™ä¸ªåç¼€å¯ä»¥è·å¾—æ›´å¥½çš„ç­”æ¡ˆï¼šå‡è®¾è¿™ä¸ªåç¼€çš„é•¿åº¦æ˜¯$i$ï¼Œ$s$ä¸$s_{0\\dots n-i-1}$å¾ªç¯ä¸€æ¬¡åä¼šåœ¨$s$ä¸$s_{i\\dots n-1}$å¯¹åº”çš„ä½ç½®å‘ç”Ÿä¸åŒï¼Œæ¯”å¦‚è¯´$s=cbcacb$å¾ªç¯ä¹‹åæ˜¯è¿™æ ·çš„\n$$\\begin{align*}\u0026amp;cbcacb|\\underline{cbcacb} \\\\ \u0026amp;cbca|cb\\underline{ca} \\end{align*}$$\nå…¶ä¸­ç«–çº¿ç”¨æ¥åˆ†éš”å¾ªç¯ï¼Œä¸‹åˆ’çº¿æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²å¼€å§‹ä¸åŒçš„ä½ç½®ã€‚å¯ä»¥è¯æ˜$s\\ge s_{i\\dots n-1}$,å› ä¸ºå¦‚æœå°äºçš„è¯ï¼Œç”±äº$i\u0026lt;n-i-1$ï¼Œæ‰€ä»¥$i$å°±æ˜¯æ›´å¥½çš„ä½ç½®ï¼Œä¹Ÿå°±ç”¨ä¸åˆ°è€ƒè™‘åç¼€çš„æƒ…å†µäº†ï¼Œå› æ­¤æˆ‘ä»¬è¯´æ˜äº†æ‰”æ‰åç¼€ä¸€å®šæ˜¯æ›´å¥½çš„é€‰æ‹©ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æƒ³åŠæ³•è®©åç¼€åœ¨åç¼€æ•°ç»„ä¸­æ’åœ¨$s$åé¢ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥åœ¨$s$åé¢åŠ ä¸€ä¸ªå¤§äºæ‰€æœ‰å­—æ¯çš„å­—ç¬¦ï¼Œè¿™æ ·å°±ä¿è¯äº†å¦‚æœæœ‰åç¼€æ˜¯sçš„å‰ç¼€çš„æƒ…å†µï¼Œåç¼€ä¸€å®šæ’åœ¨såé¢ã€‚è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†ç”¨æ¯”è¾ƒæ— è„‘çš„ç”¨åç¼€æ•°ç»„çš„åšæ³•ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; suffix_array(string s) { s += \u0026#34;#\u0026#34;; int n = s.size(), N = n + 256; vector\u0026lt;int\u0026gt; sa(n), ra(n); for (int i = 0; i \u0026lt; n; i++) sa[i] = i, ra[i] = s[i]; for (int k = 0; k \u0026lt; n; k ? k *= 2 : k++) { vector\u0026lt;int\u0026gt; nsa(sa), nra(n), cnt(N); for (int i = 0; i \u0026lt; n; i++) nsa[i] = (nsa[i] - k + n) % n; for (int i = 0; i \u0026lt; n; i++) cnt[ra[i]]++; for (int i = 1; i \u0026lt; N; i++) cnt[i] += cnt[i - 1]; for (int i = n - 1; i \u0026gt;= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i]; int r = 0; for (int i = 1; i \u0026lt; n; i++) { if (ra[sa[i]] != ra[sa[i - 1]]) r++; else if (ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n]) r++; nra[sa[i]] = r; } ra = nra; } sa.erase(sa.begin()); return sa; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; s += \u0026#39;|\u0026#39;; auto sa = suffix_array(s); int ii = find(sa.begin(), sa.end(), 0) - sa.begin(); int mn = *min_element(sa.begin() + ii + 1, sa.end()); for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; s[i % mn]; return 0; } ä½†æ˜¯åç¼€æ•°ç»„æœ‰ç‚¹æ€é¸¡ç”¨ç‰›åˆ€äº†ï¼Œæˆ‘ä»¬å…¶å®åªç”¨å’Œ$s$åšæ¯”è¾ƒï¼Œæ‰€ä»¥å¦ä¸€ç§æ›´ç®€å•çš„åšæ³•æ˜¯ç”¨zå‡½æ•°ï¼Œå› ä¸ºzå‡½æ•°æ±‚çš„æ˜¯ä¸æ•´ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å‰ç¼€ï¼Œæ‰€ä»¥æ¯”è¾ƒå‰ç¼€åä¸‹ä¸€ä¸ªå­—ç¬¦å°±èƒ½çŸ¥é“å¤§å°å…³ç³»äº†ã€‚å¯¹äºåç¼€çš„ç‰¹æ®Šæƒ…å†µï¼Œå¦‚æœä¸‹ä¸€ä¸ªå­—ç¬¦çš„ä½ç½®æ˜¯$n$ä¹Ÿå°±è¯´æ˜ $s_{i\\dots n-1}$æ˜¯$s$çš„å‰ç¼€ï¼Œæ‰€ä»¥æ­¤æ—¶içš„ä½ç½®å°±æ˜¯æœ€ä½³ä½ç½®ã€‚ä»£ç å¦‚ä¸‹ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; z_function(const string \u0026amp;s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; auto z = z_function(s); for (int i = 1; i \u0026lt; n; i++) { int f = z[i]; if (f + i \u0026gt;= n || s[f] \u0026lt; s[f + i]) { s.erase(s.begin() + i, s.end()); break; } } for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; s[i % s.size()]; return 0; } ","date":1624113729,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1624113729,"objectID":"0420b224bb77e05ab9dc2095e43ddb98","permalink":"https://tgc54.com/zh/post/cf1537e/","publishdate":"2021-06-19T10:42:09-04:00","relpermalink":"/zh/post/cf1537e/","section":"post","summary":"å½“æ—¶æœ‰ä¸ªç»†èŠ‚æ²¡æƒ³åˆ°ï¼Œç›´æ¥fst\n","tags":["å­—ç¬¦ä¸²","zå‡½æ•°","åç¼€æ•°ç»„"],"title":"CodeForces 1537E - Erase and Extend é¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"æ•´ä½“äºŒåˆ†åœ¨å›½å¤–ç§°ä¸ºparallel binary searchï¼Œæ˜¯ä¸€ç§ç”¨äºåŒæ—¶è§£å†³å¤§é‡äºŒåˆ†æœç´¢çš„ç¦»çº¿ç®—æ³•ã€‚\né€‚ç”¨é—®é¢˜çš„æè¿° ä¸€ç§å¸¸è§çš„ç±»å‹æ˜¯ï¼šç»™å‡ºå¤šä¸ªä¿®æ”¹ä¸è¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®æœ‰ä¸€ä¸ªç›®æ ‡ï¼Œé—®å¤šå°‘ä¸ªä¿®æ”¹ä¹‹åç›®æ ‡å¯ä»¥è¾¾åˆ°ã€‚ä¿®æ”¹å’Œè¯¢é—®éœ€è¦æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š\nè¯¢é—®çš„ç­”æ¡ˆå¯ä»¥äºŒåˆ†ï¼ˆåºŸè¯ï¼‰ ä¿®æ”¹å¯¹ç›®æ ‡çš„è´¡çŒ®äº’ç›¸ç‹¬ç«‹ ä¿®æ”¹å¯¹ç›®æ ‡çš„è´¡çŒ®ä¸ç›®æ ‡æ— å…³ å½“ç„¶ä¸æ˜¯æ‰€æœ‰é—®é¢˜éƒ½è¦ä¸¥æ ¼ç¬¦åˆè¿™ç§å½¢å¼ï¼Œæ•´ä½“äºŒåˆ†çš„æœ¬è´¨å°±æ˜¯å°†è¯¢é—®å½’ç±»ï¼Œä¸€èµ·å¤„ç†å½’ç±»åœ¨ä¸€èµ·è¯¢é—®ã€‚\næ€è·¯ å‡è®¾å½“å‰æœ‰ä¸€äº›è¯¢é—®çš„ç­”æ¡ˆåœ¨æŸä¸ªåŒºé—´ä¸­ï¼Œæˆ‘ä»¬å°†åŒºé—´ä¸€åˆ†ä¸ºäºŒ åº”ç”¨æŸä¸€äº›ä¿®æ”¹ï¼Œè¿™äº›ä¿®æ”¹æ˜¯å¯ä»¥å¸®åŠ©æˆ‘ä»¬åˆ¤æ–­ç­”æ¡ˆåœ¨åœ¨å“ªä¸€åŠåŒºé—´çš„ä¿®æ”¹ åˆ¤æ–­è¿™äº›è¯¢é—®æ˜¯å¦è¾¾åˆ°ç›®æ ‡ï¼Œå°†è¯¢é—®åˆ†ä¸ºè¾¾åˆ°ç›®æ ‡å’Œæ²¡è¾¾åˆ°ç›®æ ‡ä¸¤ä¸ªé›†åˆï¼ŒåŒæ—¶å¯èƒ½ä¼šä¿®æ”¹æ²¡è¾¾åˆ°ç›®æ ‡çš„è¯¢é—®çš„ç›®æ ‡ï¼ˆè¿™ä¸€æ­¥è¦å…·ä½“é—®é¢˜å…·ä½“åˆ†æï¼‰ æ’¤é”€æ­¥éª¤2ä¸­çš„ä¿®æ”¹ åˆ†åˆ«é€’å½’å·¦å³ä¸¤ä¸ªåŒºé—´ ä¾‹é¢˜ å¤šæ¬¡è¯¢é—®æ•°ç»„ç¬¬kå° æ­£å¸¸çš„æ€è·¯æ˜¯å¯¹äºæ¯ä¸ªè¯¢é—®äºŒåˆ†ä¸€æ¬¡ã€‚ä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰€æœ‰è¯¢é—®ä¸€èµ·äºŒåˆ†ï¼Œæ ¹æ®å·¦åŠéƒ¨åˆ†çš„æ•°çš„ä¸ªæ•°åˆ¤æ–­æ¯ä¸ªè¯¢é—®åº”è¯¥åˆ†åˆ°å“ªä¸ªé›†åˆä¸­ã€‚\næ ¸å¿ƒä»£ç å¦‚ä¸‹(ç®€æ´èµ·è§æ²¡ç”¨ç¦»æ•£åŒ–, query[i]æ˜¯ç¬¬iä¸ªè¯¢é—®çš„kå€¼ï¼Œsum(l, r)æ˜¯åœ¨[l, r]åŒºé—´ä¸­çš„æ•°çš„ä¸ªæ•°)\nvoid solve(int l, int r, vector\u0026lt;int\u0026gt; id) { if (l==r || id.empty()) { for (auto i : id) ans[i]=l; return; } vector\u0026lt;int\u0026gt; less, more; int mid=(l+r)/2; for (auto i : id) { if (query[i]\u0026lt;=sum(l, mid)) less.push_back(i); else { query[i]-=sum(l, mid); more.push_back(i); } } solve(l, mid, less); solve(mid+1, r, more); } é™æ€æ•°ç»„åŒºé—´ç¬¬kå° é¢˜ç›®é“¾æ¥\nè¿™é¢˜çš„ä¸€èˆ¬åšæ³•æ˜¯åœ¨å¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼ˆä¸»å¸­æ ‘ï¼‰ä¸ŠäºŒåˆ†ï¼Œå¹¶ä¸”å¯ä»¥åœ¨çº¿å›ç­”è¯¢é—®ã€‚æ•´ä½“äºŒåˆ†æ€è·¯æœ‰ç›¸ä¼¼ä¹Ÿæœ‰ä¸åŒï¼Œå‡è®¾ç›®å‰è¯¢é—®çš„åŒºé—´æ˜¯$[ql, qr]$,ç­”æ¡ˆåœ¨$[l, r]$ä¸­ï¼Œä»¤$mid=(l+r)/2$ï¼Œæ­¤æ—¶æˆ‘ä»¬æ–°å»ºä¸€ä¸ªå’ŒåŸæ•°ç»„ä¸€æ ·é•¿çš„è¾…åŠ©æ•°ç»„ï¼Œå°†æ•´ä¸ªæ•°ç»„ä¸­åœ¨$[l, mid]$ä¸­çš„æ•°åœ¨è¾…åŠ©æ•°ç»„ä¸­å„è‡ªçš„ä½ç½®ä¸Š+1ï¼Œç„¶åæŸ¥è¯¢ä½ç½®åœ¨$[ql, qr]$ä¸­çš„æ•°çš„ä¸ªæ•°ï¼ˆä¹Ÿå°±æ˜¯è¾…åŠ©æ•°ç»„ä¸­$[ql, qr]$çš„åŒºé—´å’Œï¼‰ï¼Œä¸kåšæ¯”è¾ƒå¹¶ç”±æ­¤åˆ¤æ–­å†å¾€å“ªä¸ªåŒºé—´ç»§ç»­äºŒåˆ†ã€‚\nè¿™é‡Œè¦æ³¨æ„è¦æ˜¯æ¯æ¬¡æ„å»ºè¾…åŠ©æ•°ç»„çš„æ—¶å€™éƒ½æ‰«è¿‡æ•´ä¸ªæ•°ç»„ï¼Œæ—¶é—´ä¼šçˆ†ç‚¸ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åƒåˆ’åˆ†è¯¢é—®é‚£æ ·åˆ’åˆ†æ•°ç»„ï¼Œè¿™æ ·æ·»åŠ çš„æ•°éƒ½æ˜¯åœ¨$[l, r]$ä¸­çš„æ•°ã€‚\nå…³äºåˆ’åˆ†çš„å†™æ³•ï¼š\nå¸¸è§çš„å†™æ³•æ˜¯ç”¨ä¸¤ä¸ªæ•°ç»„å­˜å·¦è¾¹å’Œå³è¾¹çš„è¯¢é—®ï¼Œä½†å…¶å®å¯ä»¥ç›´æ¥åˆ©ç”¨std::partitionæˆ–è€…std::stable_partitionç›´æ¥åœ¨åŸæ•°ç»„ä¸Šåˆ’åˆ†ï¼Œå†…å­˜å’Œæ—¶é—´ä¸Šéƒ½æ›´ä¼˜ï¼ˆæ—¶é—´å°‘10%å·¦å³ï¼Œå†…å­˜å°‘30%å·¦å³ï¼‰ï¼Œè€Œä¸”ä¸ªäººæ„Ÿè§‰å†™èµ·æ¥æ›´ç®€æ´ä¸€äº›ï¼Ÿåé¢æ‰€æœ‰é¢˜éƒ½æœ‰partitionçš„å†™æ³•ï¼Œéƒ¨åˆ†æœ‰æ•°ç»„çš„å†™æ³•ï¼Œé€‰æ‹©è‡ªå·±å–œæ¬¢çš„å³å¯ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(),(x).end() constexpr int M=3e5; namespace fenwick { int n; int t[M]; using T=int; void update(int i, T x) { while (i \u0026lt; n) { t[i] += x; i |= (i + 1); } } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } template \u0026lt;typename U\u0026gt; U query(int l, int r) { return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } }; struct Num{ int x, i; }; struct Query { int l, r, k, id; }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;Num\u0026gt; a(n); vector\u0026lt;int\u0026gt; comp(n), aa(n); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;aa[i]; comp[i]=aa[i]; } sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (int i=0; i\u0026lt;n; i++) a[i]={static_cast\u0026lt;int\u0026gt;(lower_bound(all(comp), aa[i])-comp.begin()), i}; // ç¦»æ•£åŒ– vector\u0026lt;Query\u0026gt; Q(q); for (int i=0; i\u0026lt;q; i++) { auto\u0026amp; [l, r, k, id]=Q[i]; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;k; id=i; l--, r--; } fenwick::n=n; vector\u0026lt;int\u0026gt; ans(q); // abegin å’Œ aend æ˜¯åŸæ•°ç»„ä¸­å€¼åœ¨[l, r]ä¸­çš„æ•°çš„åŒºé—´ï¼Œ qbegin å’Œ qendæ˜¯ç­”æ¡ˆåœ¨[l, r]ä¸­çš„è¯¢é—®çš„åŒºé—´ auto solve=[\u0026amp;](auto\u0026amp; solve, int l, int r, auto abegin, auto aend, auto qbegin, auto qend) { if (l==r || qbegin==qend) { for (auto it=qbegin; it!=qend; ++it) ans[it-\u0026gt;id]=l; return; } int mid=(l+r)/2; auto amid=partition(abegin, aend, [\u0026amp;](Num\u0026amp; x){ // åˆ’åˆ†åŸæ•°ç»„ï¼Œå¹¶æ›´æ–°æ ‘çŠ¶æ•°ç»„ if (x.x\u0026lt;=mid) { fenwick::update(x.i, 1); return true; } return false; }); auto qmid=partition(qbegin, qend, [\u0026amp;](Query\u0026amp; q) { // åˆ’åˆ†è¯¢é—® int t=fenwick::query\u0026lt;int\u0026gt;(q.l, q.r); if (q.k\u0026lt;=t) return true; else { q.k-=t; return false; } }); for (auto it=abegin; it!=amid; ++it) fenwick::update(it-\u0026gt;i, -1); // æ’¤é”€ä¹‹å‰çš„æ“ä½œä»¥æ¸…ç©ºæ ‘çŠ¶æ•°ç»„ solve(solve, l, mid, abegin, amid, qbegin, qmid); solve(solve, mid+1, r, amid, aend, qmid, qend); }; solve(solve, 0, (int)comp.size(), a.begin(), a.end(), Q.begin(), Q.end()); for (auto x : ans) cout\u0026lt;\u0026lt;comp[x]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } åŠ¨æ€åŒºé—´ç¬¬kå° é¢˜ç›®é“¾æ¥\nä¿®æ”¹æ— éå°±æ˜¯æŠŠåŸæ¥çš„æ•°åˆ æ‰ï¼ˆåœ¨è¾…åŠ©æ•°ç»„ä¸­å‡1ï¼‰ï¼Œå†åŠ ä¸Šä¿®æ”¹ä¹‹åçš„æ•°ï¼Œå’Œä¸Šä¸€é¢˜å¤§åŒå°å¼‚ã€‚åŒºåˆ«æ˜¯ç”±äºæœ‰äº†æ—¶é—´é¡ºåºï¼Œä¸èƒ½åƒä¸Šä¸€é¢˜å…ˆä¿®æ”¹å†è¯¢é—®äº†ï¼Œè¦æŠŠä¿®æ”¹å’Œè¯¢é—®æ”¾åœ¨ä¸€ä¸ªæ•°ç»„ï¼ˆå…¶å®ä¸Šä¸€é¢˜ä¹Ÿèƒ½æ”¾åœ¨ä¸€ä¸ªæ•°ç»„é‡Œï¼Œåªæ˜¯ä¸ºäº†æ–¹ä¾¿ç†è§£åˆ†æˆäº†ä¸¤ä¸ªæ•°ç»„ï¼‰ï¼Œè€Œä¸”è¦ç”¨std::stable_partitionä»¥ä¿è¯ç›¸å¯¹æ—¶é—´é¡ºåºä¸å˜ã€‚\nä»£ç 1ï¼ˆpartitionï¼‰ #include \u0026lt;algorithm\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(), (x).end() constexpr int M = 3e5; int N; int t[M]; using T = int; void update(int i, T x) { while (i \u0026lt; N) { t[i] += x; i |= (i + 1); } } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } template \u0026lt;typename U\u0026gt; U query(int l, int r) { return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } struct op { int type; // if type==0, add j to position i, a[i]=k // if type==1, query k-th smallest element in [i, j], id is the index of the query int i, j, k, id; }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;op\u0026gt; ops; vector\u0026lt;int\u0026gt; comp, a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; comp.push_back(a[i]); ops.push_back({0, i, 1, a[i], -1}); } int qcnt = 0; for (int i = 0; i \u0026lt; q; i++) { char ch; cin \u0026gt;\u0026gt; ch; if (ch == \u0026#39;Q\u0026#39;) { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; ops.push_back({1, l - 1, r - 1, k, qcnt++}); } else { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--; ops.push_back({0, x, -1, a[x], -1}); comp.push_back(y); a[x] = y; ops.push_back({0, x, 1, y, -1}); } } // ç¦»æ•£åŒ– sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (auto \u0026amp;[type, i, j, k, id] : ops) { if (type == 0) k = lower_bound(all(comp), k) - comp.begin(); } N = n; vector\u0026lt;int\u0026gt; ans(qcnt); auto solve = [\u0026amp;](auto \u0026amp;solve, int l, int r, auto begin, auto end) { if (l == r || begin == end) { for (auto it = begin; it != end; ++it) if (it-\u0026gt;type == 1) ans[it-\u0026gt;id] = l; return; } int mid = (l + r) / 2; // å› ä¸ºè¦ä¿è¯ç›¸å¯¹é¡ºåºä¸å˜æ‰€ä»¥è¦ç”¨stable_partition auto qmid = stable_partition(begin, end, [\u0026amp;](op \u0026amp;q) { auto \u0026amp;[type, i, j, k, id] = q; if (type == 1) { int cnt â€¦","date":1622911019,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1622911019,"objectID":"96c42ed53eaf71b543e875db69b7c626","permalink":"https://tgc54.com/zh/post/parallel_bsearch/","publishdate":"2021-06-05T12:36:59-04:00","relpermalink":"/zh/post/parallel_bsearch/","section":"post","summary":"æ•´ä½“äºŒåˆ†åœ¨å›½å¤–ç§°ä¸ºparallel binary searchï¼Œæ˜¯ä¸€ç§ç”¨äºåŒæ—¶è§£å†³å¤§é‡äºŒåˆ†æœç´¢çš„ç¦»çº¿ç®—æ³•ã€‚\n","tags":["æ•´ä½“äºŒåˆ†","ç¦»çº¿æŠ€å·§","äºŒåˆ†"],"title":"æ•´ä½“äºŒåˆ†å­¦ä¹ ç¬”è®°","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æœ‰ç‚¹ä¸çŸ¥å¦‚ä½•ä¸‹æ‰‹çš„é¢˜\næœ¬æ–‡åŸºæœ¬æ˜¯ç…§ç€è¿™ä¸ªç¿»è¯‘çš„ã€‚Pawnæ˜¯å›½é™…è±¡æ£‹é‡Œçš„å…µã€‚\nç”±äºåªèƒ½å¾€ä¸‹èµ°ï¼Œæˆ‘ä»¬ä»ä¸Šåˆ°ä¸‹ä¸€è¡Œä¸€è¡Œçš„å¤„ç†ï¼Œç»´æŠ¤æœ¬å±‚èƒ½å¤Ÿåˆ°è¾¾ çš„ä½ç½®ã€‚æ ¹æ®è§„åˆ™ï¼Œæœ‰ä¸¤ç§æƒ…å†µä¼šä½¿åˆ°è¾¾æ€§å‘ç”Ÿæ”¹å˜ï¼š\nå¦‚æœèƒ½åˆ°è¾¾ä¸Šä¸€è¡Œçš„iä½ç½®è€Œæœ¬è¡Œçš„iä½ç½®æœ‰ä¸€ä¸ªå…µï¼Œé‚£ä¹ˆæœ¬è¡Œçš„iä½ç½®å°±æ˜¯ä¸å¯è¾¾çš„ã€‚ å¦‚æœä¸Šä¸€è¡Œçš„i-1æˆ–i+1èƒ½åˆ°è¾¾çš„è¯è€Œæœ¬è¡Œçš„iä½ç½®æœ‰ä¸€ä¸ªå…µï¼Œæœ¬è¡Œçš„iä½ç½®å°±æ˜¯å¯è¾¾çš„ã€‚ ç”±äºç¬¬äºŒç§æƒ…å†µå¯ä»¥è¦†ç›–æ‰ç¬¬ä¸€ç§æƒ…å†µï¼ˆå³å¦‚æœiåŒæ—¶ç¬¦åˆä¸¤ç§æƒ…å†µé‚£ä»–ä¹Ÿæ˜¯å¯è¾¾çš„ï¼‰ï¼Œæ‰€ä»¥åœ¨æˆ‘ä»¬è®°å½•ä¸å¯è¾¾å’Œå¯è¾¾çš„å˜åŒ–ä¹‹åï¼Œå…ˆå¤„ç†ä¸å¯è¾¾çš„å˜åŒ–ï¼Œå†å¤„ç†å¯è¾¾çš„å˜åŒ–ã€‚\nä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; p(m); for (auto \u0026amp;[x, y] : p) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; } sort(p.begin(), p.end()); set\u0026lt;int\u0026gt; s{n}; for (int l = 0, r = 0; l \u0026lt; m; l = r) { while (r \u0026lt; m \u0026amp;\u0026amp; p[l].first == p[r].first) r++; vector\u0026lt;int\u0026gt; rem, ins; for (int i = l; i \u0026lt; r; i++) { int y = p[i].second; rem.push_back(y); if (s.count(y - 1) || s.count(y + 1)) ins.push_back(y); } for (auto x : rem) s.erase(x); for (auto x : ins) s.insert(x); } cout \u0026lt;\u0026lt; s.size(); return 0; } ","date":1622909529,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1622909529,"objectID":"958b208b74d06d87795cdd299061089d","permalink":"https://tgc54.com/zh/post/abc203e/","publishdate":"2021-06-05T12:12:09-04:00","relpermalink":"/zh/post/abc203e/","section":"post","summary":"æœ‰ç‚¹ä¸çŸ¥å¦‚ä½•ä¸‹æ‰‹çš„é¢˜\n","tags":[],"title":"AtCoder Beginner Contest (ABC) 203E é¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"å­æ ‘ç›¸å…³çš„åº”ç”¨ ç”±äºå­æ ‘çš„dfsåºæ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“å¾—åˆ°å­æ ‘çš„ä¿¡æ¯ã€‚\næ ‘ä¸Šå¯å‘å¼åˆå¹¶ ç”¨äºåˆ æ‰è½»å­æ ‘çš„ä¿¡æ¯\nvector\u0026lt;int\u0026gt; bch(n, -1); int cur_big=-1; auto get_big = [\u0026amp;](auto \u0026amp;dfs, int u, int p) -\u0026gt; int { int sz = 1, mx = 0; for (auto v : g[u]) { if (v == p) continue; int csz = dfs(dfs, v, u); if (csz \u0026gt; mx) mx = csz, bch[u] = v; sz += csz; } return sz; }; auto add=[\u0026amp;](auto\u0026amp; slf, int u, int p, int x) -\u0026gt; void { // update info of u here for (auto v : g[u]) { if (v==p || v==cur_big) continue; slf(slf, v, u, x); } }; auto dfs = [\u0026amp;](auto \u0026amp;dfs, int u, int pa, bool keep) -\u0026gt; void { int big = bch[u]; for (auto v : g[u]) if (v != pa \u0026amp;\u0026amp; v != big) dfs(dfs, v, u, 0); if (big != -1) { dfs(dfs, big, u, 1); cur_big=big; } add(add, u, pa, 1); // now you get all the info of subtree of u, answer queries about u here. cur_big=-1; if (!keep) add(add, u, pa, -1); }; åˆ©ç”¨äºŒåˆ†æŸ¥è¯¢å­æ ‘ä¿¡æ¯ å¦‚æœæŸ¥è¯¢çš„ä¿¡æ¯æ˜¯ç±»ä¼¼äºå­æ ‘ä¸­æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹æ»¡è¶³ä¸€å®šæ¡ä»¶ï¼Œæ¯”å¦‚ï¼šæœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹çš„é¢œè‰²ä¸ºxï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥ä¸ºæ¯ä¸ªé¢œè‰²å¼€ä¸€ä¸ªæ•°ç»„å­˜ï¼Œå¹¶ä¸”åœ¨dfsçš„æ—¶å€™å°†æ¯ä¸ªèŠ‚ç‚¹æ”¾å…¥å¯¹åº”æ•°ç»„ã€‚ç”±äºå­æ ‘çš„dfsåºæ˜¯è¿ç»­çš„ï¼Œåœ¨æ•°ç»„ä¸­çš„èŠ‚ç‚¹ä¹Ÿæ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„è¿›å‡ºæ—¶é—´æˆ³ï¼Œåˆ©ç”¨äºŒåˆ†å¾—åˆ°å­æ ‘åŒºé—´çš„é•¿åº¦ã€‚\nç»ƒä¹ é¢˜ï¼š\nABC202 E\nä»£ç  //#pragma GCC target(\u0026#34;avx,avx2,fma\u0026#34;) //#pragma GCC optimize(\u0026#34;unroll-loops,Ofast\u0026#34;) #include \u0026lt;algorithm\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; /*{{{*/ using namespace std; #ifdef LOCAL #include\u0026lt;pprint.hpp\u0026gt; // https://github.com/p-ranav/pprint pprint::PrettyPrinter P(cerr); #define de(...) P.compact(true);P.print(__VA_ARGS__) #define de_nc(...) P.compact(false);P.print(__VA_ARGS__) #else #define de(...) #define de_nc(...) #endif #define all(x) (x).begin(),(x).end() using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; inline namespace Traits { // is iterable template\u0026lt;typename T, typename = void\u0026gt; struct is_iterable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_iterable\u0026lt;T, void_t\u0026lt;decltype(begin(declval\u0026lt;T\u0026gt;())), decltype(end(declval\u0026lt;T\u0026gt;()))\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_iterable_v = is_iterable\u0026lt;T\u0026gt;::value; // is readable template\u0026lt;typename T, typename = void\u0026gt; struct is_readable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_readable\u0026lt;T, enable_if_t\u0026lt;is_same_v\u0026lt;decltype(cin \u0026gt;\u0026gt; declval\u0026lt;T\u0026amp;\u0026gt;()), istream\u0026amp;\u0026gt;\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_readable_v = is_readable\u0026lt;T\u0026gt;::value; // is printable template\u0026lt;typename T, typename = void\u0026gt; struct is_printable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_printable\u0026lt;T, enable_if_t\u0026lt;is_same_v\u0026lt;decltype(cout \u0026lt;\u0026lt; declval\u0026lt;T\u0026gt;()), ostream\u0026amp;\u0026gt;\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_printable_v = is_printable\u0026lt;T\u0026gt;::value; } inline namespace Input { template\u0026lt;typename T\u0026gt; constexpr bool needs_input_v = !is_readable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_iterable_v\u0026lt;T\u0026gt;; template\u0026lt;typename T, typename U\u0026gt; void re(pair\u0026lt;T, U\u0026gt;\u0026amp; p); template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;is_readable_v\u0026lt;T\u0026gt;\u0026gt; re(T\u0026amp; x) { cin\u0026gt;\u0026gt;x; } template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;needs_input_v\u0026lt;T\u0026gt;\u0026gt; re(T\u0026amp; v) { for (auto\u0026amp; x : v) re(x); } template\u0026lt;typename... T\u0026gt; void re(T\u0026amp;... args) {(re(args), ...);} template\u0026lt;typename T, typename U\u0026gt; void re(pair\u0026lt;T, U\u0026gt;\u0026amp; p) { re(p.first, p.second); }; } inline namespace Output { template\u0026lt;typename T\u0026gt; constexpr bool needs_output_v = !is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_iterable_v\u0026lt;T\u0026gt;; template\u0026lt;int offset=0, typename... T\u0026gt; void wr(T... args); template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_integral_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { cout\u0026lt;\u0026lt;x+offset; } template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; !is_integral_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { cout\u0026lt;\u0026lt;x; } template\u0026lt;int offset=0,typename T, typename U\u0026gt; void _W(const pair\u0026lt;T, U\u0026gt;\u0026amp; p) { wr\u0026lt;offset\u0026gt;(p.first, p.second); } template\u0026lt;int offset=0,typename It\u0026gt; void _W(It f, const It\u0026amp; l) { for (;f!=l; ++f) { _W\u0026lt;offset\u0026gt;(*f); if (f!=l) cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }} template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;needs_output_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { _W\u0026lt;offset\u0026gt;(begin(x), end(x)); } template\u0026lt;int offset, typename... T\u0026gt; void wr(T... args) { int i=0; ((_W\u0026lt;offset\u0026gt;(args), ++i, cout\u0026lt;\u0026lt;(i==sizeof...(args) ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;)), ...); #ifdef LOCAL cout.flush(); #endif } } template\u0026lt;typename T\u0026gt; bool ckmin(T\u0026amp; a, const T\u0026amp; b) { return b \u0026lt; a ? a = b, 1 : 0; } // set a = min(a,b) template\u0026lt;typename T\u0026gt; bool ckmax(T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? a = b, 1 : 0; }/*}}}*/ void solve() { int n; re(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=1; i\u0026lt;n; i++) { int p; re(p); g[p-1].push_back(i); } int timer=0; vector\u0026lt;int\u0026gt; in(n), out(n), dep(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(n); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u) -\u0026gt; void { in[u]=timer++; pos[dep[u]].push_back(in[u]); for (auto v : g[u]) { dep[v]=dep[u]+1; dfs(dfs, v); } out[u]=timer; }; dfs(dfs, 0); int q; re(q); while (q--) { int u, d; re(u, d); u--; auto\u0026amp; v=pos[d]; wr(lower_bound(all(v), out[u])-lower_bound(all(v), in[u])); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt=1; while (tt--) { solve(); } return 0; } è·¯å¾„ç›¸å…³åº”ç”¨ å¦‚æœä¿¡æ¯æ˜¯å¯é€†çš„ï¼Œæ¯”å¦‚è¯´æ±‚å’Œï¼Œæˆ‘ä»¬å¯ä»¥ç»“åˆæ¬§æ‹‰åºï¼Œç¬¬ä¸€æ¬¡è®¿é—®èŠ‚ç‚¹çš„æ—¶å€™åœ¨åºåˆ—ä¸­æ”¾å…¥æ­£å€¼ï¼Œè®¿é—®ç»“æŸä¹‹åæ”¾å…¥è´Ÿå€¼ï¼Œè¿™æ ·ä¸åœ¨dfsæ ˆä¸­çš„èŠ‚ç‚¹å°±ä¼šè¢«æŠµæ¶ˆæ‰ã€‚æ€»çš„æ¥è¯´ï¼Œå‡è®¾è¦æ±‚çš„è·¯å¾„æ˜¯ä»uåˆ°vï¼ˆvæ˜¯uçš„ç¥–å…ˆï¼Œå¦‚æœä¸æ˜¯å°±æ‹†æˆu-\u0026gt;lca(u, v)å’Œv-\u0026gt;lca(u, v)ä¸¤æ¡è·¯å¾„ï¼‰ï¼Œé‚£ä¹ˆè·¯å¾„å’Œå°±æ˜¯åºåˆ—ä¸­in[v]åˆ°in[u]çš„å’Œã€‚\n","date":1621783234,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1621783234,"objectID":"304dd5b79ee6d4615bb74e39dd6573cd","permalink":"https://tgc54.com/zh/post/dfs_ordering/","publishdate":"2021-05-23T11:20:34-04:00","relpermalink":"/zh/post/dfs_ordering/","section":"post","summary":"","tags":["DFS"],"title":"DFSåº/æ¬§æ‹‰åºçš„åº”ç”¨ï¼ˆæŒç»­æ›´æ–°ï¼‰","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"èƒŒæ™¯ï¼šä»Šå¤©åšäº†ä¸ªé¢˜ï¼Œç”¨è‡ªå·±å¹³å¸¸çš„äºŒåˆ†å†™æ³•å¾ˆä¸æ–¹ä¾¿ï¼Œç¬¬ä¸€æ¬¡ç¢°åˆ°è¿™ç§æƒ…å†µï¼Œä¸ºäº†é˜²æ­¢åé¢å†ç¢°åˆ°ç±»ä¼¼çš„æƒ…å†µï¼Œå†³å®šè®°å½•ä¸€ä¸‹äºŒåˆ†çš„ä¸¤ç§å¸¸è§å†™æ³•ã€‚\næ ¹æ®æœç´¢çš„æ¡ä»¶ï¼Œæ•´ä¸ªæœç´¢åŒºé—´å¯ä»¥è¢«åˆ’åˆ†ä¸ºä¸¤ä¸ªåŒºé—´ï¼Œå…¶ä¸­ä¸€ä¸ªä¸ºç¬¦åˆæ¡ä»¶çš„åŒºé—´ï¼Œæˆ‘ä»¬æƒ³è¦çš„å€¼å°±æ˜¯æœ€æ¥è¿‘åˆ†ç•Œçº¿çš„é‚£ä¸ªæ•°ï¼šå¦‚æœå‰åŠéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼Œé‚£æˆ‘ä»¬è¦æ‰¾çš„æ˜¯å…¶ä¸­æœ€å¤§çš„é‚£ä¸ªå€¼ï¼Œåä¹‹åˆ™æ˜¯ååŠéƒ¨åˆ†ä¸­æœ€å°çš„é‚£ä¸ªå€¼ã€‚è¿™ä¸¤ç§ä¸åŒçš„æƒ…å†µä¼šåœ¨å†™æ³•æœ‰æ‰€ä¸åŒã€‚\nå†™æ³•ä¸€ï¼š\nå¾ªç¯æ¡ä»¶ä¸ºwhile (l \u0026lt;= r)ï¼Œä¼˜ç‚¹æ˜¯ä¸è®ºå“ªéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼Œè¾¹ç•Œå˜åŒ–éƒ½æ˜¯l = mid + 1æˆ–r = mid - 1ï¼Œç»ˆæ­¢æ—¶ï¼Œ$r=l-1$ï¼Œä¹Ÿå°±æ˜¯ræ˜¯å‰åŠéƒ¨åˆ†çš„æœ€å¤§å€¼ï¼Œlå’ŒååŠéƒ¨åˆ†çš„æœ€å°å€¼ï¼Œæ ¹æ®æƒ…å†µå–læˆ–è€…rã€‚\næ¬¡æ–¹æ³•ç¼ºç‚¹æ˜¯ä¸èƒ½åŒæ—¶è¿›è¡Œä¸¤ä¸ªäºŒåˆ†æœç´¢ï¼Œä¸é€‚åˆåœ¨æŸäº›äºŒåˆ†çš„äº¤äº’é¢˜é‡Œä½¿ç”¨ã€‚\nå†™æ³•äºŒï¼š\nå¾ªç¯ç»ˆæ­¢æ¡ä»¶ä¸ºwhile (l \u0026lt; r)ä½†ä¸­ç‚¹çš„å–æ³•å’Œè¾¹ç•Œçš„å˜åŒ–ä¸¤ç§æƒ…å†µä¸ä¸€æ ·ï¼š\nå¦‚æœå‰åŠéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼š\næœç´¢åŒºé—´ä¸º$(l, r]$\nwhile (l \u0026lt; r) { int mid = (l + r + 1) / 2; if (ok(mid)) l = mid; else r = mid - 1; } å¦‚æœååŠéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼š æœç´¢åŒºé—´ä¸º$[l, r)$\nwhile (l \u0026lt; r) { int mid = (l + r) / 2; if (ok(mid)) r = mid; else l = mid + 1; } æ€»ç»“ä¸‹æ¥å°±æ˜¯ï¼š\nä¸­ç‚¹åå‘åˆ†ç•Œçº¿ ç¬¦åˆæ¡ä»¶çš„è¯ï¼Œè¾¹ç•Œç§»åŠ¨åˆ°ä¸­ç‚¹ï¼Œå¦åˆ™è¦+1æˆ–è€…-1 åŠå¼€åŠé—­åŒºé—´æ˜¯ä¸ºäº†è€ƒè™‘åˆ°æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ•°çš„æƒ…å†µï¼Œæ­¤æ—¶è¾¹ç•Œä¼šç§»åŠ¨åˆ°å¼€åŒºé—´é‚£å¤´ï¼Œç±»ä¼¼äºstd::lower_bound(a.begin(), a.end(), x)æ‰¾ä¸åˆ°çš„è¯ä¼šè¿”å›a.end()ã€‚ ä¼˜ç‚¹æ˜¯å¯ä»¥åŒæ—¶è¿›è¡Œä¸¤ä¸ªäºŒåˆ†ï¼Œå½“å…¶ä¸­ä¸€ä¸ªåŒºé—´æ”¶æ•›ä¹‹åå°±ä¸ä¼šå†å˜åŒ–äº†ã€‚è€Œä¸”è¿™ç§å†™æ³•æ¯”è¾ƒç¬¦åˆç›´è§‰ï¼Œæœ‰äº›äºŒåˆ†äº¤äº’é¢˜ä¸­æˆ‘å°±ä¼šä¸ç”±è‡ªä¸»çš„æ¢æˆè¿™ç§å†™æ³•ï¼ˆè™½ç„¶ä»¥å‰å¹¶æ²¡æœ‰ä»”ç»†ç ”ç©¶è¿‡ï¼‰ã€‚ç¼ºç‚¹å°±æ˜¯ç»†èŠ‚ç¨å¤šï¼Œä¸€æ˜¯å–ä¸­ç‚¹çš„å†™æ³•ï¼ŒäºŒæ˜¯æ³¨æ„å¼€åŒºé—´ã€‚\n","date":1621738736,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1621738736,"objectID":"58b49e130ae3733b1af588f85e9c8aea","permalink":"https://tgc54.com/zh/post/bsearch_implementations/","publishdate":"2021-05-22T22:58:56-04:00","relpermalink":"/zh/post/bsearch_implementations/","section":"post","summary":"èƒŒæ™¯ï¼šä»Šå¤©åšäº†ä¸ªé¢˜ï¼Œç”¨è‡ªå·±å¹³å¸¸çš„äºŒåˆ†å†™æ³•å¾ˆä¸æ–¹ä¾¿ï¼Œç¬¬ä¸€æ¬¡ç¢°åˆ°è¿™ç§æƒ…å†µï¼Œä¸ºäº†é˜²æ­¢åé¢å†ç¢°åˆ°ç±»ä¼¼çš„æƒ…å†µï¼Œå†³å®šè®°å½•ä¸€ä¸‹äºŒåˆ†çš„ä¸¤ç§å¸¸è§å†™æ³•ã€‚\n","tags":["äºŒåˆ†"],"title":"äºŒåˆ†æœç´¢çš„ä¸¤ç§å†™æ³•","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å¾ˆç¥å¥‡çš„æŠ€å·§\né¢˜è§£ æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªè¾…åŠ©æ•°ç»„$b$å…¶ä¸­$b_i$æ˜¯$a_i$åç¬¬$k$ä¸ª$a_i$çš„ä¸‹æ ‡ï¼Œæˆ–è€…æ˜¯$n+1$å¦‚æœåé¢æ²¡æœ‰$k$ä¸ª$a_i$äº†ã€‚æ¯”å¦‚è¯´ï¼Œæ ·ä¾‹çš„è¾…åŠ©æ•°ç»„æ˜¯[3, 7, 7, 6, 7, 7].\nè€ƒè™‘è¯¢é—®$(l, r)$ï¼Œå¯¹äº$i\\in [l, r]$ï¼Œå¦‚æœ$b_i\\le r$ï¼Œè¯´æ˜$i$å$a_i$å‡ºç°äº†å¤šäº$k$æ¬¡ï¼Œæ‰€ä»¥$i$ä¸åº”è¯¥åœ¨å†›é˜Ÿé‡Œã€‚ æ‰€ä»¥ç­”æ¡ˆæ˜¯$r-l+1-|\\{b_i|b_i\\le r, i\\in[l, r]\\}|$ã€‚æ‰¾åŒºé—´é‡Œå°äº$x$çš„æ•°çš„ä¸ªæ•°å¯ä»¥ç”¨ä¸»å¸­æ ‘æˆ–è€…waveletæ ‘è§£å†³ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct PST { int n, tot=0; vector\u0026lt;int\u0026gt; lc, rc, sum, roots; // left child, right child PST(int n_) : n(n_), lc(n\u0026lt;\u0026lt;5), rc(n\u0026lt;\u0026lt;5), sum(n\u0026lt;\u0026lt;5), roots(1) { build(0, n-1, roots[0]); } void pushup(int rt) { sum[rt] = sum[lc[rt]] + sum[rc[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc[rt]); build(mid + 1, r, rc[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int old, int\u0026amp; rt) { rt = ++tot; lc[rt] = lc[old]; rc[rt] = rc[old]; if (l == r) { sum[rt] = sum[old] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lc[old], lc[rt]); else update(pos, val, mid + 1, r, rc[old], rc[rt]); pushup(rt); } int update(int pos, int val) { // return the root of the new version int new_root; update(pos, val, 0, n-1, roots.back(), new_root); roots.push_back(new_root); return new_root; } int query(int u, int v, int l, int r, int k) { if (l==r) return sum[v]-sum[u]; int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]]; if (mid\u0026lt;k) return x+query(rc[u], rc[v], mid+1, r, k); return query(lc[u], lc[v], l, mid, k); } int query(int u, int v, int k) { return query(u, v, 0, n-1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; constexpr int M=1e5; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(M); vector\u0026lt;int\u0026gt; a(n, n); for (int i=0; i\u0026lt;n; i++) { int x; cin\u0026gt;\u0026gt;x; pos[x].push_back(i); if (pos[x].size()\u0026gt;k) { a[*(pos[x].rbegin()+k)]=i; } } int last=0; vector\u0026lt;int\u0026gt; roots(n+1); roots[0]=1; PST tr(n+1); for (int i=0; i\u0026lt;n; i++) { roots[i+1]=tr.update(a[i], 1); } int q; cin\u0026gt;\u0026gt;q; while (q--) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=(x+last)%n, r=(y+last)%n; if (l\u0026gt;r) swap(l, r); last=(r-l+1)-tr.query(roots[l], roots[r+1], r); cout\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } ","date":1621648547,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1621648547,"objectID":"16943d8b93a1e041c8144efd5466428c","permalink":"https://tgc54.com/zh/post/cf813e/","publishdate":"2021-05-21T21:55:47-04:00","relpermalink":"/zh/post/cf813e/","section":"post","summary":"å¾ˆç¥å¥‡çš„æŠ€å·§\n","tags":["æ•°æ®ç»“æ„","å¯æŒä¹…åŒ–çº¿æ®µæ ‘","ä¸»å¸­æ ‘"],"title":"CodeForces 813E - Army Creationé¢˜è§£","type":"post"},{"authors":null,"categories":["æ‚é¡¹"],"content":"ç®—æ³•ç«èµ›ä¸­ä¸»è¦æœ‰ä¸¤ç§è°ƒè¯•æ–¹å¼ï¼šè°ƒè¯•å™¨(debugger)å’Œç›´æ¥è¾“å‡ºã€‚è°ƒè¯•å™¨é€‚åˆæŸ¥çœ‹å°‘é‡æˆ–è€…ç‰¹å®šä½ç½®çš„ä¿¡æ¯ï¼Œä½†å¯èƒ½æ¯”è¾ƒè´¹æ—¶é—´å¹¶ä¸”å¦‚æœé”™è¿‡äº†æŸäº›ä¿¡æ¯å°±è¦é‡æ–°è¿è¡Œ,è€Œä¸”å¿…é¡»è¦åæ§½gdbè¾“å‡ºäºŒç»´æ•°ç»„å…¨æŒ¤åœ¨ä¸€è¡Œæ ¹æœ¬æ²¡æ³•çœ‹ï¼›è€Œç›´æ¥è¾“å‡ºé€‚åˆè·Ÿè¸ªå¤§é‡çš„ä¿¡æ¯ï¼Œå¹¶ä¸”å¯ä»¥æ–¹ä¾¿çš„æŸ¥çœ‹ä¹‹å‰çš„ä¿¡æ¯ï¼Œç¼ºç‚¹å°±æ˜¯éœ€è¦åœ¨ä»£ç ä¸­æ·»åŠ é¢å¤–çš„è¯­å¥ï¼ˆå¯èƒ½ä¼šå¾ˆå¤šï¼‰å¹¶ä¸”è¦åœ¨æäº¤ä¹‹å‰åˆ æ‰ï¼ˆå³ä¾¿æ˜¯è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯æµä¹Ÿä¼šå½±å“æ€§èƒ½ï¼‰ã€‚ä¸€ç§è§£å†³åŠæ³•å°±æ˜¯ä½¿ç”¨æå‰å†™å¥½çš„ä»£ç /å¤´æ–‡ä»¶ï¼Œå¹¶ç»“åˆ#ifdefå®å’Œå‘½ä»¤è¡Œdefineå‚æ•°å®ç°åŒºåˆ†æœ¬åœ°å’Œè¯„æµ‹ç¯å¢ƒï¼Œè®©è°ƒè¯•ä»£ç åœ¨ç¯å¢ƒä¸­å¤±æ•ˆã€‚\nè¾“å‡ºæˆ‘ç›´æ¥ç”¨çš„ç°æˆçš„pretty printerï¼Œç„¶ååœ¨ä»£ç ä¸­åŠ å…¥å¦‚ä¸‹è¯­å¥ï¼š\n#ifdef LOCAL #include\u0026lt;pprint.hpp\u0026gt; // https://github.com/p-ranav/pprint pprint::PrettyPrinter P(cerr); #define de(...) P.compact(true);P.print(__VA_ARGS__) #define de_nc(...) P.compact(false);P.print(__VA_ARGS__) #else #define de(...) #define de_nc(...) #endif æ³¨æ„éœ€è¦æŠŠå¤´æ–‡ä»¶çš„ç›®å½•åŠ åˆ°CPLUS_INCLUDE_PATHç¯å¢ƒå˜é‡é‡Œï¼Œæˆ–è€…ä½¿ç”¨-Iæ ‡è®°ã€‚ç¼–è¯‘æ—¶åŠ ä¸Š-DLOCALæ ‡è®°ä»¥å®šä¹‰LOCALï¼Œå¯ä»¥æ¢æˆå…¶ä»–çš„è¯ï¼Œåªè¦ä¿è¯ojé‡Œæ²¡æœ‰è¿™ä¸ªæ ‡è®°å°±è¡Œã€‚\nå¦‚æœä½ ä½¿ç”¨é¢„ç¼–è¯‘å¤´æ–‡ä»¶çš„è¯ï¼Œè¦æŠŠincludeçš„é‚£ä¸€è¡Œæ”¾åˆ°bits/stdc++.hé‡Œï¼Œç„¶åé‡æ–°ç¼–è¯‘bits/stdc++.hã€‚\n","date":1621642947,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1621642947,"objectID":"dfe2f43315433cce61f25389a37ad1a8","permalink":"https://tgc54.com/zh/post/debug_output_header/","publishdate":"2021-05-21T20:22:27-04:00","relpermalink":"/zh/post/debug_output_header/","section":"post","summary":"ç®—æ³•ç«èµ›ä¸­ä¸»è¦æœ‰ä¸¤ç§è°ƒè¯•æ–¹å¼ï¼šè°ƒè¯•å™¨(debugger)å’Œç›´","tags":null,"title":"ä½¿ç”¨è‡ªå®šä¹‰å¤´æ–‡ä»¶åœ¨ç®—æ³•ç«èµ›ä¸­è¾…åŠ©æœ¬åœ°è°ƒè¯•","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ¯”èµ›çš„æ—¶å€™æƒ³é”™æ–¹å‘äº†ğŸ˜\nSolution è®¾ä»é‡Œå‘å¤–å¤šè¾¹å½¢çš„è¾¹æ•°ä¸º$e1, e2, \\dots, e_n$ã€‚ä¸éš¾å‘ç°$e_i$å¿…é¡»æ˜¯$e_{i-1}$çš„å€ æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æŠŠ$e$å†™æˆ$e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$ã€‚æ‰€ä»¥ å¦‚æœæˆ‘ä»¬çŸ¥é“æœ€é‡Œé¢çš„å¤šè¾¹å½¢çš„è¾¹æ•°ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„äº‹æƒ…å°±æ˜¯æ‰¾åˆ°æœ€é•¿çš„åºåˆ—$$k_1=1, k_2, k_3, \\dots, k_n$$ ä½¿å¾—$k_i$æ˜¯$k_{i-1}$çš„å€æ•°å¹¶ä¸”$\\sum_i k_i=K$ã€‚\næ³¨æ„$k_2, k_3,\\dots, k_n$éƒ½æ˜¯$k_2$çš„å€æ•°ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬æŠŠå®ƒä»¬éƒ½é™¤ä»¥$k_2$å°±åˆå¾—åˆ° äº†ä¸€ä¸ªä»¥$1$å¼€å¤´çš„åºåˆ—ï¼ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæ›´å°çš„å­é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨åŠ¨æ€è§„ åˆ’æ¥è§£å†³ï¼šè®¾$dp_i$ä¸ºå’Œä¸º$i$çš„ä¸Šè¿°åºåˆ—çš„æœ€å¤§é•¿åº¦ã€‚å› ä¸ºæˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªçŸ­çš„åºåˆ—ä¹˜ä¸Š ä¸€ä¸ªæ•°å¹¶åœ¨æœ€å‰é¢æ”¾ä¸€ä¸ª$1$ï¼Œä»è€Œå¾—åˆ°ä¸€ä¸ªæ›´é•¿çš„åºåˆ—ï¼Œæ‰€ä»¥çŠ¶æ€è½¬ç§»å°±æ˜¯ï¼š $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":1621111156,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1621111156,"objectID":"888ff33ddab1c124f298856dfa1d76e6","permalink":"https://tgc54.com/zh/post/gcj2021_r2_matrygons/","publishdate":"2021-05-15T16:39:16-04:00","relpermalink":"/zh/post/gcj2021_r2_matrygons/","section":"post","summary":"æ¯”èµ›çš„æ—¶å€™æƒ³é”™æ–¹å‘äº†ğŸ˜\n","tags":["åŠ¨æ€è§„åˆ’"],"title":"Google Code Jam 2021 R2 Matrygonsé¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"è·¯å¾„è¦†ç›–æ˜¯ä¸€ä¸ªè·¯å¾„çš„é›†åˆä½¿å¾—æ¯ä¸ªé¡¶ç‚¹éƒ½åªè¢«ä¸€æ¡è·¯å¾„è¦†ç›–ã€‚æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜è¦æ±‚é›†åˆä¸­è·¯å¾„çš„æ¡æ•°æ˜¯æœ€å°çš„ã€‚\næ ‘çš„æœ€å°è·¯å¾„è¦†ç›– åšæ³•1ï¼šDP $dp_{u, 0}$ä»£è¡¨å½“uä¸ä¸ºè·¯å¾„çš„ç«¯ç‚¹çš„æ—¶å€™ï¼Œu çš„å­æ ‘é‡Œæœ€å°‘çš„è·¯å¾„çš„æ•°ç›®ï¼Œ$dp_{u, 1}$ä»£è¡¨å½“uä¸ºè·¯å¾„çš„ç«¯ç‚¹çš„æ—¶å€™ï¼Œu çš„å­æ ‘é‡Œæœ€å°‘çš„è·¯å¾„çš„æ•°ç›®ã€‚\nè®¾$v$ä¸ºuçš„å„¿å­ï¼ŒçŠ¶æ€è½¬ç§»æ—¶uä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µå¯ä»¥æ˜¯ä¹‹å‰uä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µåŠ ä¸Švä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µï¼Œå³: $$dp_{u, 0}\\coloneqq dp_{u, 0}+dp_{v, 0}$$ ä¹Ÿå¯ä»¥æ˜¯ä»¥uä¸ºç«¯ç‚¹çš„è·¯ä¸ä»¥vä¸ºç«¯ç‚¹ çš„è·¯è¿æˆä¸€æ¡è·¯ï¼Œå³: $$dp_{u, 0}\\coloneqq dp_{u, 1}+dp_{v, 1}-1$$ uä¸ºç«¯ç‚¹çš„æƒ…å†µç±»ä¼¼ï¼Œå¯ä»¥æ˜¯ä¹‹å‰uä¸ºç«¯ç‚¹çš„æƒ…å†µåŠ ä¸Švä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µï¼Œå³ï¼š $$dp_{u, 1}\\coloneqq dp_{u, 1}+dp_{v, 0}$$ ä¹Ÿå¯ä»¥æ˜¯å‰é¢æ‰€æœ‰å„¿å­çš„ä¸ä»¥å„¿å­ä¸ºç«¯ç‚¹çš„è·¯å¾„åŠ ä¸Šä»¥vä¸ºç«¯ç‚¹çš„è·¯å¾„,å³ï¼š $$dp_{u, 1}\\coloneqq sum+dp_{v, 1}$$ ç»¼ä¸Šæ‰€è¿°ï¼š $$\\begin{align*} dp_{u, 0}\u0026amp;\\coloneqq \\min(dp_{u, 0}+dp_{v, 0}, dp_{u, 1}+dp_{v, 1}-1)\\\\ dp_{u, 1}\u0026amp;\\coloneqq \\min(dp_{u, 1}+dp_{v, 0}, sum+dp_{v, 1})\\end{align*}$$\nå¦‚æœè¦è®°å½•æ–¹æ¡ˆçš„è¯åªå…ˆåœ¨dpçš„è¿‡ç¨‹ä¸­è®°å½•ç»è¿‡uçš„è·¯å¾„å¾€ä¸‹èµ°çš„å„¿å­ï¼Œç„¶åå†è·‘ä¸€édfsæ„å»ºè·¯å¾„ã€‚\nä»£ç ï¼š\nvector dp(n, vector\u0026lt;int\u0026gt;(2)); vector nxt(n, vector(2, pair{-1, -1})); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { dp[u][0]=dp[u][1]=1; int sum=0; for (auto v : g[u]) { if (v==p) continue; dfs(dfs, v, u); if (dp[u][0]+dp[v][0] \u0026gt; dp[u][1]+dp[v][1]-1) { nxt[u][0]={nxt[u][1].first, v}; } dp[u][0]=min(dp[u][0]+dp[v][0], dp[u][1]+dp[v][1]-1); if (dp[u][1]+dp[v][0] \u0026gt; sum+dp[v][1]) { nxt[u][1]={v, v}; } dp[u][1]=min(dp[u][1]+dp[v][0], sum+dp[v][1]); sum+=dp[v][0]; } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; end_point(n); //è·¯å¾„çš„ç«¯ç‚¹ vector\u0026lt;pii\u0026gt; remove; // ä¸åœ¨è·¯å¾„è¦†ç›–ä¸­çš„è·¯å¾„ int tot{}; auto dfs2=[\u0026amp;](auto\u0026amp; dfs2, int u, int p, int flag, int id) -\u0026gt; void { // id ä¸ºå½“å‰è·¯å¾„çš„ç¼–å· for (auto v : g[u]) { if (v==p) continue; if (v==nxt[u][flag].first || v==nxt[u][flag].second) { dfs2(dfs2, v, u, 1, id); } else { remove.emplace_back(u, v); tot++; int nflag=dp[v][0]\u0026lt;dp[v][1] ? 0 : 1; if (nflag) end_point[tot].push_back(v); dfs2(dfs2, v, u, nflag, tot); } } if (nxt[u][flag]==pair{-1, -1}) end_point[id].push_back(u); }; åšæ³•2ï¼šè´ªå¿ƒ è´ªå¿ƒåšæ³•æ›´åŠ ç®€å•ï¼Œåªç”¨ä¸€ä¸ªdfså°±èƒ½å®ç°ã€‚å¦‚æœuæœ‰ä¸¤ä¸ªå„¿å­æ˜¯è·¯å¾„çš„ç«¯ç‚¹é‚£ä¹ˆå°±è¿æ¥é‚£ä¸¤æ¡è·¯ï¼Œå¦åˆ™å°±å°†uåšä¸ºç«¯ç‚¹ã€‚\nä»£ç ï¼š\nvector\u0026lt;pii\u0026gt; end_points, remove; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; int { // è¿”å›-1ä»£è¡¨uä¸æ˜¯ç«¯ç‚¹ï¼Œå¦åˆ™è¿”å›ä»¥uä¸ºç«¯ç‚¹çš„è·¯å¾„çš„å¦ä¸€ç«¯ã€‚ vector\u0026lt;int\u0026gt; next; for (auto v : g[u]) { if (v==p) continue; int end_v=dfs(dfs, v, u); if (end_v\u0026gt;=0) { if (next.size() \u0026lt;= 1) { next.push_back(end_v); } else { remove.emplace_back(u, v); end_points.emplace_back(end_v, v); } } else { remove.emplace_back(u, v); } } if (next.empty()) next.push_back(u); if (next.size()==1) { if (p!=-1) return next[0]; end_points.emplace_back(next[0], u); return -1; } else { end_points.emplace_back(next[0], next[1]); return -1; } }; ç»ƒä¹ é¢˜ CF1521D - Nastia Plays with a Tree\nDAGçš„æœ€å°è·¯å¾„è¦†ç›– æˆ‘ä»¬æŠŠåŸå›¾ä¸Šçš„æ¯ä¸ªç‚¹æ‹†æˆä¸¤ä¸ªç‚¹ï¼ˆå¯¹äºç‚¹xï¼Œå¯ä»¥æŠŠä»å®ƒæ‹†å‡ºå»çš„ç‚¹è®°ä¸ºx+nï¼‰ï¼Œå…¶ä¸­ä¸€ä¸ªç‚¹ä¸æºç‚¹ç›¸è¿ï¼Œå¦ä¸€ä¸ªä¸æ±‡ç‚¹ç›¸è¿ã€‚å¯¹äºåŸDAGä¸Šçš„è¾¹u -\u0026gt; vï¼Œåœ¨æ–°å›¾ä¸­è¿æ¥ u -\u0026gt; v\u0026#39;ï¼Œæ‰€æœ‰è¾¹çš„å®¹é‡å‡ä¸º1ã€‚è·‘ä¸€éæœ€å¤§æµï¼ˆæœ¬è´¨ä¸Šæ˜¯äºŒåˆ†å›¾åŒ¹é…ï¼‰ï¼Œå¾—åˆ°çš„æœ€å¤§æµï¼ˆæˆ–è€…æœ€å¤§åŒ¹é…ï¼‰ä¾¿æ˜¯è¢«è¦†ç›–çš„è¾¹æ•°ï¼Œç”±äºè·¯å¾„ä¸Šçš„ç‚¹æ•°ç­‰äºè¾¹æ•°+1ï¼Œæ‰€ä»¥ç‚¹æ•°å‡è¢«è¦†ç›–çš„è¾¹æ•°ä¾¿æ˜¯è·¯å¾„çš„æ•°ç›®ã€‚ä¹Ÿå¯ä»¥ç†è§£ä¸ºæœ€å¤§æµç»è¿‡çš„æ¯ä¸€æ¡è¾¹å¯¹åº”åŸå›¾ä¸­æœ‰ä¸€æ¡å‘è¾¹çš„èµ·ç‚¹ï¼Œæ‰€ä»¥è·¯å¾„çš„ç»ˆç‚¹æ˜¯æ²¡æœ‰å¯¹åº”çš„è¾¹çš„ï¼Œæ‰€ä»¥ç‚¹æ•°å‡è¢«è¦†ç›–çš„è¾¹æ•°ä¾¿æ˜¯ç»ˆç‚¹çš„æ•°ç›®ä¹Ÿå°±æ˜¯è·¯å¾„çš„æ•°ç›®ã€‚\nå¦‚ä½•è®°å½•è·¯å¾„ï¼Ÿå¯ä»¥åœ¨å¢å¹¿é€”ä¸­è®°å½•æ¯ä¸ªç‚¹çš„ä¸‹ä¸€ä¸ªç‚¹ã€‚å¦‚ä½•æ‰¾èµ·ç‚¹ï¼Ÿå¦‚æœx\u0026#39;åˆ°æ±‡ç‚¹çš„å‰©ä½™å®¹é‡ä¸º1ï¼Œè¯´æ˜æ²¡æœ‰ç‚¹æµå‘x ï¼Œä¹Ÿå°±è¯´æ˜xæ˜¯èµ·ç‚¹ã€‚\næ¨¡æ¿é¢˜ï¼š\næ´›è°·P2764 æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜\nä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h, nxt; Flow(int n) : n(n), g(n), nxt(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (a) nxt[u] = v; // å¢å¹¿æˆåŠŸä¾¿è®°å½•è·¯å¾„ if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back((int)e.size()); e.emplace_back(v, c); g[v].push_back((int)e.size()); e.emplace_back(u, 0); } void maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } n = (n - 2) / 2; for (int i = n + 1; i \u0026lt;= 2 * n; i++) { if (e[g[i].back()].cap == 1) { int u = i - n; while (u \u0026gt; 0) { cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; u = nxt[u] - n; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Flow g(2 * n + 2); while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g.addEdge(u, v + n, 1); } for (int i = 1; i \u0026lt;= n; i++) { g.addEdge(0, i, 1); g.addEdge(i + n, 2 * n + 1, 1); } g.maxFlow(0, 2 * n + 1); return 0; } å‚è€ƒèµ„æ–™ https://zhuanlan.zhihu.com/p/125759333\n","date":1620487550,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1620487550,"objectID":"eb1b9db51a2e00ca2ad694637826f07d","permalink":"https://tgc54.com/zh/post/minimum_path_cover/","publishdate":"2021-05-08T11:25:50-04:00","relpermalink":"/zh/post/minimum_path_cover/","section":"post","summary":"è·¯å¾„è¦†ç›–æ˜¯ä¸€ä¸ªè·¯å¾„çš„é›†åˆä½¿å¾—æ¯ä¸ªé¡¶ç‚¹éƒ½åªè¢«ä¸€æ¡è·¯å¾„è¦†ç›–ã€‚æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜è¦æ±‚é›†åˆä¸­è·¯å¾„çš„æ¡æ•°æ˜¯æœ€å°çš„ã€‚\n","tags":["å›¾è®º"],"title":"æ ‘å’ŒDAGçš„æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"è²Œä¼¼è¿˜æŒºç»å…¸çš„ä¸€ä¸ªé—®é¢˜\næ˜¾ç„¶æˆ‘ä»¬è¦å•ç‹¬è€ƒè™‘æ¯ä¸ªè¿é€šå—ï¼Œç»“è®ºæ˜¯ç­”æ¡ˆä¸º$\\lfloor \\frac{m}{2} \\rfloor$ï¼Œå…¶ä¸­mä¸ºè¾¹æ•°ã€‚å¯»æ‰¾ç­”æ¡ˆçš„ç®—æ³•å¦‚ä¸‹ï¼š\nè·‘ä¸€édfså¾—åˆ°dfsç”Ÿæˆæ ‘ï¼Œç„¶åä»ä¸‹å¾€ä¸Šå¤„ç†è¾¹ï¼šå°†ä¸å½“å‰èŠ‚ç‚¹ç›¸è¿çš„è¾¹ä¸¤ä¸¤é…å¯¹ï¼Œå¦‚æœè¾¹æ•°æ˜¯å¥‡æ•°å°±ç•™ä¸‹ä¸çˆ¶äº²èŠ‚ç‚¹ç›¸è¿çš„é‚£æ¡è¾¹ç»™çˆ¶äº²èŠ‚ç‚¹ã€‚è¿™æ ·å°±å¯ä»¥ä¿è¯æ‰€æœ‰è¾¹éƒ½è¢«è¦†ç›–äº†ã€‚\nä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=0; i\u0026lt;m; i++) { int u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--, v--; g[u].push_back(v); g[v].push_back(u); } vector\u0026lt;int\u0026gt; vis(n); vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; res; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; bool { vis[u]=1; vector\u0026lt;int\u0026gt; w; if (p!=-1) w.push_back(p); for (auto v : g[u]) { if (v==p) continue; if (!vis[v]) { if (dfs(dfs, v, u)) w.push_back(v); } else if (vis[v]==1) w.push_back(v); } while (w.size() \u0026gt;= 2) { res.emplace_back(*(w.rbegin()+1), u, w.back()); w.pop_back(); w.pop_back(); } vis[u]=2; return !w.empty(); }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) dfs(dfs, i, -1); } cout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto\u0026amp; [x, y, z] : res) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } ç»ƒä¹ é¢˜ï¼š\nCF1159E - Off by One\ngym102001K - Boomerangs\nCF858E - Wizardâ€™s Tour\n","date":1620271252,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1620271252,"objectID":"e482788cb65e1b4e506f51194c4c997e","permalink":"https://tgc54.com/zh/post/cover_edges_with_path_of_length_two/","publishdate":"2021-05-05T23:20:52-04:00","relpermalink":"/zh/post/cover_edges_with_path_of_length_two/","section":"post","summary":"è²Œä¼¼è¿˜æŒºç»å…¸çš„ä¸€ä¸ªé—®é¢˜\n","tags":["DFS","å›¾è®º"],"title":"ç”¨é•¿ä¸º2çš„è·¯å¾„è¦†ç›–æ‰€æœ‰è¾¹","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"æ€»ç»“ä¸€äº›å¸¸è§çš„æ•°å­¦æ¨¡å‹ã€‚\nå°†ç›´çº¿ä¸Šå¤šä¸ªç‚¹ç§»åŠ¨åˆ°ä¸€ä¸ªç‚¹çš„æœ€å°è·ç¦» ç§»åŠ¨åˆ°æœ€ä¸­é—´çš„é‚£ä¸ªç‚¹è·ç¦»æœ€å°ï¼Œæˆ–è€…è¯´æ˜¯ç§»åŠ¨åˆ°ä¸€ç‚¹ä½¿å¾—ä¸¤ä¾§çš„ç‚¹ä¸€æ ·å¤šã€‚\nå°†ç›´çº¿ä¸Šå¤šä¸ªç‚¹ç§»åŠ¨åˆ°è¿ç»­çš„ä½ç½® å‡è®¾èµ·ç‚¹ä¸º$a$, ä¹Ÿå°±æ˜¯è¯´æœ€å°åŒ–$\\sum_i|x_i-(a+i)|=\\sum_i|(x_i+i)-a|$, äºæ˜¯é—®é¢˜åˆè½¬åŒ–æˆäº†å°†åæ ‡ä¸º$x_i-i$çš„ç‚¹ç§»åŠ¨åˆ°ä¸€ç‚¹çš„é—®é¢˜ï¼Œå–ä¸­é—´çš„åæ ‡å³å¯ã€‚\nChicken McNugget Theorem å‡è®¾$n, m$äº’è´¨ï¼Œæœ€å¤§çš„ä¸èƒ½è¢«è¡¨ç¤ºä¸º$an+bm, a, b\\ge 0$çš„æ•°æ˜¯$nm-m-n$.\nsource\næœ€å°åŒ–ä¸€ç‚¹åˆ°å…¶ä»–ç‚¹è·ç¦»çš„å¹³æ–¹çš„å’Œ ç”±äº$dis^2=x^2+y^2$ï¼Œè€Œxå’Œyå¯ä»¥ç‹¬ç«‹æ”¹å˜ï¼Œæ‰€ä»¥å¯ä»¥åˆ†åˆ«æœ€å°åŒ–ä¸¤ä¸ªåæ ‡è½´çš„è·ç¦»ï¼Œä¹Ÿå°±æ˜¯åæ ‡çš„å¹³å‡æ•°ã€‚\n","date":1620268462,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1620268462,"objectID":"9d013ca677855a7a700077e82adf6e2d","permalink":"https://tgc54.com/zh/post/math_model/","publishdate":"2021-05-05T22:34:22-04:00","relpermalink":"/zh/post/math_model/","section":"post","summary":"æ€»ç»“ä¸€äº›å¸¸è§çš„æ•°å­¦æ¨¡å‹ã€‚\n","tags":["æ•°å­¦"],"title":"ä¸€äº›æ•°å­¦æ¨¡å‹","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ç®—æ˜¯æœ‰æ‰€è¿›æ­¥ä½†è¿˜æ˜¯ç¨æœ‰é—æ†¾ï¼Œå·®ä¸€é¢˜å°±èƒ½è¿›division championships.\næ›´æ–°ï¼šæ‰€æœ‰7é¢˜é˜Ÿéƒ½ä»¥wildcardçš„èº«ä»½æ™‹çº§NADCäº†ï¼Œè€Œä¸”å¦‚æœæœ¬å­¦æ ¡åªæœ‰wildcardé˜Ÿçš„è¯ï¼Œä¼šè¢«åˆ†åˆ°æœ€å¼±çš„central divisionï¼Œç„¶åæˆ‘ä»¬åˆè«åå…¶å¦™çš„æ‹¿äº†ä¸ªç¬¬6ï¼Œæ™‹çº§NACäº†ğŸ˜‚\næ¯”èµ›è¿‡ç¨‹ ä¸¤ä¸ªé˜Ÿå‹ä¸€ä¸ªç®€ç§°Tï¼Œä¸€ä¸ªç®€ç§°Jã€‚\nå¼€åœºæˆ‘ä»å‰å¾€åè¯»ï¼ŒAæ¯”è¾ƒé•¿å°±ç›´æ¥è·³è¿‡äº†ï¼Œè¯»äº†Bæ„Ÿè§‰æœ‰ç‚¹æƒ³æ³•ä½†åˆä¸æ˜¯å¾ˆç¡®å®šå°±æ¥ç€è¯»ï¼ŒCå¾ˆæ˜æ˜¾æ˜¯ä¸ªæ‰¾æœ€å¤§ç¯ï¼Œä¸€å¼€å§‹è¿˜è§‰å¾—æ¯”è¾ƒéº»çƒ¦ï¼Œä½†æƒ³æƒ³ä¸æ˜¯ç¯å°±æ˜¯é“¾æ‰€ä»¥ç›´æ¥dfså°±è¡Œäº†ã€‚åŒæ—¶é˜Ÿå‹Jè¯»åˆ°Eå‘ç°å°±æ˜¯ä¸ªçŸ©é˜µä¹˜æ³•äºæ˜¯å¼€å§‹å†™ï¼Œæˆ‘åˆè·Ÿæ¦œåšäº†Gã€‚ä¹‹åä¸ä¹…é˜Ÿå‹Jçš„Eä¹Ÿè¿‡äº†ã€‚å¦ä¸€ä¸ªé˜Ÿå‹Tè¯»äº†Hæ˜¯è´ªå¿ƒä½†ä¸ä¼šå†™ï¼Œæˆ‘æ­¤æ—¶åœ¨å†™Bçš„æš´åŠ›ï¼ˆä½†å…¶å®ç¨å¾®æƒ³æƒ³æš´åŠ›è‚¯å®šè¶…æ—¶ä½†ä¸çŸ¥é“ä¸ºå•¥è¿˜æ˜¯å†™å®Œäº†ï¼‰ã€‚Bæš´åŠ›å†™å®Œæ‰å‘ç°ä¼šè¶…æ—¶ï¼Œæ­¤æ—¶Hè¿˜æ²¡åšå‡ºæ¥ï¼Œæˆ‘çœ‹äº†ä¸€çœ¼ä¹Ÿæ²¡æƒ³æ³•ï¼Œå°±æ‰”ç»™é˜Ÿå‹Jäº†ã€‚ç„¶åå‘ç°Bå¥½åƒå¯ä»¥dpï¼Œç„¶åå°±ä¸€è¾¹æƒ³ä¸€è¾¹å†™ï¼Œè™½ç„¶æœ‰ç‚¹æ¶å¿ƒä½†æŒºç›´æ¥çš„ï¼Œæœ€åä¸€éè¿‡ã€‚å†™Bçš„è¿‡ç¨‹ä¸­é˜Ÿå‹Jè¿‡äº†Hï¼Œç®—æ˜¯ç­¾å®Œåˆ°äº†ã€‚æ­¤æ—¶æ‰ä¸€ä¸ªåŠå°æ—¶ï¼Œæ„Ÿè§‰éå¸¸å¥½ï¼Œæ¯”å»å¹´é¡ºåˆ©å¤šäº†ã€‚\nç„¶åæˆ‘åœ¨åšKï¼Œæ„Ÿè§‰æ˜¯dpï¼Œæœ‰ç‚¹æ€è·¯ä½†ä¸ä¼šå†™ï¼Œé˜Ÿå‹Jåœ¨åšJï¼Œè¿‡äº†æ ·ä¾‹ä½†æ˜¯WAï¼Œé˜Ÿå‹Tç›´æ¥å¼€Iäº†ï¼ˆå…¶å®æ˜¯æœ€éš¾çš„é¢˜orzï¼‰ã€‚äºæ˜¯ä¸‰ä¸ªäººéƒ½å¡é¢˜äº†ï¼Œä¸çŸ¥ä¸è§‰è¿‡äº†ä¸€ä¸ªåŠå°æ—¶æˆ‘ç»ˆäºæ”¾å¼ƒäº†ï¼Œæ­¤æ—¶Jé¢˜è¿‡äº†ä¸€å¤§å †ï¼Œäºæ˜¯æˆ‘å°±è·Ÿé˜Ÿå‹Jæ¢äº†ä¸€ä¸‹é¢˜ï¼Œç”±äºé˜Ÿå‹Jç”¨çš„pythonè€Œæˆ‘åˆæ‡’çš„çœ‹æ‰€ä»¥å°±å‡†å¤‡é‡å†™ï¼Œç„¶åæ²¡æƒ³åˆ°æ˜¯ä¸ªè¶…çº§æ¶å¿ƒæ¨¡æ‹Ÿé¢˜ï¼Œè€Œä¸”å†™äº†ä¸€å †bugï¼Œç¦»ç»“æŸè¿˜æœ‰åŠå°æ—¶å’Œé˜Ÿå‹Jå‡ ä¹åŒæ—¶è¿‡äº†Jå’ŒKã€‚ç„¶åä»”ç»†ä¸€çœ‹Aå‘ç°å¾ˆç®€å•ä½†è¾“å‡ºæ ¼å¼å¾ˆæ¶å¿ƒï¼Œæœ€åè™½ç„¶å‹‰å¼ºå†™å®Œä½†æ²¡æ—¶é—´debugï¼Œä»¥7é¢˜æ”¶åœºã€‚\nåæ€ å¡é¢˜å¤ªä¹…æ²¡æœ‰åŠæ—¶æ”¾å¼ƒï¼Œå“ªæ€•å»è¯»è¯»åˆ«çš„é¢˜ã€‚é¢˜æ²¡æœ‰éƒ½è¯»ä¸€éï¼Œé˜Ÿå‹Jå…¶å®è¯»äº†Aä½†æ„Ÿè§‰å¾ˆéº»çƒ¦ï¼Œä½†æˆ‘æ„Ÿè§‰æ¯”Jå¥½åšå¤šäº†ï¼ˆå¯èƒ½æˆ‘Jå†™çš„å¤ªçƒ‚äº†ï¼‰ã€‚Låˆ°æœ€åä¹Ÿæ²¡äººè¯»ï¼Œå…¶å®ä¹Ÿä¸éš¾ï¼Œå°±æ˜¯ä¸ªäºŒåˆ†å›¾åŒ¹é…çš„æ¿å­ é¢˜ã€‚æ‰€ä»¥è¯´ä¹Ÿä¸èƒ½ä¸€å‘³çš„è·Ÿæ¦œï¼Œæ¯•ç«Ÿæ¯ä¸ªäººçš„çŸ¥è¯†ç‚¹è¦†ç›–ä¸ä¸€æ ·ã€‚ä½†Kå¡åŠå¤©æ²¡åšå‡ºæ¥ä¹Ÿä¸åº”è¯¥ã€‚\né¢˜è§£ A æ•°æ®å¾ˆå°ï¼Œæ‰¾lcaç›´æ¥æš´åŠ›ç½‘ä¸Šè·³ä¹Ÿå¯ä»¥ã€‚è¾“å‡ºæ ¼å¼æ¯”è¾ƒæ¶å¿ƒï¼Œè¦å¤šçœ‹å‡ éï¼Œæ³¨æ„ä¸è¦æŠŠ11th, 12th, 13thè¾“å‡ºæˆ 11st, 12nd, 13rdã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, T; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;T; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; a(n); vector\u0026lt;string\u0026gt; name(n); unordered_map\u0026lt;string, int\u0026gt; id; for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;name[i]; id.try_emplace(name[i], id.size()); int x; cin\u0026gt;\u0026gt;x; a[i].resize(x); for (auto\u0026amp; s : a[i]) { cin\u0026gt;\u0026gt;s; id.try_emplace(s, id.size()); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(id.size()); vector\u0026lt;int\u0026gt; ind(id.size()); for (int i=0; i\u0026lt;n; i++) { int u=id[name[i]]; for (auto\u0026amp; s : a[i]) { g[u].push_back(id[s]); ind[id[s]]++; } } vector\u0026lt;int\u0026gt; pa(id.size()); vector\u0026lt;int\u0026gt; dep(id.size()); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { pa[u] = p; for (auto v : g[u]) { if (v == p) continue; dep[v]=dep[u]+1; dfs(dfs, v, u); } }; auto lca=[\u0026amp;](int x, int y) { while (x!=y) { if (dep[x]\u0026lt;dep[y]) swap(x, y); x=pa[x]; } return x; }; for (int i=0; i\u0026lt;id.size(); i++) { if (ind[i]==0) { dfs(dfs, i, i); break; } } auto ordinal=[](int x) { auto s=to_string(x); if (x\u0026gt;=11 \u0026amp;\u0026amp; x\u0026lt;=13) return s+\u0026#34;th\u0026#34;; if (x%10==1) return s+\u0026#34;st\u0026#34;; if (x%10==2) return s+\u0026#34;nd\u0026#34;; if (x%10==3) return s+\u0026#34;rd\u0026#34;; return s+\u0026#34;th\u0026#34;; }; while (T--) { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int l=lca(id[s], id[t]); int m=dep[id[s]]-dep[l]; int n=dep[id[t]]-dep[l]; int swaped=0; if (m\u0026gt;n) { swap(m, n); swaped=1; swap(s, t); } if (m==0) { swap(s, t); if (n==1) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the child of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { n-=2; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the \u0026#34;; for (int i=0; i\u0026lt;n; i++) cout\u0026lt;\u0026lt;\u0026#34;great \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;grandchild of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else if (m==n \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are siblings\\n\u0026#34;; else { n--; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(n)\u0026lt;\u0026lt;\u0026#34; cousins\\n\u0026#34;; } } else if (n\u0026gt;m \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n-m==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt; ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, 1 time removed\\n\u0026#34;; else cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, \u0026#34;\u0026lt;\u0026lt;n-m\u0026lt;\u0026lt;\u0026#34; times removed\\n\u0026#34;; } } return 0; } B dp[x][y][i][used][d] ä»£è¡¨æ˜¯å¦å­˜åœ¨ä»¥åæ ‡ $(x, y)$ çš„å­—ç¬¦ç»“å°¾ï¼Œè¦†ç›–ç›®æ ‡å­—ç¬¦ä¸²çš„å‰iä¸ªå­—ç¬¦ï¼Œè½¬å‘usedæ¬¡ï¼Œç»“æŸæ—¶çš„æ–¹å‘æ˜¯dçš„èµ°æ³•ã€‚æ³¨æ„é•¿åº¦ä¸º$i$çš„å­—ç¬¦ä¸²æœ€å¤šè½¬$i-1$æ¬¡ï¼Œè™½ç„¶ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯æ²¡æœ‰æ–¹å‘çš„ï¼Œä½†ä¸ºäº†è½¬ç§»æ–¹ä¾¿å°±å˜æˆäº†æ‰€æœ‰æ–¹å‘ï¼Œæ‰€ä»¥æšä¸¾è½¬å‘æ¬¡æ•°çš„è¯è¦é™åˆ¶ä¸€ä¸‹ï¼Œä¸ç„¶ä¼šå‡ºç°é•¿åº¦ä¸º2è½¬ä¸¤æ¬¡çš„èµ°æ³•ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int dp[10][10][105][105][8]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector a(n, vector\u0026lt;char\u0026gt;(m)); for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { cin\u0026gt;\u0026gt;a[i][j]; } } int limit; string s; cin\u0026gt;\u0026gt;limit\u0026gt;\u0026gt;s; limit=min(limit, int(s.size())); const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { if (a[i][j]==s[0]) { for (int d=0; d\u0026lt;8; d++) dp[i][j][0][0][d]=1; } } } for (int i=1; i\u0026lt;s.size(); i++) { for (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (a[x][y]!=s[i]) continue; for (int used=0; used\u0026lt;=min(limit, i-1); used++) { for (int d=0; d\u0026lt;8; d++) { for (int pd=0; pd\u0026lt;8; pd++) { auto [dx, dy]=dirs[d]; unsigned nx=x+dx, ny=y+dy; int pused=used-(d!=pd); // if (i==1) pused=0; if (nx\u0026lt;n \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; pused\u0026gt;=0 \u0026amp;\u0026amp; dp[nx][ny][i-1][pused][pd]) { dp[x][y][i][used][d]=1; } } } } } } } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { for (int d=0; d\u0026lt;8; d++) if (dp[i][j][s.size()-1][limit][d]) return cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;, 0; } } cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;; return 0; } C ç”±äºæ¯ä¸ªç‰©å“æœ€å¤šåªæœ‰ä¸€ä¸ªäººè¦ï¼Œæ‰€ä»¥æ¯ä¸ªç‚¹çš„å‡ºåº¦æœ€å¤šä¸º1ï¼Œæ‰€ä»¥æ¯ä¸ªè¿é€šåˆ†é‡è¦ä¹ˆæ˜¯ç¯è¦ä¹ˆæ˜¯é“¾ã€‚ç›´æ¥dfså³å¯ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int â€¦","date":1615334400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615334400,"objectID":"25ae9bc17f82f59017c87481689ebc1d","permalink":"https://tgc54.com/zh/post/2020_icpc_ecna/","publishdate":"2021-03-10T00:00:00Z","relpermalink":"/zh/post/2020_icpc_ecna/","section":"post","summary":"ç®—æ˜¯æœ‰æ‰€è¿›æ­¥ä½†è¿˜æ˜¯ç¨æœ‰é—æ†¾ï¼Œå·®ä¸€é¢˜å°±èƒ½è¿›division championships.\næ›´æ–°ï¼šæ‰€æœ‰7é¢˜é˜Ÿéƒ½ä»¥wildcardçš„èº«ä»½æ™‹çº§NADCäº†ï¼Œè€Œä¸”å¦‚æœæœ¬å­¦æ ¡åªæœ‰wildcardé˜Ÿçš„è¯ï¼Œä¼šè¢«åˆ†åˆ°æœ€å¼±çš„central divisionï¼Œç„¶åæˆ‘ä»¬åˆè«åå…¶å¦™çš„æ‹¿äº†ä¸ªç¬¬6ï¼Œæ™‹çº§NACäº†ğŸ˜‚\n","tags":["Contests"],"title":"2020 ICPC East Central NA Regional Contest æ€»ç»“ä¸é¢˜è§£","type":"post"},{"authors":null,"categories":["æ¯”èµ›é¢˜è§£"],"content":"å®˜æ–¹è‹±æ–‡é¢˜è§£\nA. Bitwise ä»é«˜ä½å¾€ä½ä½è´ªå¿ƒï¼Œå†™ä¸€ä¸ªå‡½æ•°åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°xã€‚\nå¦‚ä½•åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°xï¼Ÿä¾ç„¶æ˜¯è´ªå¿ƒçš„æ€è·¯ï¼Œæˆ‘ä»¬ä»æŸä¸€ä½å¼€å§‹ï¼Œè®°å½•å½“å‰çš„æˆ–å€¼ï¼Œå¦‚æœå¤§äºxå°±å¼€å§‹æ–°çš„ä¸€å—ã€‚ä½†å¦‚æœä»æ¯ä¸ªæ•°éƒ½å¼€å§‹è¯•ä¸€éçš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$ã€‚ä½†æ˜¯æˆ‘ä»¬å‘ç°æ¯ä¸ªå—çš„ç»“æŸä½ç½®ä¸€å®šæ˜¯æŸä¸€ä½å˜æˆ1çš„ä½ç½®ï¼Œæ‰€ä»¥è¯´å¼€å§‹çš„ä½ç½®å…¶å®å¹¶ä¸é‡è¦ï¼Œæœ€å¤šåªä¼šå°‘ç®—ä¸€ä¸ªéƒ¨åˆ†ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬éå†ä¸¤åœˆï¼Œå¦‚æœè‡³å°‘æœ‰$2k-1$ä¸ªå—çš„è¯å°±è¯´æ˜xæ˜¯å¯è¡Œçš„ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n*2); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i+n]=a[i]; } auto can=[\u0026amp;](int x) -\u0026gt; bool { int cnt=0, cur=0; for (int i=0; i\u0026lt;2*n; i++) { cur|=a[i]; if ((cur\u0026amp;x)==x) { cnt++; cur=0; } } return cnt\u0026gt;=2*k-1; }; int ans=0; for (int bit=31; bit\u0026gt;=0; bit--) { if (can(ans|(1\u0026lt;\u0026lt;bit))) ans|=(1\u0026lt;\u0026lt;bit); } cout\u0026lt;\u0026lt;ans; return 0; } B. Conveyor Belts æˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªç‚¹æ‹†æˆ$K$ä¸ªç‚¹ï¼Œç¬¬$i$ä¸ªç‚¹ä»£è¡¨ç¬¬$t\\bmod K$æ—¶åˆ»ã€‚åŸå›¾ä¸­a -\u0026gt; bçš„è¾¹æ‹†å®Œä¹‹åå°±å˜æˆäº†açš„ç¬¬$i$æ—¶åˆ»è¿åˆ°bçš„ç¬¬$(i+1)\\bmod K$æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚è¿™æ ·å°±ä¿è¯äº†æ¯æ—¶åˆ»æ¯æ¡ä¼ é€å¸¦ä¸Šåªæœ‰ä¸€ä¸ªç‰©å“ã€‚ç„¶åæ·»åŠ ä¸€ä¸ªè¶…çº§æºç‚¹ï¼Œè¿åˆ°ç¬¬$i$ä¸ªproducerçš„ç¬¬$i$æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚æœ€åä»ç¬¬$N$ä¸ªç‚¹çš„æ¯ä¸€ä¸ªæ—¶åˆ»è¿åˆ°ä¸€ä¸ªè¶…çº§æ±‡ç‚¹ï¼Œå®¹é‡ä¸ºæ— ç©·å¤§ã€‚ç„¶åè·‘ä¸ªæœ€å¤§æµå°±è¡Œäº†ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} // indexed from 0! struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } int maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; Flow mf(n*k+2); for (int i=0; i\u0026lt;m; i++) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; for (int j=0; j\u0026lt;k; j++) { mf.addEdge(x*k+j, y*k+(j+1)%k, 1); } } for (int i=0; i\u0026lt;k; i++) mf.addEdge(n*k, i*k+i, 1); for (int i=0; i\u0026lt;k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9); cout\u0026lt;\u0026lt;mf.maxFlow(n*k, n*k+1); return 0; } C. Free Food æš´åŠ›æ ‡è®°æ¯ä¸€å¤©å³å¯\nD. Hoppers å¦‚æœæœ‰é•¿åº¦ä¸ºå¥‡æ•°çš„ç¯çš„è¯å¹¶ä¸”æ•´ä¸ªç½‘ç»œè¿é€šå°±èƒ½ä¼ æ’­åˆ°æ•´ä¸ªç½‘ç»œã€‚æ‰€ä»¥åªå°‘æ£€æŸ¥æ¯ä¸ªè¿é€šåˆ†é‡æ˜¯ä¸æ˜¯äºŒåˆ†å›¾å¹¶è®¡ç®—è¿é€šåˆ†é‡çš„ä¸ªæ•°å°±è¡Œäº†ã€‚\né˜Ÿå‹å†™çš„æ‰€ä»¥æ²¡æœ‰ä»£ç QAQ\nE. Largest Triangle è¿™é¢˜è¿‡äºç»å…¸ï¼Œç½‘ä¸Šåº”è¯¥æœ‰å¾ˆå¤šé¢˜è§£ã€‚\nG. Non-Prime Factors å…ˆé¢„å¤„ç†ç­”æ¡ˆï¼Œç±»ä¼¼ç­›æ³•çš„æ€è·¯ï¼šå¦‚æœä¸æ˜¯è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬çš„ç­”æ¡ˆåŠ 1,è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬æ ‡è®°æˆåˆæ•°ã€‚$O(1)$è¾“å‡ºè¯¢é—®å³å¯ã€‚å¿«è¯»è²Œä¼¼ä¸æ˜¯å¾ˆæœ‰å¿…è¦ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} namespace IO { const int MAXSIZE = 1 \u0026lt;\u0026lt; 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u0026lt;\u0026lt; 20], *pp = pbuf; inline void push(const char \u0026amp;c) { if (pp - pbuf == 1 \u0026lt;\u0026lt; 20) fwrite(pbuf, 1, 1 \u0026lt;\u0026lt; 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + \u0026#39;0\u0026#39;); } } // const int N=2e6; int ans[N+1]; bool not_prime[N+1]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q=IO::rd(); for (int i=2; i\u0026lt;=N; i++) { if (!not_prime[i]) { for (int j=i+i; j\u0026lt;=N; j+=i) not_prime[j]=1; } else { for (int j=i; j\u0026lt;=N; j+=i) { ans[j]++; } } } while (q--) { int x=IO::rd(); printf(\u0026#34;%d\\n\u0026#34;, ans[x]+1); } return 0; } J. SG Coin å…¶å®å°±æ˜¯ä¸ªå–æ¨¡ä¸‹çš„å‡æ³•ã€‚ã€‚ã€‚\nL. Wi Know é¦–å…ˆæˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼šå¯¹äº$i\u0026lt;j\u0026lt;k, S_i=S_j=S_k$ï¼Œ$(S_i, S_k)$ä¸€å®šä¸å·®äº$(S_j, S_k)$ã€‚æ‰€ä»¥åœ¨$A, B, A, B$ ä¸­ç¬¬ä¸€ä¸ªAæˆ‘ä»¬ä¸€å®šé€‰åœ¨$S$ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„Aã€‚åŒç†ï¼Œç¬¬äºŒä¸ªBä¸€å®šé€‰$S$ä¸­æœ€åä¸€å‡ºç°çš„Bã€‚\nè§£æ³•çš„å¤§è‡´æ€è·¯å°±æ˜¯å›ºå®šBæ‰¾æœ€å°çš„Aã€‚ä¸€ç§æ¯”è¾ƒnaiveçš„æ€è·¯æ˜¯åœ¨$[i+1, last_i-1]$ä¸­æŸ¥è¯¢æœ€å°å€¼ï¼Œä½†æœ‰ä¸¤ä¸ªé—®é¢˜ï¼š\nä¸çŸ¥é“æœ€å°å€¼åœ¨$i$ä¹‹å‰æœ‰æ²¡æœ‰å‡ºç°è¿‡ã€‚ æœ€å°å€¼å¯èƒ½ç­‰äº$S_i$ã€‚ æ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ä¸€æ¬¡æŠŠæ‰€æœ‰çš„æ•°éƒ½æ”¾åˆ°çº¿æ®µæ ‘é‡Œï¼Œè¦æŒ‰ä¸€å®šçš„é¡ºåºæ”¾ã€‚å¯¹äºæ¯ä¸ªä½ç½®$i$ï¼Œæˆ‘ä»¬è®°å½•ä¸€ä¸ª$nxt_i$ä¸º$S_i$çš„ä¸‹ä¸€ä¸ªå‡ºç°ä½ç½®ã€‚ç„¶åæˆ‘ä»¬éå†$S$ï¼Œé¦–å…ˆæŸ¥è¯¢$[i+1, last_i-1]$ä¸­çš„æœ€å°å€¼minï¼Œç„¶åç”¨{min, S[i]}æ›´æ–°ç­”æ¡ˆï¼Œæœ€ååœ¨çº¿æ®µæ ‘ä¸­æŠŠ$next_i$è®¾ä¸º$S_i$ã€‚\nè¿™æ ·ä¸ºä»€ä¹ˆé¿å…äº†ä¸Šé¢çš„ä¸¤ä¸ªé—®é¢˜å‘¢ï¼Ÿé¦–å…ˆï¼Œåªæœ‰åœ¨$i$ä¹‹å‰å‡ºç°è¿‡çš„æ•°æ‰ä¼šè¢«åŠ è¿›å»ï¼Œé¿å…äº†é—®é¢˜1ï¼Œç„¶åæˆ‘ä»¬æ˜¯å…ˆæŸ¥è¯¢å†æ·»åŠ ï¼Œè€Œä¸”ä¸€æ¬¡åªåŠ ä¸€ä¸ªï¼Œè¿™æ ·å°±é¿å…é—®é¢˜2ã€‚æ€»ä¹‹è¿™ä¸ªè§£æ³•è¿˜æ˜¯å¾ˆå¦™çš„ï¼Œæ¯”å®˜æ–¹é¢˜è§£ç®€å•ä¸å°‘ã€‚\n#include â€¦","date":1612656e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1612656e3,"objectID":"049cc2a6ab8357a44d2809315fec7faf","permalink":"https://tgc54.com/zh/post/2018_icpc_singapore/","publishdate":"2021-02-07T00:00:00Z","relpermalink":"/zh/post/2018_icpc_singapore/","section":"post","summary":"å®˜æ–¹è‹±æ–‡é¢˜è§£\n","tags":null,"title":"é¢˜è§£ 2018 ICPC Asia Singapore Regional Contest","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ„Ÿè§‰æŒºå¥—è·¯çš„ï¼Œä½†å½“æ—¶å¤ªèœäº†ä¸ä¼šåšï¼Œæ˜¯é“ä¸é”™çš„é¢˜\nSolution For brevity, letâ€™s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, thereâ€™s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if Iâ€™m wrong).\né¢˜è§£ é¦–å…ˆå…ˆç®—å‡ºæŠŠæ¯ä¸€ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸º$j$çš„ä½ç½®çš„èŠ±è´¹ï¼Œç„¶åéå† $5!$ ç§ç›¸å¯¹ä½ç½®é¡ºåºï¼Œç„¶åè®°å½•æŠŠå‰$i$ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸º$j$çš„ä½ç½®çš„èŠ±è´¹ã€‚ å…·ä½“è½¬ç§»å…¬å¼çœ‹ä¸Šé¢å§ï¼Œæ‡’å¾—å¤åˆ¶äº†QAQ.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } ","date":1611446400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1611446400,"objectID":"987abba7bafb7b8c5818afa5c5dc0c6e","permalink":"https://tgc54.com/zh/post/2019_ecna_k/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"/zh/post/2019_ecna_k/","section":"post","summary":"æ„Ÿè§‰æŒºå¥—è·¯çš„ï¼Œä½†å½“æ—¶å¤ªèœäº†ä¸ä¼šåšï¼Œæ˜¯é“ä¸é”™çš„é¢˜\n","tags":["åŠ¨æ€è§„åˆ’"],"title":"é¢˜è§£ 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å•è°ƒæ ˆå¥½é¢˜ï¼Œéå¸¸ç‹¬ç‰¹çš„è§†è§’ã€‚\né¢˜è§£ æ ˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ {x,i}ä»£è¡¨çš„æ˜¯ä¸€ç»„è¿ç»­çš„å¤šç±³è¯ºï¼Œä½¿å¾—å¦‚æœæˆ‘ä»¬å¦‚æœæ¨å€’xå¤„çš„å¤šç±³è¯ºï¼Œä»ç¬¬iä¸ªå¼€å§‹ä¸€ç›´åˆ°ä¸‹ä¸€ç»„çš„å¤šç±³è¯ºéƒ½ä¼šè¢«æ¨æ‰ã€‚æ‰€ä»¥æˆ‘ä»¬å¤„ç†æ–°çš„å¤šç±³è¯ºçš„æ—¶å€™ï¼Œè¦å…ˆæŠŠå½“å‰å¤šç±³è¯ºå¤Ÿå¾—åˆ°çš„å¤šç±³è¯ºç»„å¼¹å‡ºï¼Œæœ€åæ ˆé¡¶çš„å…ƒç´ å°±æ˜¯æœ€è¿‘çš„å¤Ÿä¸ç€çš„å¤šç±³è¯ºï¼Œä¹Ÿå°±æ˜¯å½“å‰å¤šç±³è¯ºçš„ç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1593907200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1593907200,"objectID":"a35e030634c807593b88852b9ed18d36","permalink":"https://tgc54.com/zh/post/cf56e/","publishdate":"2020-07-05T00:00:00Z","relpermalink":"/zh/post/cf56e/","section":"post","summary":"å•è°ƒæ ˆå¥½é¢˜ï¼Œéå¸¸ç‹¬ç‰¹çš„è§†è§’ã€‚\n","tags":["æ•°æ®ç»“æ„","å•è°ƒæ ˆ"],"title":"é¢˜è§£ Codeforces 56E - Domino Principle","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"éå¸¸å¥½çš„å­¦ä¹ dpçš„æ¯”èµ›ã€‚\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThereâ€™s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define sz(x) int(x.size()) using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0,â€‰1,â€‰\\dots ,â€‰iâ€‰-â€‰1$ such that the last element is j and all the first iâ€‰-â€‰1 inequalities are fulfilled.\nTransition is:\nif(s[i]==\u0026#39;\u0026gt;\u0026#39;) $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; â€¦","date":1593561600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1593561600,"objectID":"78556d54e3455cc33b74e1666fa9447e","permalink":"https://tgc54.com/zh/post/abc_dp/","publishdate":"2020-07-01T00:00:00Z","relpermalink":"/zh/post/abc_dp/","section":"post","summary":"éå¸¸å¥½çš„å­¦ä¹ dpçš„æ¯”èµ›ã€‚\n","tags":["åŠ¨æ€è§„åˆ’"],"title":"éƒ¨åˆ†é¢˜è§£ Atcoder Educational DP Contest","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"è´ªå°±å®Œäº‹äº†\né¢˜è§£ é¦–å…ˆå…ˆç®—å‡º$s_i$ï¼šå–œæ¬¢é£Ÿç‰©$i$çš„äººçš„ä¸ªæ•°ã€‚å¯¹äºé£Ÿç‰©$i$ï¼Œå¦‚æœ$s_i\\leq w_i$ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºè¿™äº›äººæ— è®ºä½ ä»¥ä»€ä¹ˆé¡ºåºå«ä»–ä»¬éƒ½æœ‰é£Ÿç‰©åƒã€‚æ‰€ä»¥æˆ‘ä»¬å°½å¯èƒ½çš„æ™šå«ä»–ä»¬ã€‚\næ•´ä¸ªè¿‡ç¨‹æœ‰ç‚¹åƒæ‹“æ‰‘æ’åºæˆ–è€…è¯´æ˜¯BFSï¼šä»æ‰€æœ‰æ»¡è¶³$s_i\\leq w_i$çš„ç‚¹å¼€å§‹ï¼Œå½“è®¿é—®æ–°çš„ç‚¹uæ—¶ï¼Œ$s_u$å‡1ï¼Œå¦‚æœ$s_u\\leq w_u$çš„è¯ï¼Œå°±æŠŠuåŠ è¿›é˜Ÿåˆ—å¹¶æŠŠuåŠ åˆ°å«äººçš„åå•é‡Œã€‚æœ€ååè½¬åå•å°±å¾—åˆ°ç­”æ¡ˆäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1592956800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1592956800,"objectID":"06c0bf802608ee040079f6ad5de8c651","permalink":"https://tgc54.com/zh/post/cf1369e/","publishdate":"2020-06-24T00:00:00Z","relpermalink":"/zh/post/cf1369e/","section":"post","summary":"è´ªå°±å®Œäº‹äº†\n","tags":["BFS","è´ªå¿ƒ"],"title":"é¢˜è§£Codeforces 1369E - DeadLee","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ€è€ƒçš„è§’åº¦å¾ˆå¦™\né¢˜è§£ ç­”æ¡ˆçš„ä¸ªæ•°ç­‰äºæœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸º$|S|+K$çš„å­—ç¬¦ä¸²$T$ä½¿å¾—$S$æ˜¯ä»–çš„ä¸€ä¸ªå­åºåˆ—ã€‚\nè®¾$S_i$åœ¨$T$ä¸­çš„ä¸‹æ ‡ä¸º$a_1,a_2,\\dots,a_{|S|}$ã€‚ ä¸ºäº†é¿å…é‡å¤ï¼Œæˆ‘ä»¬åœ¨æ‰€æœ‰å¯èƒ½çš„$a+i$ä¸­å–æœ€å°çš„ã€‚ä¸éš¾çœ‹å‡ºï¼Œ$a_i$å’Œ$a_{i+1}$ä¹‹é—´çš„å­—ç¬¦æœ‰25ç§é€‰æ‹©ï¼Œ$a_{|S|}$ä¹‹åçš„æœ‰26ç§å¯èƒ½ã€‚\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥æšä¸¾$a_{|S|}$ä¹‹åçš„å­—ç¬¦çš„ä¸ªæ•°ï¼Œè¿™æ ·åœ¨å­—ç¬¦é€‰æ‹©æ–¹é¢æˆ‘ä»¬æœ‰$25^{K-x}\\cdot 26^x$ç§å¯èƒ½ã€‚ç„¶åå†è€ƒè™‘å¦‚ä½•åˆ†é…$K-x$ä¸ªå­—ç¬¦ï¼Œæ ¹æ®æ’æ¿æ¨¡å‹ï¼Œæˆ‘ä»¬æœ‰${|S|-1+k-x \\choose |S|-1}$ç§æ–¹å¼ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸ªxï¼Œç­”æ¡ˆå¢åŠ $25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592870400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1592870400,"objectID":"a11771ffea2607bdd412a57ba223c74f","permalink":"https://tgc54.com/zh/post/abc171f/","publishdate":"2020-06-23T00:00:00Z","relpermalink":"/zh/post/abc171f/","section":"post","summary":"æ€è€ƒçš„è§’åº¦å¾ˆå¦™\n","tags":["ç»„åˆå­¦"],"title":"é¢˜è§£ Atcoder Beginner Contest 171F - Strivore","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æœ‰æ—¶å€™åŒæŒ‡é’ˆä¼šå¾ˆç®€å•\né¢˜è§£ ä¸éš¾çœ‹å‡ºæ‰€æœ‰æ‰“å¼€çš„å›¾ç‰‡æ˜¯æ‰€æœ‰å›¾ç‰‡çš„ä¸€ä¸ªå­æ®µã€‚æˆ‘ä»¬å¯ä»¥æšä¸¾æ‰€æœ‰å·¦ç«¯ç‚¹ç„¶åç”¨åŒæŒ‡é’ˆæ‰¾åˆ°æœ€å³çš„ç«¯ç‚¹ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592784e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1592784e3,"objectID":"3b5824e80415765cbc5357e44b562370","permalink":"https://tgc54.com/zh/post/cf650b/","publishdate":"2020-06-22T00:00:00Z","relpermalink":"/zh/post/cf650b/","section":"post","summary":"æœ‰æ—¶å€™åŒæŒ‡é’ˆä¼šå¾ˆç®€å•\n","tags":["åŒæŒ‡é’ˆ"],"title":"é¢˜è§£ Codeforces 650B/651D Image Preview","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å…¶å®å¹¶ä¸éš¾ï¼Œå®˜æ–¹é¢˜è§£ç»™çš„dpåšæ³•å¤ªå“äººäº†\né¢˜è§£ é¦–å…ˆå®šä¹‰ä¸€ä¸‹â€œæ’äº†åºçš„å­åºåˆ—â€ï¼šå®ƒæ˜¯ä¸€ä¸ªåŸæ•°ç»„çš„å­åºåˆ—å¹¶ä¸”åœ¨æ’åºä¹‹åçš„æ•°ç»„ä¸­æ˜¯ä¸€ä¸ªå­æ•°ç»„ã€‚ä¸éš¾çœ‹å‡ºæ²¡ç”¨è¢«ç§»åŠ¨è¿‡çš„å…ƒç´ ä¼šå½¢æˆä¸€ä¸ªæ’äº†åºçš„å­åºåˆ—ã€‚æ‰€ä»¥è¯´å¦‚æœæˆ‘ä»¬æ‰¾åˆ°æœ€é•¿çš„æ’äº†åºçš„å­åºåˆ—é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯æœ€å°çš„ã€‚\nå› ä¸ºæˆ‘ä»¬åªå…³æ³¨æ•°å­—çš„ç›¸å¯¹å¤§å°ï¼Œæˆ‘ä»¬å¯ä»¥å‹ç¼©ä¸€ä¸‹æ•°å­—ï¼Œè¿™æ ·å†™èµ·æ¥ä¼šç®€å•ä¸€äº›ã€‚ç„¶åæ¯ä¸ªæ•°ç»„å¼€ä¸€ä¸ªæ•°ç»„å­˜æ”¹æ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡ã€‚\nç„¶åéå†æ‰€æœ‰æ•°å­—ï¼Œå¦‚æœå½“å‰æ•°å­—çš„æœ€å°ä¸‹æ ‡å¤§äºä¹‹å‰æ•°å­—çš„æœ€å¤§ä¸‹æ ‡ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡éƒ½å¯ä»¥åŠ åˆ°å½“å‰çš„å­åºåˆ—é‡Œã€‚å¦åˆ™æˆ‘ä»¬éœ€è¦é‡æ–°å¼€å§‹ä¸€ä¸ªå­åºåˆ—ï¼Œä»¥ä¸‹ä¸¤ç‚¹éœ€è¦æ³¨æ„ï¼š\nå½“å‰æ•°å­—çš„ä¸€éƒ¨åˆ†ä¹Ÿæ˜¯å¯ä»¥è¢«åŠ åˆ°åˆšæ‰çš„å­åºåˆ—é‡Œçš„ï¼Œæ¯”å¦‚è¯´1,2,2,1,2ï¼Œç¬¬äºŒä¸ª2å°±å¯ä»¥åŠ è¿›å»å˜æˆ1,1,1,2ã€‚\nä¹‹å‰çš„æ•°çš„ä¸€éƒ¨åˆ†ä¹Ÿå¯ä»¥è¢«åŠ åˆ°æ–°çš„å­åºåˆ—é‡Œï¼Œæ¯”å¦‚1,2,2,1,2ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠç¬¬ä¸€ä¸ª1åŠ è¿›æ¥å˜æˆ1,2,2,2ã€‚\nä½†æ˜¯è¿˜æœ‰ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µï¼šè¿™ä¸ªå­åºåˆ—åªåŒ…å«ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡éƒ½æ˜¯ä¸å®Œæ•´çš„ï¼Œæ¯”å¦‚2,1,1,2,2,1ã€‚ä¸éš¾çœ‹å‡ºæˆ‘ä»¬è¦å–ç¬¬ä¸€ä¸ªæ•°çš„ä¸€ä¸ªå‰ç¼€ï¼Œå–ç¬¬äºŒä¸ªæ•°çš„ä¸€ä¸ªåç¼€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æšä¸¾å‰ç¼€çš„ä½ç½®ç„¶åæ‰¾åˆ°å¯¹åº”çš„åç¼€ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } ","date":1592438400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1592438400,"objectID":"b2500e3749bc3fde901f74ac21dcf70c","permalink":"https://tgc54.com/zh/post/cf1367f2/","publishdate":"2020-06-18T00:00:00Z","relpermalink":"/zh/post/cf1367f2/","section":"post","summary":"å…¶å®å¹¶ä¸éš¾ï¼Œå®˜æ–¹é¢˜è§£ç»™çš„dpåšæ³•å¤ªå“äººäº†\n","tags":["è´ªå¿ƒ","äºŒåˆ†"],"title":"Codeforces 1367F2 - Flying Sort (Hard Version) é¢˜è§£","type":"post"},{"authors":null,"categories":null,"content":"æ‰“ä¹±\nB U2 R2 U2 L2 B\u0026#39; D2 R2 U2 R2 F2 R B\u0026#39; U R F U2 L2 R\u0026#39; B2 è§£æ³•ï¼š\nU\u0026#39; R2\u0026#39; F\u0026#39; //cross y U\u0026#39; R\u0026#39; U R//first pair U\u0026#39; L\u0026#39; U L U2 R U\u0026#39; R\u0026#39;//second pair U2 L\u0026#39; U\u0026#39; L2 U L\u0026#39;//third pair y\u0026#39; U R U2 R\u0026#39; U2 R U\u0026#39; R\u0026#39;//fourth pair U r U R\u0026#39; U R U2 r\u0026#39;//OLL U\u0026#39; R\u0026#39; U\u0026#39; F\u0026#39; R U R\u0026#39; U\u0026#39; R\u0026#39; F R2 U\u0026#39; R\u0026#39; U\u0026#39; R U R\u0026#39; U R//PLL ","date":1591660800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1591660800,"objectID":"5646c4c779d505b199ffc6d2bee77a68","permalink":"https://tgc54.com/zh/post/33pb9.8/","publishdate":"2020-06-09T00:00:00Z","relpermalink":"/zh/post/33pb9.8/","section":"post","summary":"","tags":["é­”æ–¹"],"title":"9.80æ— è·³3é˜¶pbå¤ç›˜","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"link\né¢˜è§£ è®©æˆ‘ä»¬å…ˆå°è¯•å›ºå®šå³ç«¯ç‚¹ï¼Œç„¶åå¯¹äºæ¯ä¸ªå³ç«¯ç‚¹æ‰¾åˆ°æœ€é•¿çš„å­æ•°ç»„ã€‚\nä»¤$ pos_ {xï¼Œi} $ä¸ºç¬¬iä¸ª$x$çš„ä¸‹æ ‡ã€‚å‡è®¾å½“å‰çš„å³ç«¯ç‚¹æ˜¯$ r \\in [0ï¼Œnï¼‰$ï¼Œå¯¹äºæ¯ä¸ª$ x \\in [1ï¼ŒC] $,å·¦ç«¯ç‚¹ä¸å¯èƒ½è½åœ¨åŒºé—´$ [pos_ {xï¼Œm-k + 1 } + 1ï¼Œi] $ï¼Œå…¶ä¸­$ m $æ˜¯ç›´åˆ°$ r $ä¸ºæ­¢$ x $çš„å‡ºç°æ¬¡æ•°ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœå·¦ç«¯ç‚¹åœ¨è¿™ä¸ªåŒºé—´å†…ï¼Œåˆ™$ x $çš„å‡ºç°å°†å¤§äºé›¶ä¸”å°äº$ K $ï¼Œä¸æ»¡è¶³çº¦æŸæ¡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™äº›åŒºé—´ä¸ŠåŠ 1ï¼Œé‚£ä¹ˆæœ€å·¦çš„ç«¯ç‚¹æ˜¯å€¼ä¸º0çš„æœ€å°ä¸‹æ ‡ã€‚\nç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹å½“å³ç«¯ç‚¹ç§»è‡³$ r + 1 $æ—¶åŒºé—´å¦‚ä½•å˜åŒ–ã€‚æ˜¾è€Œæ˜“è§ï¼Œåªæœ‰$ a_ {r + 1} $çš„åŒºé—´ä¼šæ”¹å˜ã€‚ åŒºé—´å°†ä»$ [pos_ {a_ {r + 1}ï¼Œmk} + 1ï¼Œpos_ {a_ {r + 1}ï¼Œm-1}] $å˜ä¸º$ [pos_ {a_ {r + 1}ï¼Œm- k + 1} + 1ï¼Œpos_ {a_ {r + 1}ï¼Œm}] $ã€‚è¯·æ³¨æ„ï¼Œåœ¨ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸å¿…æ›´æ”¹é‡å çš„éƒ¨åˆ†ã€‚\nç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ”¯æŒåŒºé—´ä¿®æ”¹å’Œå…¨å±€æœ€å°å€¼æŸ¥è¯¢çš„æ•°æ®ç»“æ„,akaçº¿æ®µæ ‘ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1591660800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1591660800,"objectID":"5d6cd577bebac391c8dc5c6197ef5405","permalink":"https://tgc54.com/zh/post/hdu6602/","publishdate":"2020-06-09T00:00:00Z","relpermalink":"/zh/post/hdu6602/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„","çº¿æ®µæ ‘"],"title":"é¢˜è§£ HDU6602 - Longest Subarray","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å¥½å‡ å¤©æ²¡æ›´æ–°äº†\né¢˜è§£ é¦–å…ˆï¼Œå…ˆå®šä¹‰è¿™ä¸ªå‡½æ•°$f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$ï¼Œä¹Ÿå°±æ˜¯ä»$i$å¼€å§‹å¾€åè¿ç»­$k$ä¸ªæ•°çš„å’Œã€‚\nç„¶åæˆ‘ä»¬è¯æ˜å¦‚æœkå’Œä¸€ä¸ªç­”æ¡ˆé‚£ä¹ˆ2kä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼š$f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$ã€‚å› æ­¤æˆ‘ä»¬ä»èƒ½æ‰¾åˆ°ä¸€ä¸ªå¤§äº$\\dfrac n 2$çš„ç­”æ¡ˆã€‚\nç„¶åæˆ‘ä»¬åˆ†ç±»è®¨è®ºï¼Œå…ˆè€ƒè™‘$x\\ge 0$çš„æƒ…å†µã€‚å¦‚æœkæ˜¯ç­”æ¡ˆï¼Œå› ä¸º$f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$ï¼Œæ‰€ä»¥k+1ä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼Œå› æ­¤æˆ‘ä»¬åªè¦åˆ¤æ–­$k=n$æ˜¯ä¸æ˜¯ç­”æ¡ˆå°±è¡Œäº†ã€‚\næœ€åï¼Œè€ƒè™‘$x\\leq 0$ï¼Œæˆ‘ä»¬éœ€è¦å€ŸåŠ©ä»¥ä¸‹å‰ç¼€å’Œï¼Œå®šä¹‰$pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ å¹¶ä¸” $pre_0=0$. æˆ‘ä»¬éœ€è¦æ‰¾åˆ° $k$ ä½¿å¾—å¯¹äºæ‰€æœ‰$0\\leq i\\leq n-k$:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nå› ä¸º$k\u0026gt;\\dfrac n 2$ï¼Œâ€œçª—å£â€ä¹‹åçš„æ‰€æœ‰æ•°å­—éƒ½æ˜¯$x$ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä¸ç­‰å¼å¯ä»¥å†™æˆè¿™æ ·ï¼š\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\nå¯¹äºæ¯ä¸€ä¸ª$i$ï¼Œå¯¹åº”çš„kæ˜¯$n-1$ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸ç­‰å¼å·¦è¾¹çš„æœ€å¤§å€¼å¦‚æœå°äº$pre_n+x\\cdot (n-i)$ï¼Œé‚£ä¹ˆ$k=n-i$æ˜¯ä¸€ä¸ªç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end() using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } ","date":1590451200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1590451200,"objectID":"f6c24e730c4557e772053577ca037e38","permalink":"https://tgc54.com/zh/post/cf1358e/","publishdate":"2020-05-26T00:00:00Z","relpermalink":"/zh/post/cf1358e/","section":"post","summary":"å¥½å‡ å¤©æ²¡æ›´æ–°äº†\n","tags":null,"title":"Codeforces 1358E - Are You Fired? é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ è¿™é¢˜å¦‚æœä¸èƒ½å¾€å·¦èµ°çš„è¯å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„dpé¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬è¦å¤„ç†ä¸€ä¸‹é¢å¤–çš„æƒ…å†µã€‚ä½†æ˜¯ç»è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°æˆ‘ä»¬ä¸éœ€è¦å¾€å·¦èµ°è¶…è¿‡ä¸¤æ ¼ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„è¯æ˜ï¼š\næ‰€ä»¥æˆ‘ä»¬åªè¦é¢å¤–è€ƒè™‘ä¸¤ç§çŠ¶æ€è½¬ç§»å°±è¡Œäº†ï¼Œæ‰€æœ‰çš„çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } ","date":1589846400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1589846400,"objectID":"776b2bf95d67661c062050dc5a430922","permalink":"https://tgc54.com/zh/post/cf762d/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"/zh/post/cf762d/","section":"post","summary":"","tags":["åŠ¨æ€è§„åˆ’"],"title":"Codeforces 762D - Maximum Path é¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"æ€»ç»“ä¸€ä¸‹åŠ æ·±å°è±¡\nå·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å½“å‰å° ä¸¥æ ¼å•è°ƒé€’å¢æ ˆï¼Œå¦‚æœæ±‚çš„æ˜¯æ•°å­—æ ˆå†…å°±å­˜æ•°å­—ï¼Œå¦‚æœæ±‚è·ç¦»æ ˆå†…å°±å­˜æ•°å­—+ä¸‹æ ‡æˆ–è€…æ•°å­—+åˆ°æ ˆå†…å‰ä¸€ä¸ªå…ƒç´ çš„è·ç¦»ã€‚\nä¸¾ä¾‹ [2,1,6,4,5]\n[] ç©ºæ ˆï¼Œè¯´æ˜2ä¹‹å‰æ²¡æœ‰æ¯”2å°çš„å…ƒç´ ï¼Œç„¶å2å…¥æ ˆ [2]\nä¸ºäº†ä¿æŒå•è°ƒé€’å¢ï¼Œéœ€è¦æŠŠ2å¼¹å‡ºï¼Œå˜æˆç©ºæ ˆï¼Œè¯´æ˜1å‰é¢ä¹Ÿæ²¡æœ‰æ¯”1å°çš„ï¼Œç„¶å1å…¥æ ˆ [1]\n6æ¯”1å¤§ï¼Œç›´æ¥å…¥æ ˆï¼Œ[1, 6]\nå…ˆæŠŠæ¯”4å¤§çš„å…ƒç´ å¼¹å‡º[1],ç„¶åå…¥æ ˆ [1, 4]\n5ç›´æ¥å…¥æ ˆ [1, 4, 5]\næ±‚è·ç¦»ï¼š\n{å…ƒç´ ,åˆ°å‰ä¸€ä¸ªçš„è·ç¦»}\n[] -\u0026gt; [{2,1}]\n[] -\u0026gt; [{1,2}]\n[{1,2}] -\u0026gt; [{1,2},{6,1}]\n[{1,2}] -\u0026gt; [{1,2},{4,2}]\n[{1,2},{4,2}] -\u0026gt; [{1,2},{4,2},{5,1}]\nä»£ç  æ±‚å…ƒç´ ï¼š\nstack\u0026lt;int\u0026gt; stk vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;stk.top()\u0026gt;=a[i]) stk.pop(); ans[i]=stk.top(); stk.push(a[i]); } æ±‚è·ç¦»:\nstack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ int res=1; while(!stk.empty()\u0026amp;\u0026amp;stk.top().first\u0026gt;=a[i]){ res+=stk.top().second; stk.pop(); } ans[i]=res; stk.push({a[i],res}); } å·¦è¾¹ç¬¬ä¸€ä¸ªå¤§ï¼Œç¬¬ä¸€ä¸ªå¤§äºç­‰äºï¼Œç¬¬ä¸€ä¸ªå°äºç­‰äº ä¸¥æ ¼å•è°ƒé€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å¢\nå³è¾¹ç¬¬ä¸€ä¸ªå¤§ç­‰ç­‰ ä»å³å¾€å·¦å¤„ç†å³å¯\n","date":1589846400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1589846400,"objectID":"6e68232cf7d7931a1887dd47dd9c4be0","permalink":"https://tgc54.com/zh/post/monotonic_stack/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"/zh/post/monotonic_stack/","section":"post","summary":"æ€»ç»“ä¸€ä¸‹åŠ æ·±å°è±¡\n","tags":["æ•°æ®ç»“æ„","å•è°ƒæ ˆ"],"title":"å•è°ƒæ ˆå¸¸è§æ¨¡å‹","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ é¢˜ç›®æœ¬è´¨æ˜¯åˆ¤æ–­èƒ½å¦æ‰¾åˆ°ä¸€å¯¹çº¿æ®µä½¿å¾—ä»–ä»¬åœ¨ä¸€ä¸ªç»´åº¦ä¸Šç›¸äº¤ä½†ä¸åœ¨å¦ä¸€ç»´åº¦ä¸Šä¸ç›¸äº¤ã€‚ä¸ºäº†å¾—åˆ°æ‰€æœ‰ç›¸äº¤çš„çº¿æ®µï¼Œæˆ‘ä»¬è¦çŸ¥é“å¯¹äºæ‰€æœ‰æ—¶é—´ç‚¹è¢«å“ªäº›çº¿æ®µè¦†ç›–äº†ã€‚å…·ä½“ä¸€ç‚¹å°±æ˜¯éœ€è¦å‡ ä¸ªæ•°ç»„$open_i$å’Œ$close_i$ï¼Œåˆ†åˆ«å­˜çš„æ˜¯ä»¥$i$å¼€å¤´å’Œç»“å°¾çš„çº¿æ®µã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•çŸ¥é“æ˜¯å¦æœ‰ä¸€å¯¹çº¿æ®µä¸ç›¸äº¤å‘¢ï¼Ÿæˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸¤ä¸ªmultisetï¼Œä¸€ä¸ªå­˜å½“å‰çº¿æ®µçš„èµ·ç‚¹ï¼Œå¦ä¸€ä¸ªå­˜ç»ˆç‚¹ã€‚å¦‚æœæœ€å³è¾¹çš„èµ·ç‚¹å¤§äºæœ€å·¦è¾¹çš„ç»ˆç‚¹é‚£ä¹ˆå°±è¯´æ˜æœ‰ä¸¤ä¸ªçº¿æ®µæ²¡é‡å ã€‚\næœ€ååˆ«å¿˜äº†ç¦»æ•£åŒ–å¹¶ä¸”ä¸¤ä¸ªç»´åº¦éƒ½è¦æ£€æŸ¥ä¸€ä¸‹ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } ","date":1589414400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1589414400,"objectID":"c3db5c2f8a8a843a2b7b3bb77ac6140f","permalink":"https://tgc54.com/zh/post/cf1284d/","publishdate":"2020-05-14T00:00:00Z","relpermalink":"/zh/post/cf1284d/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„"],"title":"Codeforces 1284D - New Year and Conference é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ è§‚å¯Ÿæ˜“çŸ¥ï¼Œè‹¥æƒ³ç”¨æœ€å°çš„æ—¶é—´è¦†ç›–ä¸€æ®µçº¿æ®µï¼Œé‚£ä¹ˆç»“æŸæ—¶çš„ä½ç½®ä¸€å®šåœ¨çº¿æ®µçš„å·¦ç«¯ç‚¹æˆ–å³ç«¯ç‚¹ã€‚é‚£ä¹ˆæˆ‘ä»¬çš„dpçŠ¶æ€å°±å¯ä»¥è®¾ä¸º$dp_{l,r,p}$ï¼Œä»£è¡¨è¦†ç›–ä»låˆ°rçš„çº¿æ®µæ‰€ç”¨çš„æœ€çŸ­æ—¶é—´å¹¶ä¸”ä»¥å·¦ç«¯ç‚¹ç»“å°¾ï¼ˆp=0ï¼‰ï¼Œå³ç«¯ç‚¹ç»“å°¾ï¼ˆp=1ï¼‰ã€‚\nçŠ¶æ€è½¬ç§»æ˜¯ä¸éš¾æƒ³çš„ï¼Œ$dp_{l,r,0}$å¯ä»¥ç”±$dp_{l+1,r,0}$æˆ–$dp_{l+1,r,1}$å¾—åˆ°ï¼ŒåŒç†$dp_{l,r,1}$å¯ä»¥ç”±$dp_{l,r-1,0}$æˆ–$dp_{l,r-1,1}$å¾—åˆ°ï¼Œåˆ«å¿˜äº†åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦åœ¨è§„å®šçš„æ—¶é—´ä¹‹å†…ã€‚å…·ä½“è½¬ç§»çœ‹ä»£ç ï½\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); const int N=1005; int dp[N][N][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; p(n+1),t(n+1); ms(dp,INF); for1(i,n){ cin\u0026gt;\u0026gt;p[i]; dp[i][i][0]=dp[i][i][1]=0; } for1(i,n) cin\u0026gt;\u0026gt;t[i]; for(int len=2;len\u0026lt;=n;len++){ for(int l=1;l+len-1\u0026lt;=n;l++){ int r=l+len-1; int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]); int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]); if(t1\u0026lt;=t[l]) dp[l][r][0]=t1; if(t2\u0026lt;=t[r]) dp[l][r][1]=t2; } } int ans=min(dp[1][n][0],dp[1][n][1]); cout\u0026lt;\u0026lt;(ans==INF?-1:ans); return 0; } ","date":1589068800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1589068800,"objectID":"3181469dbaebdb1b327693c6495ac3ff","permalink":"https://tgc54.com/zh/post/nc5447c/","publishdate":"2020-05-10T00:00:00Z","relpermalink":"/zh/post/nc5447c/","section":"post","summary":"","tags":["åŠ¨æ€è§„åˆ’"],"title":"é¢˜è§£ Nowcoder 5447C - å¼ è€å¸ˆçš„æ—…è¡Œ","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æƒ³æ˜ç™½äº†ä»¥åå…¶å®å¾ˆç®€å•\né¢˜è§£ é¦–å…ˆï¼Œå¦‚æœ$c_i$å¤§äº$i$çš„å­æ ‘çš„å¤§å°ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸å­˜åœ¨ã€‚\nå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªæ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„åŒ…å«è¿™ä¸ªèŠ‚ç‚¹æ‰€æœ‰å­æ ‘çš„èŠ‚ç‚¹ï¼ŒæŒ‰ç…§$a_i$çš„å¤§å°æ’åºï¼ˆè™½ç„¶æˆ‘ä»¬ç°åœ¨è¿˜ä¸çŸ¥é“$a_i$çš„å…·ä½“æ•°å€¼ï¼Œæˆ‘ä»¬åªå…³å¿ƒç›¸å¯¹å¤§å°å…³ç³»ï¼‰ã€‚ä¸‹ä¸€ä¸ªé—®é¢˜å°±æ˜¯å¦‚ä½•ç»„åˆå­èŠ‚ç‚¹çš„æ•°ç»„ï¼Œç­”æ¡ˆå…¶å®å¾ˆç®€å•ï¼šç›´æ¥æ‹¼èµ·æ¥å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ¯ä¸ªå­æ ‘æ˜¯äº’ç›¸ç‹¬ç«‹çš„ã€‚æœ€åä¸€æ­¥å°±æ˜¯æŠŠå½“å‰çš„èŠ‚ç‚¹æ”¾è¿›å»ï¼Œå› ä¸º$c_i$æ˜¯å·²çŸ¥çš„æ‰€ä»¥æ•°ç»„çš„ç¬¬$c_i$ä¸ªæ•°åº”è¯¥æ˜¯$i$.\nç°åœ¨æˆ‘ä»¬æœ‰äº†åŒ…å«æ‰€æœ‰èŠ‚ç‚¹çš„æ•°ç»„$order$ï¼Œæˆ‘ä»¬æŠŠ$1,2,3,\\dots$ èµ‹ç»™ $order_1,order_2,order_3,\\dots$å°±è¡Œäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1588809600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1588809600,"objectID":"e0ce215156e345204fc229b8b1700704","permalink":"https://tgc54.com/zh/post/cf1286b/","publishdate":"2020-05-07T00:00:00Z","relpermalink":"/zh/post/cf1286b/","section":"post","summary":"æƒ³æ˜ç™½äº†ä»¥åå…¶å®å¾ˆç®€å•\n","tags":["DFS"],"title":"CodeForces 1286B/1287D - Numbers on Tree é¢˜è§£","type":"post"},{"authors":null,"categories":null,"content":"æ•°å­¦å¤ªåƒåœ¾\naå†™é”™äº†ä¸€ä¸ªåœ°æ–¹ä½†æ ·ä¾‹è¿‡äº†ä¹Ÿå°±æ²¡å¤šæƒ³å°±äº¤äº†ï¼Œä¸Šæ¥å°±åƒä¸€å‘waâ€¦â€¦\nbé¢˜ä¹Ÿå·®ä¸å¤šï¼Œç®€å•æƒ³äº†æƒ³å°±å¼€å§‹å†™ï¼Œä¹Ÿæ²¡è€ƒè™‘ä¸€äº›æ›´å¤æ‚çš„æƒ…å†µï¼Œåˆåƒä¸€å‘waã€‚\ncé¢˜åº”è¯¥æ—©ç‚¹æ‰“è¡¨çš„ï¼Œæ‰‹åŠ¨æšä¸¾è¿˜æ˜¯è´¹æ—¶é—´ï¼Œè€Œä¸”è¿˜ç®—é”™äº†ä¸€ä¸ªï¼Œæ›´åŠ é˜»ç¢äº†å‘ç°è§„å¾‹ã€‚ç„¶åå°±æ˜¯è®¡æ•°é—®é¢˜ï¼Œç®—ç›¸ç­‰çš„æƒ…å†µç¡®å®æ²¡é”™ï¼Œä½†æœ‰ç‚¹è¿‡äºæƒ³æŠŠå…¬å¼ä¸€èˆ¬åŒ–äº†ï¼Œå°±åº”è¯¥æŒ‰ç…§è‡ªå·±çš„æƒ³æ³•æ¥ï¼Œå“ªæ€•å…¬å¼é•¿ä¸€äº›ï¼Œæ¯•ç«Ÿæ¯”èµ›è¿½æ±‚çš„è¿˜æ˜¯é€Ÿåº¦ã€‚\ndé¢˜è´ªå¿ƒç­–ç•¥æƒ³é”™äº†ï¼Œè²Œä¼¼ç»å¸¸çŠ¯è¿™æ ·çš„é”™è¯¯ï¼Œä¸€ç§ç­–ç•¥æ˜¯ä»å¤§å¾€å°å¡«ã€‚\næ€»ç»“ï¼šè¿˜æ˜¯åº”è¯¥å³æ—¶å†³å®šå–èˆï¼Œé‡å†™å¾€å¾€æ¯”ä¿®æ”¹å¥½ï¼ˆåœ¨å¡é¢˜çš„æ—¶å€™ï¼‰ï¼Œè¿˜æœ‰å¿ƒæ€çš„é—®é¢˜ã€‚\n","date":1587945600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587945600,"objectID":"3e4c92e27bb0a70b1c323ad332ef88d7","permalink":"https://tgc54.com/zh/post/cf1432recap/","publishdate":"2020-04-27T00:00:00Z","relpermalink":"/zh/post/cf1432recap/","section":"post","summary":"æ•°å­¦å¤ªåƒåœ¾\n","tags":null,"title":"Recap of Educational Codeforces round 86","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ æˆ‘ä»¬å¯ä»¥åšçš„æœ€å°çš„æ“ä½œå°±æ˜¯åªæ’åºç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯è¯´äº¤æ¢$a_i$å’Œ$a_{i+1}$å¦‚æœ$a_i\u0026gt;a_{i+1}$ã€‚é€šè¿‡è¿™ç§æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ$a_i$æŒªåˆ°ä½ç½®$j,j\u0026lt; i$ï¼Œå¦‚æœæ‰€æœ‰$i$åˆ°$j-1$çš„æ•°éƒ½æ¯”$a_i$å°çš„è¯ã€‚\næ˜ç™½äº†æ“ä½œçš„æœ¬è´¨ä¹‹åæˆ‘ä»¬å°±å¯ä»¥å°è¯•ä»ç”¨aæ•°ç»„çš„æ•°å·¦å¾€å³æ„é€ bæ•°ç»„äº†ã€‚è®¾å½“å‰çš„ä½ç½®ä¸º$i$:\né¦–å…ˆæ‰¾åˆ°æœ€å·¦çš„ä½ç½®$j$ä½¿å¾—$a_j=b_i$ï¼Œå¦‚æœæ‰¾ä¸åˆ°é‚£ä¹ˆç­”æ¡ˆæ˜¯noã€‚æˆ‘ä»¬å¯ä»¥ç”¨setæˆ–è€…å¾ˆå¤šä¸ªvectorç»´æŠ¤ä½ç½®ã€‚\nåˆ¤æ–­$[1,j)$ï¼ˆæœ€åˆçš„ä¸‹æ ‡ï¼‰ä¸­çš„æœ€å°å€¼æ˜¯å¦æ¯”$a_j$å°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘å®ç°è¿™ä¸€æ“ä½œã€‚\nå°†$a_j$è®¾ä¸ºæ— ç©·å¤§ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r) int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } ","date":1587772800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587772800,"objectID":"e4adfe88a5e4df415ea312d1973ff114","permalink":"https://tgc54.com/zh/post/cf1187d/","publishdate":"2020-04-25T00:00:00Z","relpermalink":"/zh/post/cf1187d/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„","çº¿æ®µæ ‘"],"title":"Codeforces 1187D - Subarray Sorting é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"yysyè¿™ç§é¢˜æƒ³å‡ºæ¥çœŸçš„çˆ½ã€‚\né¢˜è§£ è¿™é“é¢˜æœ‰å¾ˆå¤šä¸åŒçš„dpæ–¹æ³•ã€‚è¿™é‡Œæˆ‘å°†æè¿°ä¸€ä¸‹æˆ‘è®¤ä¸ºæ¯”è¾ƒæ ‡å‡†çš„æ–¹æ³•ã€‚å½“ç„¶æœ‰æ›´çŸ­çš„åšæ³•ä½†æ˜¯ä¹Ÿçœ‹ä¸æ‡‚å•ŠQAQã€‚\né¦–å…ˆå®šä¹‰ä¸€ä¸‹dpçŠ¶æ€ï¼Œè®¾$dp_{i,j}$ä¸ºå‰iä¸ªæ•°çš„ç­”æ¡ˆå¹¶ä¸”æœ€åä¸€ä¸ªé€‰çš„æ•°çš„ä¸‹æ ‡æ˜¯$i-j$ã€‚\né€šè¿‡è§‚å¯Ÿä¸éš¾å‘ç°å¦‚æœ$i$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆjæœ€å¤§æ˜¯2ï¼Œå¦åˆ™jæœ€å¤§æ˜¯1ã€‚è¿™ç‚¹å¯ä»¥é€šè¿‡å–$1,3,5,\\dots$çš„æ•°æ¥éªŒè¯ã€‚\nç°åœ¨æˆ‘ä»¬å¯ä»¥è€ƒè™‘çŠ¶æ€è½¬ç§»äº†ã€‚å¦‚æœ$i$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆé€‰çš„æ•°çš„ä¸ªæ•°å’Œ$i-1$æ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥$dp_{i,j}$åº”è¯¥ç­‰äº$dp_{i-1,j-1}$é™¤äº†$dp_{i,0}$ï¼Œå› ä¸º$a_i$åœ¨è®¡ç®—$dp_{i-1,j}$çš„æ—¶å€™å¹¶æ²¡æœ‰è¢«è€ƒè™‘åˆ°ï¼Œæ‰€ä»¥$dp_{i,0}$åº”è¯¥ä»$dp_{i-2,j}$è½¬ç§»è¿‡æ¥ã€‚ä»¥ä¸‹æ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹:\n$$ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,0}\\\\ dp_{i,2}\u0026amp;=dp_{i-1,1}\\end{align*} $$\nå½“$i$ä¸ºå¶æ•°ï¼Œè¦æ¯”$i-1$å¤šé€‰ä¸€ä¸ªæ•°ï¼Œæƒ³æ³•åŸºæœ¬ç±»ä¼¼ã€‚çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š\n\\[ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{align*} \\]\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } ","date":1587686400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587686400,"objectID":"1d6004096c568b592f0b072725e78cae","permalink":"https://tgc54.com/zh/post/abc162f/","publishdate":"2020-04-24T00:00:00Z","relpermalink":"/zh/post/abc162f/","section":"post","summary":"yysyè¿™ç§é¢˜æƒ³å‡ºæ¥çœŸçš„çˆ½ã€‚\n","tags":["åŠ¨æ€è§„åˆ’"],"title":"Atcoder beginner contest 162F -  Select Half Select Half é¢˜è§£","type":"post"},{"authors":null,"categories":["æ‚é¡¹"],"content":"ä»…ç”¨åšæé†’è‡ªå·±ï¼Œçœ‹ä¸æ‡‚æ¦‚ä¸è´Ÿè´£ï½\nLIS å’Œ LNDS int LIS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=lower_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } int LNDS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=upper_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } Maximum subarray sum int cur=0, max_sum=0;//max_sum=-1e8 if at least one element must be chosen for(auto it:a){ cur=max(cur+it,it); max_sum=max(max_sum,cur); } æ•´æ•°ä¸‰åˆ† ä»¥æ±‚å‡½æ•°æœ€å¤§å€¼ä¸ºä¾‹\nwhile(l\u0026lt;r-2){ int m=(l+r)/2; if(cal(m)\u0026gt;cal(m+1)) r=m+1; else l=m; } int ans=max({cal(l),cal(l+1),cal(r)}); æŠŠnåˆ†æˆkç»„ int sz=n/k æœ‰n%kç»„æœ‰sz+1ä¸ªï¼Œk-n%kç»„æœ‰szä¸ªã€‚\nå¿«é€ŸèŒƒå›´åˆ¤æ–­ åˆ¤æ–­æ˜¯å¦åœ¨[0, N)ï¼Œå¸¸ç”¨äºbfs/dfsè¾¹ç•Œåˆ¤æ–­\nif((unsigned)x\u0026lt;N) åˆ¤æ–­æ˜¯å¦åœ¨[l, r]å†…\nif((x-l|r-x)\u0026gt;=0) æ ¹æ®ä¸¤æ•°ä¹‹å’Œå’Œå¼‚æˆ–å€¼åæ¨ä¸¤æ•° åŸç†ï¼ša+b==(a^b)+2*(a\u0026amp;b)\nå¦‚æœ$sum-xor$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæ— è§£ã€‚\nå¦åˆ™$A=(sum-xor)/2$ï¼Œæ ¹æ®Aå’Œxorçš„æ¯ä¸€ä½å¡«å°±è¡Œäº†ï¼Œæ³¨æ„å¦‚æœæŸä¸€ä½ä¸¤æ•°éƒ½æ˜¯1çš„è¯ä¹Ÿæ˜¯æ— è§£ã€‚\nä¼˜å…ˆé˜Ÿåˆ—æ¨¡æ¿å‚æ•°è‡ªåŠ¨æ¨æ–­ å¯ä»¥å°‘å†™ä¸€ç‚¹ä»£ç ï¼Œéœ€è¦æ¯”è¾ƒæ–°çš„g++ç‰ˆæœ¬ã€‚\npriority_queue q(greater{}, vector\u0026lt;int\u0026gt;{}); ç²¾ç¡®è®¡ç®—$\\lceil\\log_2 x\\rceil$ x==1 ? 0 : __lg(x-1)+1; ç”¨äº¤æ¢ç›¸é‚»å…ƒç´ çš„æ’åºæ•°ç»„çš„æœ€å°æ“ä½œæ¬¡æ•° æ˜¯æ•°ç»„ä¸­é€†åºå¯¹çš„æ•°ç›®\naä¸ª0ï¼Œbä¸ª1ç»„æˆçš„01å­—ç¬¦ä¸²å­—å…¸åºç¬¬kå° å…ˆé¢„å¤„ç†iä¸ª0,jä¸ª1çš„å­—ç¬¦ä¸²ä¸ªæ•°ï¼Œç„¶åä»é«˜ä½åˆ°åº•ä½æšä¸¾\nvector dp(a+1, vector(b+1, 0LL)); dp[0][0]=1; for (int i=0; i\u0026lt;=a; i++) { for (int j=0; j\u0026lt;=b; j++) { if (i\u0026gt;0) { dp[i][j]+=dp[i-1][j]; } if (j) { dp[i][j]+=dp[i][j-1]; } } } auto find_kth=[\u0026amp;](auto\u0026amp; find_kth, int A, int B, ll k) { if (A==0) return string(B, \u0026#39;b\u0026#39;); if (B==0) return string(A, \u0026#39;a\u0026#39;); if (k\u0026lt;=dp[A-1][B]) return \u0026#34;a\u0026#34;+find_kth(find_kth, A-1, B, k); return \u0026#34;b\u0026#34;+find_kth(find_kth, A, B-1, k-dp[A-1][B]); }; ä½è¿ç®—æŠ€å·§ å¯ä»¥çœ‹è¿™\nå†’æ³¡æ’åºéå†çš„æ¬¡æ•° åˆ›å»ºä¸€ä¸ªå¤åˆ¶æ•°ç»„bï¼Œå…¶ä¸­$b[i]={a[i], i}$ï¼Œç„¶åæ’åºbï¼Œæ’åºå$b[i].second-i$çš„æœ€å¤§å€¼å°±æ˜¯ç­”æ¡ˆï¼Œ$b[i].second-i$æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªæ•°å‘å‰ç§»åŠ¨çš„è·ç¦»ï¼Œä¸éš¾æƒ³å‡ºæ¯ä¸ªä¼šå‘å‰ç§»åŠ¨çš„æ•°ä»ç¬¬ä¸€è½®éå†å°±ä¼šå¼€å§‹å‘å‰ç§»åŠ¨ï¼Œç›´åˆ°åˆ°è¾¾æ’åºåçš„ä½ç½®ï¼Œæ‰€ä»¥æœ€å¤§çš„å‘å‰ç§»åŠ¨è·ç¦»å°±æ˜¯éå†çš„è½®æ•°ã€‚\n","date":1587427200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587427200,"objectID":"07ea5317007ff0a04dc3f13c25e93960","permalink":"https://tgc54.com/zh/post/cp_tricks/","publishdate":"2020-04-21T00:00:00Z","relpermalink":"/zh/post/cp_tricks/","section":"post","summary":"ä»…ç”¨åšæé†’è‡ªå·±ï¼Œçœ‹ä¸æ‡‚æ¦‚ä¸è´Ÿè´£ï½\n","tags":null,"title":"ç®—æ³•ç«èµ›æ‚è®°","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ä¸»å¸­æ ‘ï¼\né¢˜è§£ ç”¨ä¸»å¸­æ ‘æˆ‘ä»¬å¯ä»¥çŸ¥é“åœ¨ç»™å®šåŒºé—´é‡Œçš„æ‰€æœ‰æ•°çš„å‡ºç°æ¬¡æ•°ã€‚æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒå®¹æ˜“çš„æƒ³åˆ°ä¸€ä¸ªäºŒåˆ†åšæ³•ï¼š\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; è¿™ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\log n\\log n)$ã€‚è¶³å¤Ÿé€šè¿‡æœ¬é¢˜ï¼Œä½†è¿˜æœ‰ä¼˜åŒ–çš„åœ°æ–¹ã€‚äº‹å®ä¸Šï¼ŒäºŒåˆ†éƒ¨åˆ†å¯ä»¥åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„æ—¶å€™å®Œæˆã€‚é¦–å…ˆæˆ‘ä»¬è§„å®šå‡ ä¸ªå˜é‡ï¼š$[x,y]$ä¸ºå½“å‰è¯¢é—®çš„åŒºé—´ï¼Œ$[l,r]$ä¸ºå½“å‰åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„åŒºé—´ï¼Œ$s$ä¸º$(r,y]$é‡Œæ•°å­—çš„å‡ºç°æ¬¡æ•°ã€‚ä¼ªä»£ç å¤§æ¦‚æ˜¯è¿™æ ·ï¼š\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//(mid,y]ä¸­çš„æ•°æ¯”midå¤§ï¼Œä¹Ÿå°±æ˜¯è¯´ç­”æ¡ˆåœ¨å³è¾¹çš„åŒºé—´ return query(l,mid,s+cnt);//(mid,y]çš„æ•°ä¸å¤Ÿå¤šï¼Œç­”æ¡ˆåœ¨å·¦è¾¹çš„åŒºé—´ } Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } ","date":1587168e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587168e3,"objectID":"afb5d85a6f373ad1163ad486e3772ff9","permalink":"https://tgc54.com/zh/post/hdu6278/","publishdate":"2020-04-18T00:00:00Z","relpermalink":"/zh/post/hdu6278/","section":"post","summary":"ä¸»å¸­æ ‘ï¼\n","tags":["æ•°æ®ç»“æ„","çº¿æ®µæ ‘","ä¸»å¸­æ ‘","äºŒåˆ†"],"title":"HDU6278 - Just h-index é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜ç›®æœ¬èº«å°±å¾ˆå¥½ï¼ŒåŒæ—¶åˆèƒ½å¸¦æ¥å¯¹æ ‘çŠ¶æ•°ç»„çš„ä¸€äº›æ€è€ƒã€‚\né¢˜è§£ æˆ‘ä»¬è¦å€’ç€å¤„ç†ï¼Œå¯¹äºå½“å‰çš„$i$ï¼Œä¼šå­˜åœ¨ä¸€ä¸ª$k$ï¼Œä½¿å¾—$k$ä¸ªè¿˜æ²¡æœ‰ç”¨è¿‡çš„æœ€å°çš„æ•°çš„å’Œä¸º$s_i$ã€‚é‚£ä¹ˆå½“å‰$i$çš„ç­”æ¡ˆå°±æ˜¯$k+1$ã€‚å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…äºŒåˆ†æ‰¾ï¼Œä¹Ÿå¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…å€å¢é»‘ç§‘æŠ€æ±‚ã€‚\nCode äºŒåˆ† #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } å€å¢ #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1586476800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1586476800,"objectID":"72421a1d8275d4784e131410dfa75fe3","permalink":"https://tgc54.com/zh/post/cf1208d/","publishdate":"2020-04-10T00:00:00Z","relpermalink":"/zh/post/cf1208d/","section":"post","summary":"é¢˜ç›®æœ¬èº«å°±å¾ˆå¥½ï¼ŒåŒæ—¶åˆèƒ½å¸¦æ¥å¯¹æ ‘çŠ¶æ•°ç»„çš„ä¸€äº›æ€è€ƒã€‚\n","tags":["äºŒåˆ†","æ•°æ®ç»“æ„","æ ‘çŠ¶æ•°ç»„"],"title":"Codeforces 1208D- Restore Permutation é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å¦ˆä¸ªå”§çœ‹é”™é¢˜äº†\nSolution If thereâ€™s only one element in the set, the graph is obvious bipartite. If thereâ€™s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\né¢˜è§£ ä¸€ç‚¹ä¸­æ–‡ä¸å†™ä¹Ÿä¸å¤ªå¥½ï¼Œä¸‡ä¸€æœ‰äººçœ‹å‘¢â€¦â€¦ç®€å•å†™ä¸€ä¸‹è¦ç‚¹å§ï¼Œè¿™é¢˜å…³é”®åœ¨äºç†è§£ç¯æ˜¯æ€ä¹ˆå½¢æˆçš„ï¼Œç¯çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Œä»¥åŠä¸ºä»€ä¹ˆå½“ä¸”ä»…å½“ä¸¤ä¸ªæ•°åŒ…å«ç›¸åŒ2çš„å¹‚çš„æ—¶å€™ç¯çš„é•¿åº¦æ˜¯å¶æ•°ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } å‚è€ƒèµ„æ–™ https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n","date":1586390400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1586390400,"objectID":"c413b71dcb42e20642fb629107abc665","permalink":"https://tgc54.com/zh/post/cf1220d/","publishdate":"2020-04-09T00:00:00Z","relpermalink":"/zh/post/cf1220d/","section":"post","summary":"å¦ˆä¸ªå”§çœ‹é”™é¢˜äº†\n","tags":["æ•°å­¦","æ•°è®º"],"title":"Codeforces 1220D - Alex and Julian é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ä¼˜é›…çš„è§£æ³•ã€‚\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬å¯ä»¥å¿½ç•¥ç¬¬ä¸€å±‚æ–¹å—ã€‚è®¾$dp_{s,b}$è¡¨ç¤ºæŠŠ$b$ä¸ªæ–¹å—æ”¾åœ¨$s$å †ä¸Šæ”¾æ³•çš„æ•°é‡ã€‚ï¼ˆæœ‰äº›å †å¯ä»¥æ˜¯ç©ºçš„)\nç°åœ¨æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹è½¬ç§»æ–¹ç¨‹ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š\nç¬¬ä¸€å±‚æ˜¯æ»¡çš„ æœ€å·¦è¾¹çš„å †æ˜¯ç©ºçš„ åœ¨å³è¾¹çš„å †æ˜¯ç©ºçš„ ç¬¬ä¸€ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç¬¬ä¸€å±‚ï¼Œæ”¾ç½®çš„æ–¹æ³•å°±æ˜¯$dp_{s,b-s}$. ç¬¬äºŒï¼Œä¸‰ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç©ºçš„é‚£ä¸€å †ï¼Œæ‰€ä»¥æœ‰$2\\cdot dp_{s-1,b}$ç§æ”¾æ³•ï¼Œä½†ä¸¤ç§æƒ…å†µæœ‰é‡å ï¼Œå› ä¸ºæœ‰å¯èƒ½å·¦å³ä¸¤å †éƒ½æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥è¦å‡æ‰$dp_{s-2,b}$ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œè½¬ç§»æ–¹ç¨‹å°±æ˜¯ï¼š\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}-dp_{s-2,b}$$\nè¿™ä¸ªå¯ä»¥ç”¨è®°å¿†åŒ–æœç´¢æ¥æ±‚ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } ","date":1586131200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1586131200,"objectID":"e94b31a0ee14a1862f14e5a0f9483ae2","permalink":"https://tgc54.com/zh/post/gym102428f/","publishdate":"2020-04-06T00:00:00Z","relpermalink":"/zh/post/gym102428f/","section":"post","summary":"ä¼˜é›…çš„è§£æ³•ã€‚\n","tags":["åŠ¨æ€è§„åˆ’"],"title":"Gym 102428F - Fabricating Sculptures é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å¦™å•Šï¼\né¢˜è§£ æˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ•°ç»„$L$ä½¿å¾—ç¬¬$x$ä¸ªå·¥ä½œæ—¥ä¸æ—©äºç¬¬$L_x$å¤©ï¼Œé€šè¿‡ä»å‰å¾€åå°½å¯èƒ½æ—©çš„é€‰æ‹©å·¥ä½œæ—¥ã€‚åŒæ ·åœ°ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ $R$æ•°ç»„ä½¿å¾—ç¬¬$x$ä¸ªå·¥ä½œæ—¥ä¸æ™šäº$R_x$å¤©ï¼Œé€šè¿‡ä»åå¾€å‰é€‰æ‹©ã€‚ä»–å¿…é¡»åœ¨ç¬¬$i$å¤©å·¥ä½œå½“ä¸”ä»…å½“å­˜åœ¨$x$ä½¿å¾—$L_x=R_x=i$ã€‚å¯ä»¥åœ¨$O(N)$çš„æ—¶é—´å†…è§£å†³ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } ","date":1586044800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1586044800,"objectID":"1a4293ac02cb7d345777d35154e92fc8","permalink":"https://tgc54.com/zh/post/abc161e/","publishdate":"2020-04-05T00:00:00Z","relpermalink":"/zh/post/abc161e/","section":"post","summary":"å¦™å•Šï¼\n","tags":["è´ªå¿ƒ"],"title":"AtCoder Beginner Contest 161E - Yutori é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ç°åœ¨çœ‹æ¥å½“æ—¶æ˜¯çœŸçš„èœï¼Œä¸è¿‡è¿˜æ˜¯èƒ½å­¦åˆ°ä¸€äº›å¥‡æ€ªçš„çŸ¥è¯†233\né¢˜è§£ æœ€å¤šæœ‰$10^6$å¯¹$(x,y)$ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥éå†æ‰€æœ‰çš„å¯¹ã€‚æ¯ä¸€å¯¹æœ‰$\\dfrac 1 {n\\cdot k_x}$çš„æ¦‚ç‡è¢«é€‰ä¸­ï¼Œæ‰€ä»¥ä¸€ä¸ªåˆæ³•çš„$(x,y,z)$çš„æ¦‚ç‡æ˜¯$\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$ï¼Œå…¶ä¸­$cnt_y$æ˜¯æƒ³è¦yç¤¼ç‰©çš„å­©å­çš„ä¸ªæ•°ã€‚\nä¸€ä¸ªæœ‰æ„æ€çš„æ€§è´¨æ˜¯$\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$ï¼Œå½“$p$ä¸åˆ†æ¯äº’è´¨çš„æ—¶å€™æˆç«‹ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨éå†çš„æ—¶å€™å¯ä»¥ç›´æ¥æŠŠæ¦‚ç‡è½¬æ¢æˆ$cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$ç„¶ååŠ åˆ°ç­”æ¡ˆä¸Šã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1585785600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1585785600,"objectID":"6341797ffdd2221783caf75d763dfe75","permalink":"https://tgc54.com/zh/post/cf1279d/","publishdate":"2020-04-02T00:00:00Z","relpermalink":"/zh/post/cf1279d/","section":"post","summary":"ç°åœ¨çœ‹æ¥å½“æ—¶æ˜¯çœŸçš„èœï¼Œä¸è¿‡è¿˜æ˜¯èƒ½å­¦åˆ°ä¸€äº›å¥‡æ€ªçš„çŸ¥è¯†233\n","tags":["æ•°å­¦","æ¦‚ç‡"],"title":"CodeForces 1279D - Santa's Bot é¢˜è§£","type":"post"},{"authors":null,"categories":["Linux"],"content":"éšç¼˜æ›´æ–°ï¼Œæƒ³åˆ°å•¥å°±è®°å•¥\né…ç½® è§¦æ‘¸æ¿ ä¸€å¼€å§‹å‘ç°è§¦æ‘¸æ¿å³é”®å’Œå·¦é”®æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼ŒåŒæŒ‡è½»æŒ‰è¿˜æ˜¯ä¸­é”®â€¦â€¦\nè§£å†³æ–¹æ³•ï¼š\nç¼–è¾‘ /etc/X11/xorg.conf.d/30-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; Option \u0026#34;ButtonMapping\u0026#34; \u0026#34;1 3 2\u0026#34; Option \u0026#34;TappingButtonMap\u0026#34; \u0026#34;lmr\u0026#34; EndSection æ˜ å°„caps+hjklä¸ºæ–¹å‘é”® ç¼–è¾‘~/.Xmodmap\nclear lock keycode 43 = h H Left H keycode 44 = j J Down J keycode 45 = k K Up K keycode 46 = l L Right L keycode 66 = Mode_switch Caps_Lock keycode 31 = i I KP_Home I keycode 32 = o O KP_End O Then update xmodmap:\n{% highlight shell %} xmodmap ~/.Xmodmap {% endhighlight %}\nè§£å†³æŒ‚èµ·åå¤±æ•ˆçš„é—®é¢˜ï¼š\n{% highlight shell %} sudo touch /usr/lib/systemd/system-sleep/xkeyboard sudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard {% endhighlight %}\nç¼–è¾‘xkeyboard\n#!/bin/bash case $1 in pre) exit 0 ;; post) export DISPLAY=:0 sleep 10 xmodmap /home/thallium/.Xmodmap ;; esac ä¸»é¢˜ arc\n{% highlight shell %} sudo pacman -S arc-gtk-theme {% endhighlight %}\nè½¯ä»¶ vimé…ç½® å¾…æ›´æ–°\nfcitxç è¡¨ å¾…æ›´æ–°\nAutojump å¿«é€Ÿè·³è½¬æ–‡ä»¶å¤¹ï¼Œå†ä¹Ÿä¸ç”¨é•¿é•¿çš„cdäº†ï½\nå®‰è£… {% highlight shell %} yay autojump {% endhighlight %}\nSource the correct autojump file {% highlight shell %} echo â€œ/usr/share/autojump/autojump.bashâ€ Â» ~/.bashrc chmod 755 /usr/share/autojump/autojump.bash source ~/.bashrc {% endhighlight %}\næ³¨æ„äº‹é¡¹ å¿«é€Ÿè·³è½¬çš„æ–‡ä»¶å¤¹éœ€è¦æ­£å¸¸è®¿é—®ä¸€æ¬¡ã€‚\næˆªå›¾: Deepin screenshot ä¸€å¼€å§‹ç”¨çš„æ˜¯ç«ç„°æˆªå›¾ï¼Œä½†æ˜¯ä¸èƒ½è‡ªåŠ¨è¯†åˆ«çª—å£ï¼Œåæ¥å¶ç„¶å‘ç°deepin screenshotæ„Ÿè§‰æŒºä¸é”™çš„ã€‚\n{% highlight shell %} sudo pacman -S deepin-screenshot {% endhighlight %}\nå¦‚æœä¸èƒ½æ­£å¸¸å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œå®‰è£…xfce4-clipman\nè¯å…¸ Wudao dict\nå®‰è£…ï¼š\n{% highlight shell %} git clone https://github.com/chestnutheng/wudao-dict cd ./wudao-dict/wudao-dict sudo bash setup.sh {% endhighlight %}\né—®é¢˜è§£å†³ ä¿®æ”¹/etc/profileå¯¼è‡´å¾ªç¯ç™»å½• 2020.03.27\nä¸€èˆ¬çš„è§£å†³æ–¹æ³•æ˜¯ä»å‘½ä»¤è¡Œç™»å½•ç„¶åæ¢å¤ä¹‹å‰çš„ä¿®æ”¹ï¼Œä½†æˆ‘ä»å‘½ä»¤è¡Œä¹Ÿæ˜¯å¾ªç¯ç™»å½•â€¦â€¦äºæ˜¯æƒ³åˆ°èƒ½ä¸èƒ½ä»windowsä¿®æ”¹ç„¶åå‘ç°æœ‰ä¸ªè½¯ä»¶å«linux file system for windowsï¼Œç„¶åé—®é¢˜å°±è§£å†³äº†ã€‚çœŸçš„å¤ªä¸å®¹æ˜“äº†ï¼Œå¿ƒæ€å·®ç‚¹å´©äº†â€¦â€¦\nGnome-shellå†…å­˜æ³„æ¼é—®é¢˜ gnomeä¼ ç»Ÿè‰ºèƒ½ï¼Œalt+F2å†è¾“å…¥rå¯ä»¥é‡æ–°å¯åŠ¨shellã€‚\nè®©gvimé»˜è®¤åœ¨æ–°æ ‡ç­¾ä¸­å¯åŠ¨ ç¼–è¾‘/usr/share/applications/gvim.desktop\næŠŠ {% highlight shell %} Exec=gvim -f %F {% endhighlight %} æ”¹æˆ {% highlight shell %} Exec=gvim -p â€“remote-tab-silent %F {% endhighlight %}\ni3wmä¸‹è¿è¡ŒQQ/TIM/Wechat 2020-04-13\nåŸä½œè€…\n{% highlight shell %} nohup /usr/lib/gsd-xsettings \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd /opt/deepinwine/apps/Deepin-TIM ./run.sh {% endhighlight %}\næœ€åå°†ç¬¬ä¸€æ­¥æ·»åŠ åˆ°i3å¯åŠ¨é¡¹é‡Œã€‚\n","date":1585267200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1585267200,"objectID":"6c702f9df67ffce13d035a560c30508c","permalink":"https://tgc54.com/zh/post/manjaro-setup/","publishdate":"2020-03-27T00:00:00Z","relpermalink":"/zh/post/manjaro-setup/","section":"post","summary":"éšç¼˜æ›´æ–°ï¼Œæƒ³åˆ°å•¥å°±è®°å•¥\n","tags":["Linux"],"title":"Manjaro æŠ˜è…¾è®°å½•","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"çœ‹äº†ä¸€ä¸Šåˆæ‰çœ‹æ˜ç™½å¤§ä½¬çš„ä»£ç \né¢˜è§£ dp[i][j]è¡¨ç¤ºå‰iä¸ªæ•°é‡Œé¢åºåˆ—å’Œæ˜¯jçš„ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´æŠŠé¢˜ç›®è¦æ±‚æ”¹æˆå‰iä¸ªæ•°ï¼Œå’Œæ˜¯jæ—¶çš„ç­”æ¡ˆã€‚\nå½“æˆ‘ä»¬å¤„ç†æ–°çš„æ•°çš„æ—¶å€™ï¼Œå‡è®¾è¿™ä¸ªæ•°æ˜¯xï¼Œå½“å‰åœ¨ç¬¬iä½ã€‚å¾ˆæ˜æ˜¾å‰é¢çš„åºåˆ—å¯ä»¥é‡å¤ä½¿ç”¨ã€‚ç°åœ¨æˆ‘ä»¬å†è€ƒè™‘æ–°çš„æ•°å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼š\né¦–å…ˆï¼Œæ–°æ•°è‡ªå·±å°±å¯ä»¥ä½œä¸ºä¸€ä¸ªåºåˆ—ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰dp[i][x]=iã€‚å…¶æ¬¡ï¼Œæ–°çš„æ•°è¿˜å¯ä»¥å’Œå‰é¢çš„åºåˆ—å½¢æˆæ–°çš„åºåˆ—ï¼Œæ‰€ä»¥å¯¹äºæ‰€æœ‰$j\\ge x$ï¼Œæˆ‘ä»¬æœ‰dp[i][j]+=dp[i-1][j-x]ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1585094400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1585094400,"objectID":"f351eae4d1a6a25d3434b9d32b8e94ba","permalink":"https://tgc54.com/zh/post/abc159e/","publishdate":"2020-03-25T00:00:00Z","relpermalink":"/zh/post/abc159e/","section":"post","summary":"çœ‹äº†ä¸€ä¸Šåˆæ‰çœ‹æ˜ç™½å¤§ä½¬çš„ä»£ç \n","tags":["åŠ¨æ€è§„åˆ’"],"title":"AtCoder Beginner Contest 159E - Dividing Chocolate é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ æˆ‘ä»¬å¯ä»¥å…ˆå¯¹é‚»æ¥è¡¨çš„èŠ‚ç‚¹ï¼Œæ ¹æ®èŠ‚ç‚¹åœ¨è¾“å…¥åºåˆ—çš„å‡ºç°é¡ºåºæ’åºã€‚ç„¶åå°±å¯ä»¥æ­£å¸¸è·‘ä¸€éBFSç„¶åæ£€æŸ¥å¾—åˆ°çš„åºåˆ—å’Œè¾“å…¥æ˜¯å¦ä¸€æ ·ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } ","date":1584835200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584835200,"objectID":"4ff4a040806fe6a9c74a25180e3516cc","permalink":"https://tgc54.com/zh/post/cf1037d/","publishdate":"2020-03-22T00:00:00Z","relpermalink":"/zh/post/cf1037d/","section":"post","summary":"","tags":["BFS","å›¾è®º"],"title":"CodeForces 1037D - Valid BFS? é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æˆ‘æ€ä¹ˆè¿æ‰¾ç¯éƒ½ä¸ä¼š\né¢˜è§£ ä¸è®ºä»å“ªå¼€å§‹ï¼Œæœ€ç»ˆéƒ½ä¼šé™·å…¥å¾ªç¯ï¼ˆåŒ…æ‹¬è‡ªç¯ï¼‰ï¼Œæ‰€ä»¥æŠŠé™·é˜±æ”¾åœ¨ç¯ä¸Šæ°¸è¿œæ˜¯æœ€ä¼˜çš„ã€‚æ‰€ä»¥è¿™ä¸ªé¢˜å°±æ˜¯è¦æ‰¾åˆ°æ‰€æœ‰ç¯ç„¶åæ‰¾å‡ºæ¯ä¸ªç¯ä¸Šçš„æœ€å°èŠ±è´¹ã€‚\næ‰¾ç¯åº”è¯¥ç®—æ˜¯æ¯”åŸºç¡€çš„æŠ€å·§äº†ï¼Œä½†æˆ‘æ˜¯ç¬¬ä¸€æ¬¡é‡åˆ°è¿™ç§é¢˜ï¼ˆå¤ªèœäº†ï¼‰ã€‚å¯ä»¥åœ¨è¿™å­¦å¦‚ä½•æ‰¾ç¯ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1584748800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584748800,"objectID":"57ce9477d206ab49663addeebf2dc0f3","permalink":"https://tgc54.com/zh/post/cf1027d/","publishdate":"2020-03-21T00:00:00Z","relpermalink":"/zh/post/cf1027d/","section":"post","summary":"æˆ‘æ€ä¹ˆè¿æ‰¾ç¯éƒ½ä¸ä¼š\n","tags":["DFS","å›¾è®º"],"title":"CodeForces 1027D - Mouse Hunt","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ç«Ÿç„¶ä¸€æ¬¡å°±è¿‡äº†\nLink\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost cost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige pre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.\né¢˜è§£ è¿™ä¸ªé¢˜ç»“åˆäº†æœ€çŸ­è·¯å’Œ0/1èƒŒåŒ…ç®—æ³•ã€‚\nç¬¬ä¸€æ­¥æ˜¯æ‰¾åˆ°æ‰€æœ‰èœå“çš„æœ€å°èŠ±è´¹ï¼Œä¹Ÿå°±æ˜¯DAGä¸Šçš„æœ€çŸ­è·¯ã€‚è¿™ä¸ªå¯ä»¥ç”¨æ‹“æ‰‘æ’åºåœ¨$O(n)$çš„æ—¶é—´å†…è§£å†³ï¼Œå…·ä½“å®ç°çœ‹ä¸Šé¢çš„ä»£ç è§£é‡Šã€‚\nç¬¬äºŒæ­¥å°±æ˜¯éå¸¸æ ‡å‡†çš„0/1èƒŒåŒ…äº†ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort ms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack for1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } ","date":1584144e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584144e3,"objectID":"56b5155afbc095b4bafd9ee26c6606bc","permalink":"https://tgc54.com/zh/post/swerc2017e/","publishdate":"2020-03-14T00:00:00Z","relpermalink":"/zh/post/swerc2017e/","section":"post","summary":"ç«Ÿç„¶ä¸€æ¬¡å°±è¿‡äº†\n","tags":["å›¾è®º","æœ€çŸ­è·¯","æ‹“æ‰‘æ’åº","åŠ¨æ€è§„åˆ’","èƒŒåŒ…é—®é¢˜"],"title":"SWERC2017 E - Ingredients é¢˜è§£","type":"post"},{"authors":null,"categories":["æ‚é¡¹"],"content":"Policy-Based Data Structure(PB_DS)çš„åŸºç¡€ç”¨æ³•\nå“ˆå¸Œè¡¨ ç”¨æ³• #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table å¯ä»¥åƒunordered_mapä¸€æ ·ç”¨ã€‚\nç¨å¾®å¥½ä¸€ç‚¹çš„å“ˆå¸Œå‡½æ•° struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; æ— æ•Œå“ˆå¸Œå‡½æ•° struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; å¹³è¡¡æ ‘ å£°æ˜ å¤´æ–‡ä»¶ #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; ç”¨ä½œstd::map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; ç”¨ä½œstd::set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; ç”¨ä½œstd::multiset tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; ä¹Ÿå¯ä»¥ç”¨std::less_equalï¼Œä½†lower_bound å’Œ upper_bound å‡½æ•°ä¼šäº¤æ¢åŠŸèƒ½å¹¶ä¸”findä¼šå¤±æ•ˆï¼Œæ‰€ä»¥è°¨æ…ä½¿ç”¨ã€‚\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; æ¯”std::setæ›´å¼ºçš„åŠŸèƒ½ï¼šæ’å å¿…é¡»åœ¨å£°æ˜é‡Œç”¨tree_order_statistics_node_updateä»¥è·å¾—ä¸æ’åç›¸å…³çš„åŠŸèƒ½:\nsize_type order_of_key(key_const_reference);// è¿”å›æ¯”keyå°çš„å…ƒç´ çš„ä¸ªæ•° iterator find_by_order(size_type order) // è¿”å›æ’åä¸ºorderçš„å…ƒç´ çš„è¿­ä»£å™¨ï¼Œæ’åä»0å¼€å§‹ e.g. æ±‚é€†åºå¯¹\n#include \u0026lt;bits/extc++.h\u0026gt; using namespace std; using namespace __gnu_pbds; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); // æ³¨æ„æ­¤å¤„ç”¨äº†less_equalä»¥å…è®¸é‡å¤çš„å…ƒç´  tree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; st; int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (auto\u0026amp; x : a) cin \u0026gt;\u0026gt; x; long long ans=0; for (int i=n-1; i\u0026gt;=0; i--) { ans += st.order_of_key(a[i]); st.insert(a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ä½¿ç”¨ lower_bound å’Œ upper_bound æ‰¾å‰é©±å’Œåç»§ å‰é©±ï¼š\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set åç»§ï¼š\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); ä¼˜å…ˆé˜Ÿåˆ— åŸå‹ template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; ç”¨æ³• é»˜è®¤çš„æ¨¡æ¿å‚æ•°å°±æ˜¯æ€§èƒ½æœ€å¥½çš„ï¼Œæ³¨æ„å¿…é¡»è¦å¸¦ä¸Š__gnu_pbdså‘½åç©ºé—´ä»¥åŒºåˆ†std::priority_queueã€‚\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt; __gnu_pbds::priority_queue\u0026lt;int\u0026gt;; æ‰€æœ‰çš„5ç§tag:\nbinary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag å’Œ std::priority_queueçš„ä¸åŒä¹‹å¤„ point_iterator push(const_reference r_val); //pushä¼šè¿”å›æŒ‡å‘æ’å…¥åå…ƒç´ çš„pointè¿­ä»£å™¨ï¼ˆå’Œéå†è¿­ä»£å™¨ä¸ä¸€æ ·ï¼‰ void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other) //åˆå¹¶ä¸¤ä¸ªå †åŒæ—¶æ¸…ç©ºother void split(Pred prd,priority_queue \u0026amp;other) // æ ¹æ®prdå‡½æ•°çš„è¿”å›å€¼ï¼ˆtrueæˆ–falseï¼‰åˆ†è£‚ä¸¤ä¸ªå † void modify(point_iterator it,const key) // æŸäº›å †æ”¯æŒå¿«é€Ÿä¿®æ”¹å †ä¸­çš„å…ƒç´ ï¼Œæ¯”å¦‚ç”¨åœ¨dijkstraä¸­ begin(); end();//begin å’Œ end è¿­ä»£å™¨ å‚è€ƒèµ„æ–™ Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_dsåº“çš„ä¸€äº›å¸¸ç”¨æ–¹æ³•\nç”¨ pbds è¿‡ luogu P3369ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘\n","date":1584057600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584057600,"objectID":"e4f3cea50788d3e2df3bb882586dd24a","permalink":"https://tgc54.com/zh/post/pbds_basic_usage/","publishdate":"2020-03-13T00:00:00Z","relpermalink":"/zh/post/pbds_basic_usage/","section":"post","summary":"Policy-Based Data Structure(PB_DS)çš„åŸºç¡€ç”¨æ³•\n","tags":["æ•°æ®ç»“æ„"],"title":"PB_DSçš„åŸºç¡€ç”¨æ³•","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å¥½é¢˜ï¼\né¢˜è§£ ç­”æ¡ˆåˆ†ä¸¤æ­¥dfsï¼Œç¬¬ä¸€ä¸ªdfsç”¨æ¥è®¡ç®—$sub_i$ï¼š $i$çš„å­æ ‘ä¸­çš„çš„å­å›¾çš„æœ€å¤§å·®å€¼ã€‚ç¨å¾®æœ‰ç‚¹ç»•ï¼Œå…¶å®é¢˜ç›®ä¸­çš„â€œå­æ ‘â€åº”è¯¥å«å­å›¾æ¯”è¾ƒåˆé€‚ï¼Œå› ä¸ºæ˜¯æ— æ ¹æ ‘ï¼Œè¯´å­å›¾æ²¡ä»€ä¹ˆæ„ä¹‰ã€‚ä½†æˆ‘ä»¬dfsçš„æ—¶å€™å…¶å®æ˜¯æŠŠå›¾å½“æˆæœ‰æ ¹æ ‘ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡dfså¾—åˆ°çš„ç­”æ¡ˆåªè€ƒè™‘äº†å­æ ‘çš„è´¡çŒ®ï¼Œå‰©ä½™éƒ¨åˆ†çš„è´¡çŒ®ç”±ç¬¬äºŒä¸ªdfsç®—ã€‚å…¶ä»–éƒ¨åˆ†çš„è´¡çŒ®çœ‹è‹±æ–‡å§â€¦â€¦æ‡’å¾—å†å†™ä¸€éäº†ï¼ˆé€ƒï¼‰ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1583971200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1583971200,"objectID":"b0f559614cafeb21d0706a477021b6f5","permalink":"https://tgc54.com/zh/post/cf1324f/","publishdate":"2020-03-12T00:00:00Z","relpermalink":"/zh/post/cf1324f/","section":"post","summary":"å¥½é¢˜ï¼\n","tags":["DFS","åŠ¨æ€è§„åˆ’","æ ‘"],"title":"CodeForces 1324F - Maximum White Subtree é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ è¿™ä¸ªé¢˜æœ‰ç‚¹è´ªå¿ƒçš„æ„æ€ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸€ä¸ªæ°´ç®±çœ‹ä½œæ˜¯ä¸€äº›ç”±è¿ç»­æ°´ç®±ç»„æˆçš„ç»„ï¼Œæ¯ä¸ªç»„ä¸€å¼€å§‹çš„å¤§å°éƒ½æ˜¯1ã€‚å¦‚æœå½“å‰çš„ç»„çš„å¹³å‡å€¼æ¯”å·¦è¾¹çš„ç»„çš„å¹³å‡å€¼å°çš„è¯ï¼Œå°±åˆå¹¶è¿™ä¸¤ä¸ªç»„ã€‚ç”¨æ ˆå­˜å‚¨ä¹‹å‰ç»„çš„å¤§å°å’Œæ°´é‡çš„å’Œã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1582934400,"objectID":"87f6736ec7b474e5bb1717f26e8faa34","permalink":"https://tgc54.com/zh/post/cf1300e/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"/zh/post/cf1300e/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„","å•è°ƒæ ˆ"],"title":"Codeforces 1300E - Water Balance é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"å¦™å•Š\nProblem Link\né¢˜è§£ æˆ‘ä»¬ç”¨$A$è¡¨ç¤ºè¾“å…¥ï¼Œç”¨$P$è¡¨ç¤ºç­”æ¡ˆã€‚$A_i-A_{i-1}$å°±æ˜¯æ¯”$P_i$å¤§çš„æ•°å­—çš„ä¸ªæ•°å› æ­¤æˆ‘ä»¬ä¹Ÿèƒ½çŸ¥é“æ¯”$P_i$å°çš„æ•°çš„ä¸ªæ•°ã€‚æˆ‘ä»¬å¯ä»¥ç”¨æƒå€¼çº¿æ®µæ ‘ç„¶åä»åéå†$A$ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¾—åˆ°æ‰€æœ‰æ²¡ç”¨è¿‡çš„æ¯”$P_i$å°çš„æ•°çš„ä¸ªæ•°ï¼Œç„¶ååœ¨çº¿æ®µæ ‘ä¸­æ‰¾åˆ°å¯¹åº”çš„æ•°å¹¶æ›´æ–°çº¿æ®µæ ‘ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1582934400,"objectID":"031a4e534f6ecca46f315b57f3eed27d","permalink":"https://tgc54.com/zh/post/hdu5592/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"/zh/post/hdu5592/","section":"post","summary":"å¦™å•Š\n","tags":["æ•°æ®ç»“æ„","çº¿æ®µæ ‘"],"title":"HDU 5592 - ZYB's Premutation é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ æˆ‘ä»¬å¯ä»¥ç”¨è®°å¿†åŒ–dfsï¼ŒdpçŠ¶æ€æ˜¯ä»¥ä¸‹4ä¸ªæ•°ï¼šå‰©ä½™çš„å †æ•°ã€æœ€å³è¾¹ä¸‰å †é‡Œé¡¶ç«¯çš„ç‰Œã€‚å¦‚æœæˆ‘ä»¬æœ€åèƒ½å‰©ä¸‹ä¸€å †çš„è¯ç­”æ¡ˆå°±æ˜¯yesã€‚è¿™é¢˜ä¹Ÿå¯ä»¥ç”¨bfsï¼ŒçŠ¶æ€æ˜¯dpæ˜¯ä¸€æ ·çš„ï¼Œå¯èƒ½æ›´å¥½ç†è§£ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } ","date":1582329600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1582329600,"objectID":"8cf5c936a4f22f4462c41527eb086816","permalink":"https://tgc54.com/zh/post/cf208b/","publishdate":"2020-02-22T00:00:00Z","relpermalink":"/zh/post/cf208b/","section":"post","summary":"","tags":["DFS","åŠ¨æ€è§„åˆ’"],"title":"Codeforces 208B - Solitaire é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ è¿™ç§é¢˜å¸¸è§å¥—è·¯å°±æ˜¯å†™ä¸€ä¸ªæ±‚1åˆ°xç­”æ¡ˆçš„å‡½æ•°$F(x)$ç„¶åæœ€ç»ˆç­”æ¡ˆå°±æ˜¯$F(r)-F(l-1)$ã€‚\nä¸€ç§å¾ˆå¦™çš„æ–¹æ³•æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä»»æ„æ•°å­—ä¹‹ååŠ ä¸€ä¸ªç¬¬ä¸€ä½çš„æ•°å­—ä»è€Œå¾—åˆ°é¢˜ç›®è¦æ±‚çš„æ•°å­—ã€‚æ‰€ä»¥å¦‚æœxå°äº10é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯xï¼Œå¦åˆ™ç­”æ¡ˆå°±æ˜¯å»æ‰æœ€åä¸€ä½çš„x+9ã€‚å¦‚æœæœ€åä¸€ä½å°äºç¬¬ä¸€ä½æˆ‘ä»¬è¿˜è¦æŠŠç­”æ¡ˆå‡1ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } ","date":1582243200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1582243200,"objectID":"0c1f678a60493ed71731789da5f0af45","permalink":"https://tgc54.com/zh/post/cf205c/","publishdate":"2020-02-21T00:00:00Z","relpermalink":"/zh/post/cf205c/","section":"post","summary":"","tags":["æ•°å­¦","ç»„åˆå­¦"],"title":"Codeforces 205D - Little Elephant and Interval é¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } ","date":1582070400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1582070400,"objectID":"466bbe82f03d90e28f20f2be08f5d091","permalink":"https://tgc54.com/zh/post/longestpathondag/","publishdate":"2020-02-19T00:00:00Z","relpermalink":"/zh/post/longestpathondag/","section":"post","summary":"vector\u003cint\u003e G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; }","tags":["å›¾è®º","åŠ¨æ€è§„åˆ’","DFS"],"title":"DAGä¸Šæœ€é•¿è·¯","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"FML\né¢˜è§£ è®©$g= \\gcd(a,m)$ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰$a=g\\cdot kï¼Œ m=g\\cdot l,\\gcd(l,k)=1$ï¼Œä¸éš¾å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦ä½¿$\\gcd(a,m)=\\gcd(a+x,m)$ï¼Œ $x$å¿…é¡»æ˜¯$g$çš„å€æ•°ï¼Œè®¾$x=n\\cdot g$ã€‚ è€Œä¸”ï¼Œ$k+n$å’Œ$l$å¿…é¡»è¦äº’è´¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æ‰¾åˆ°ä»$k$åˆ°$k+l$ä¸­ä¸$l$äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚å¯¹äºé‚£äº›å¤§äº$l$çš„æ•°ï¼Œå¦‚æœ $\\gcd(k+x,l)=1$é‚£ä¹ˆ$\\gcd((k+x)\\bmod l,l)=1$ã€‚åˆå› ä¸º$(k+x)\\bmod l\u0026lt; l $ï¼Œæ‰€ä»¥æˆ‘ä»¬çœŸæ­£è¦ç®—çš„æ˜¯æ¯”$l$å°å¹¶ä¸”ä¸$l$äº’è´¨çš„æ•°çš„ä¸ªæ•°, ä¹Ÿå°±æ˜¯$\\varphi(l)$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } ","date":1580256e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1580256e3,"objectID":"08878d729f4a97bde3fb673421b15b07","permalink":"https://tgc54.com/zh/post/cf1295d/","publishdate":"2020-01-29T00:00:00Z","relpermalink":"/zh/post/cf1295d/","section":"post","summary":"FML\n","tags":["æ•°å­¦","æ¬§æ‹‰å‡½æ•°","æ•°è®º"],"title":"Codeforces 1295D - Same GCDs é¢˜è§£","type":"post"},{"authors":null,"categories":null,"content":"è¿˜æ˜¯å¤§ä½¬çš„æ€è·¯å¼ºå•Šã€‚\né¢˜è§£ æˆ‘ä»¬å¯ä»¥å¾—åˆ°æ‰€æœ‰æ¨¡$x$ç›¸åŒçš„æ•°é€šè¿‡åŠ æˆ–å‡$x$æ‰€ä»¥æˆ‘ä»¬åªå…³æ³¨$a_i\\bmod x$ã€‚ä¸ºäº†ä½¿mexæœ€å¤§åŒ–ï¼Œæˆ‘ä»¬éœ€è¦ä»0å¼€å§‹å°½å¯èƒ½é•¿çš„è¿ç»­çš„æ•°ã€‚åœ¨æ¨¡çš„æ„ä¹‰ä¸‹ï¼Œä¹Ÿå°±æ˜¯è¯´$1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$ã€‚æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä¿å­˜åŒä½™ç±»é‡Œçš„æ•°çš„ä¸ªæ•°ç„¶åæ¯æ¬¡è¯¢é—®åå°è¯•å¢åŠ ç­”æ¡ˆå°±è¡Œäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1579651200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1579651200,"objectID":"370e1e6f589ad3869ea3d83ad7d39ccc","permalink":"https://tgc54.com/zh/post/cf1294d/","publishdate":"2020-01-22T00:00:00Z","relpermalink":"/zh/post/cf1294d/","section":"post","summary":"è¿˜æ˜¯å¤§ä½¬çš„æ€è·¯å¼ºå•Šã€‚\n","tags":["æ•°å­¦"],"title":"Codeforces 1294D - MEX maximizing é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜æ„ï¼š å®šä¹‰å¦‚ä¸‹åºåˆ—çš„å˜æ¢ï¼ˆç”±ä¸€ä¸ªå·²çŸ¥åºåˆ—ç”Ÿæˆå¦ä¸€ä¸ªåºåˆ—ï¼‰ï¼š\nå¦‚æœåºåˆ—æ˜¯ç©ºçš„åˆ™åœæ­¢ï¼Œå¦åˆ™åœ¨æ–°åºåˆ—çš„æœ€ååŠ ä¸Šå½“å‰åºåˆ—æ‰€æœ‰å…ƒç´ çš„gcdï¼Œç„¶åä»åŸåºåˆ—ä¸­ç§»é™¤ä¸€ä¸ªå…ƒç´ ã€‚é‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°åœæ­¢ï¼Œé—®èƒ½å¾—åˆ°çš„æœ€å¤§å­—å…¸åºçš„åºåˆ—ã€‚\né¢˜å¾ˆç®€å•ï¼Œç›¸ä¿¡èªæ˜çš„ä½ ä¸€å®šèƒ½åšå‡ºæ¥ã€‚\næ€è·¯ å¾ˆæ˜¾ç„¶ï¼Œå‰é¢å‡ ä¸ªæ•°å¿…ç„¶æ˜¯1ï¼Œæ‰€ä»¥è¦æƒ³è®©å­—å…¸åºå°½é‡å¤§å°±å¾—å°½å¿«å‡ºç°åˆ«çš„æ•°ï¼Œè¦æƒ³è®©ä¸€ä¸ªæ•°å‡ºç°å°±å¾—åˆ æ‰å…¨éƒ¨ä¸æ˜¯å®ƒå€æ•°çš„æ•°ï¼Œé‚£ä¹ˆæœ€å¿«èƒ½å‡ºç°çš„æ•°å°±æ˜¯2äº†ï¼Œåªè¦æŠŠæ‰€æœ‰å¥‡æ•°åˆ æ‰å°±è¡Œäº†ã€‚ç„¶åå°±å‰©ä¸‹äº†ä¸€å †å¶æ•°ï¼Œæ˜¯ä¸æ˜¯çœ‹èµ·æ¥ä¼¼æ›¾ç›¸è¯†ï¼Ÿæ²¡é”™ä»–åˆå˜æˆäº†åˆšæ‰çš„é—®é¢˜åªä¸è¿‡æ‰€æœ‰æ•°éƒ½ä¹˜äº†2ï¼ˆç¦æ­¢å¥—å¨ƒï¼‰ã€‚é‚£å•¥æ—¶å€™åœå‘¢ï¼Ÿå½“nå°äº3çš„æ—¶å€™ï¼Œå› ä¸ºæ­¤æ—¶æ— æ³•ç”¨åˆšæ‰çš„è§„å¾‹ã€‚\næ˜¯ä¸æ˜¯å¾ˆæœ‰æ„æ€å‘¢ï¼Ÿå…¶å®é€’å½’çš„é¢˜éƒ½æŒºæœ‰æ„æ€çš„ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); void solve(int x,int mul){ if(x==1) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;2*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==3) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;3*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else{ for(int i=1;i\u0026lt;=x;i+=2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; solve(x/2,mul*2); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; solve(n,1); return 0; } ","date":1578873600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1578873600,"objectID":"9e08341a5b2753d35d2e75658b20e5dd","permalink":"https://tgc54.com/zh/post/cf1059c/","publishdate":"2020-01-13T00:00:00Z","relpermalink":"/zh/post/cf1059c/","section":"post","summary":"","tags":["æ„é€ "],"title":"Codeforces 1059C - Sequence Transformation é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"long longå¼€å°äº†ï¼Œè¡€çš„æ•™è®­ã€‚\né¢˜è§£ ä¸éš¾çœ‹å‡º$a$å’Œ$b$å¿…é¡»æ˜¯äº’è´¨çš„ï¼Œæˆ‘ä»¬è´¨å› æ•°åˆ†è§£Xï¼Œæœ€å¤šæœ‰11ä¸ªä¸åŒçš„è´¨å› æ•°å› ä¸ºå‰12ä¸ªè´¨å› æ•°çš„ç§¯å¤§äº$1\\cdot 10^{12}$ã€‚æˆ‘ä»¬å¯ä»¥æš´åŠ›æšä¸¾æ‰€æœ‰çš„åˆ†é…æƒ…å†µæ¥å¾—åˆ°æœ€ä¼˜çš„ç­”æ¡ˆã€‚\nå¦ä¸€ç§è§£æ³•æ˜¯éå†Xçš„æ‰€æœ‰å› æ•°$p$ç„¶ååˆ¤æ–­$\\gcd(d,\\frac X d)$æ˜¯å¦æ˜¯1å¹¶æ›´æ–°ç­”æ¡ˆã€‚\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1578614400,"objectID":"b4f1d488728f6d503cb83e6f93bd6e0a","permalink":"https://tgc54.com/zh/post/cf1285c/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"/zh/post/cf1285c/","section":"post","summary":"long longå¼€å°äº†ï¼Œè¡€çš„æ•™è®­ã€‚\n","tags":["æ•°å­¦","æ•°è®º"],"title":"Codeforces 1285C - Fadi and LCM é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"Almost\né¢˜è§£ æˆ‘ä»¬ä»æœ€é«˜ä½å¼€å§‹å› ä¸ºæœ€é«˜ä½å¯¹æ•°çš„å½±å“æœ€å¤§ã€‚æˆ‘ä»¬éœ€è¦æŠŠæ‰€æœ‰æ•°åˆ†æˆä¸¤ç»„ï¼Œä¸€ç»„æ˜¯å½“å‰ä½ä¸º1çš„æ•°ï¼Œå¦ä¸€ç»„æ˜¯å½“å‰ä½ä¸º0çš„æ•°ã€‚å¦‚æœå…¶ä¸­ä¸€ç»„æ˜¯ç©ºçš„é‚£ä¹ˆæˆ‘ä»¬æ€»æ˜¯å¯ä»¥ä½¿è¿™ä¸€ä½å˜æˆ0ç„¶ååˆ°ä¸‹ä¸€ä½ã€‚å¦åˆ™è¿™ä¸€ä½æ€»ä¼šæœ‰1ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦å¯¹é‚£ä¸¤ç»„è§£å†³åŒæ ·çš„é—®é¢˜æ¥çŸ¥é“è¿™ä½æ˜¯å¡«1è¿˜æ˜¯0ï¼Œè¿™å¾ˆæ˜æ˜¾æ˜¯ä¸ªé€’å½’ã€‚è®¾é‚£ä¸¤ç»„çš„ç­”æ¡ˆåˆ†åˆ«æ˜¯$ans_1$å’Œ$ans_0$ï¼Œå½“å‰åœ¨ç¬¬$i$ä½ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯$2^i+\\min(ans_1,ans_0)$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1578614400,"objectID":"02a0c7e5f6bf33acb0e7be84b83ae1af","permalink":"https://tgc54.com/zh/post/cf1285d/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"/zh/post/cf1285d/","section":"post","summary":"Almost\n","tags":["æ„é€ ","åˆ†æ²»"],"title":"Codeforces 1285D - Dr. Evil Underscores é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"InTerEStinG.\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç”¨300ä¸ªaå’Œ300ä¸ªbæ¥çŸ¥é“aå’Œbçš„ä¸ªæ•°ã€‚åŒæ—¶ç­”æ¡ˆçš„é•¿åº¦å°±æ˜¯ä»–ä»¬çš„å’Œã€‚\nç„¶åå‡è®¾ç­”æ¡ˆéƒ½æ˜¯aï¼Œå¦‚æœæˆ‘ä»¬æŠŠå…¶ä¸­ä¸€ä½æ¢æˆbé‚£ä¹ˆç­”æ¡ˆè¦ä¹ˆæ˜¯bä¸ªä¸ªæ•°+1è¦ä¹ˆæ•°bçš„ä¸ªæ•°-1ï¼Œå¦‚æœæ˜¯-1é‚£ä¸ªé‚£ä¸€ä½å°±æ˜¯bå¦åˆ™æ˜¯aã€‚å¯¹æ‰€æœ‰ä½ç½®é‡å¤ä¸Šè¿°æ“ä½œå°±åŸºæœ¬æ˜¯ç­”æ¡ˆäº†ã€‚\næ³¨æ„æ­¤æ—¶æˆ‘ä»¬ç”¨äº†$n+3$æ¬¡è¯¢é—®ï¼Œè¶…è¿‡äº†é™åˆ¶ï¼Œä½†å…¶å®æœ€åä¸€ä½ä¸ç”¨è¯¢é—®ï¼Œç”¨å‰é¢çš„ä¿¡æ¯å°±èƒ½ç®—å‡ºæ¥ã€‚\n","date":1578268800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1578268800,"objectID":"c4e5213e584a2f4a020290bfce132ad7","permalink":"https://tgc54.com/zh/post/cf1282d/","publishdate":"2020-01-06T00:00:00Z","relpermalink":"/zh/post/cf1282d/","section":"post","summary":"InTerEStinG.\n","tags":["æ„é€ "],"title":"Codeforces 1282D - Enchanted Artifact é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ–°å¹´ç¬¬ä¸€poï¼\né¢˜è§£ è¿™ä¸ªé¢˜æˆ‘ä»¬ç”¨å¹¶æŸ¥é›†æ¥åˆå¹¶é›†åˆå¹¶ç”¨std::list æˆ– std::vectoræ¥ç»´æŠ¤æ¯ä¸ªé›†åˆé‡Œé¢çš„å…ƒç´ ã€‚ï¼ˆç†è®ºä¸Šæ¥è¯´liståº”è¯¥å¿«å¾ˆå¤šï¼Œä½†æäº¤åçš„è¿è¡Œæ—¶é—´å·®ä¸å¤šï¼‰\nå…·ä½“æ­¥éª¤å°±æ˜¯ï¼š\næ‰¾åˆ°ä¸¤ä¸ªçŒ«çš„ç¥–å…ˆçš„id åˆå¹¶ä¸¤ä¸ªé›†åˆï¼Œå¹¶ä¸”æ‹¼æ¥ä¸¤ä¸ªé“¾è¡¨ï¼ˆæˆ–è€…æ•°ç»„ï¼‰ Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1577836800,"objectID":"d1df1f6a7364297b325226780e9e24b4","permalink":"https://tgc54.com/zh/post/cf1131f/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/zh/post/cf1131f/","section":"post","summary":"æ–°å¹´ç¬¬ä¸€poï¼\n","tags":["å¹¶æŸ¥é›†"],"title":"Codeforces 1131F - Asya And Kittens é¢˜è§£","type":"post"},{"authors":null,"categories":null,"content":"è½¬çœ¼å°±åˆ°äº†2019å¹´çš„æœ€åä¸€å¤©äº†ã€‚çœ‹åˆ°äº†å¾ˆå¤šäººçš„å›é¡¾å’Œæ€»ç»“ï¼Œåˆæƒ³åˆ°äº†ä»Šå¹´å‘ç”Ÿçš„ä¸€äº›äº‹æƒ…ï¼Œå¿ƒæƒ³æˆ‘ä¹Ÿå¯ä»¥å†™ç‚¹æµæ°´è´¦å•Šã€‚\n2019å‘ç”Ÿçš„æœ€å¤§çš„äº‹ï¼Œè«è¿‡äºæˆ‘ä»ä¸­å›½æ¥åˆ°äº†åŠ æ‹¿å¤§ã€‚å½“ç„¶ä¹Ÿæœ‰å¾ˆå¤šåˆ«çš„äº‹æƒ…å€¼å¾—å›å¿†ï¼šå­¦äº†è‡ªç”±æ³³ã€æ‰“äº†åŒºåŸŸèµ›ã€æ¡¥å¼sub20ã€å­¦ä¼šåšèœâ€¦â€¦\nå…ˆè¯´è¯´ç•™å­¦ï¼Œè¿™ä¸ªå†³å®šå…¶å®æ¯”è¾ƒçªç„¶ï¼Œä½†è€ƒè™‘åˆ°æ—¶é—´æœ‰ç‚¹æ™šï¼Œæ‰€ä»¥å‡†å¤‡çš„è¿‡ç¨‹ä¹Ÿæ˜¯ç´§é”£å¯†é¼“ã€‚å¯¹æˆ‘æ¥è¯´æœ€å¤§çš„æŒ‘æˆ˜å°±æ˜¯è€ƒé›…æ€ï¼ŒæŠ¥äº†ä¸ªç½‘è¯¾ï¼Œå­¦ä¸€æ•´ä¸ªå¯’å‡çš„æ—¶é—´ï¼Œä½†è‡ªå·±å´æ²¡å¤ªåŠªåŠ›ï¼Œé˜…è¯»å’Œå¬åŠ›ç›¸å¯¹ç®€å•ï¼Œè‡ªå·±æœ€æ‹…å¿ƒçš„è¿˜æ˜¯å†™ä½œå’Œå£è¯­ï¼Œå°¤å…¶æ˜¯å£è¯­ï¼Œå› ä¸ºæ˜¯æœ€éš¾ç»ƒä¹ çš„ï¼Œå†åŠ ä¸Šè‡ªå·±ä¹Ÿæ²¡è®¤çœŸå‡†å¤‡ç´ æï¼Œä»¥è‡³äºè€ƒè¯•å‰å¤•å¼‚å¸¸ç´§å¼ ï¼Œæœç„¶æœ€åæˆç»©åªæœ‰5.5ã€‚æ­¤æ—¶å¸Œæœ›å…¨éƒ½æ”¾åœ¨äº†ä¸‹ä¸€æ¬¡è€ƒè¯•ä¸Šé¢ï¼Œä¸¤æ¬¡è€ƒè¯•ä¸­é—´çš„åå‡ å¤©ä¹Ÿå…¨ç”¨åœ¨äº†å‡†å¤‡å£è¯­ä¸Šï¼Œå€¼å¾—åº†å¹¸çš„æ˜¯ç¢°åˆ°äº†è‡ªå·±æ¯”è¾ƒç†Ÿæ‚‰çš„è¯é¢˜ï¼Œè‡ªæˆ‘æ„Ÿè§‰è‰¯å¥½ã€‚å¥½æ­¹è¾¾åˆ°äº†ä¹‹å‰çš„ç›®æ ‡ï¼ˆè™½ç„¶åªæœ‰6åˆ†ï¼‰ã€‚ä»å¹´åˆå¼€å§‹å‡†å¤‡ä¸€ç›´åˆ°4æœˆä¸­æ—¬æ‹¿åˆ°æˆç»©ï¼Œå†åˆ°4æœˆåº•æ‹¿åˆ°çº¦å…‹çš„offerï¼Œè¿™ä»¶äº‹æ€»ç®—å‘Šä¸€æ®µè½ã€‚ è¿™ä¸€å¹´ä¹Ÿæ˜¯acmèµ·æ­¥çš„ç¬¬ä¸€å¹´ï¼Œè™½ç„¶ä¸­é—´ç»å†äº†ä¸€äº›æ³¢æŠ˜ï¼Œä½†æœ€åè¿˜æ˜¯å†³å®šèµ°åœ¨æ¡è·¯ã€‚å¯’å‡è®­ç»ƒæ‰“å¼€äº†ç®—æ³•è¿›é˜¶çš„é—¨ï¼Œå­¦æœŸåˆšå¼€å§‹è®­ç»ƒè¿˜æ¯”è¾ƒæ­£å¸¸ï¼Œè€ƒå®Œé›…æ€ä¹‹åå°±å¼€å§‹æ”¾é£è‡ªæˆ‘ï¼Œå¤©å¤©æ³¡åœ¨å®éªŒå®¤ï¼Œæœ‰æ®µæ—¶é—´å°±æ˜¯å¤©å¤©æ•²çº¿æ®µæ ‘ï¼Œæœ€ååŸºæœ¬ä¸Šåšå®Œäº† â€œå¤§å¯çº¿æ®µæ ‘26é¢˜â€,å½“æ—¶æ„Ÿè§‰è¿˜æ˜¯æƒ³å½“çˆ½çš„~æœŸé—´æ‰“äº†åŒ—äº¤æ ¡èµ›ï¼Œå¡åœ¨äº†é“é¢˜æ„ä¸æ¸…çš„çƒ‚é¢˜ä¸Šï¼Œè¢«åŒ—äº¤å¤§ä½¬åŠæ‰“ã€‚è¿˜å»äº†åŒ—å·¥æ‰“äº†ç¨‹åºè®¾è®¡å¤©æ¢¯èµ›ï¼Œæ·±åˆ»ä½“ä¼šåˆ°äº†ä»€ä¹ˆå«â€œæš´åŠ›ç¢¾æ ‡ç®—â€ï¼Œæœ€åæ··äº†ä¸ªé“œå¥–ã€‚æ”¾å‡å‰æ‰“äº†åŒ—æ—æ ¡èµ›ï¼ŒçŸ®å­é‡Œé¢æ‹”é«˜ä¸ªï¼Œè¿æ°”å¥½å‡ºäº†6é¢˜æ··äº†ç¬¬å››è¿˜èµšäº†200å—ï¼Œä¸å¾—ä¸è¯´è¿™å¥–é‡‘è¿˜æ˜¯å¾ˆå¤§æ°”çš„ã€‚\nè½¬çœ¼åˆ°äº†æš‘å‡ï¼Œç”±äºæš‘å‡é›†è®­å‰è¿˜æœ‰å°å­¦æœŸï¼Œå†åŠ ä¸Šåœ¨åŒ—äº¬ä¹Ÿæ²¡ä»€ä¹ˆå¥½å¾…çš„äº†ï¼Œäºæ˜¯å°±æ—©æ—©å›äº†å®¶ï¼Œæš‘å‡é›†è®­ä¹Ÿå°±ä¸æäº†ï¼Œé”™è¿‡äº†ä¸€äº›ç®—æ³•ï¼Œä¸è¿‡ç°åœ¨çœ‹æ¥å¤§éƒ¨åˆ†ä¹Ÿæ²¡æœºä¼šç”¨æ¯•ç«Ÿç®€å•é¢˜è¿˜åšä¸å¥½ã€‚åœ¨å®¶çš„æ—¶å€™è€ƒè™‘åˆ°äº†å»äº†åŠ æ‹¿å¤§è¿˜è¦ä¸è¦ç»§ç»­æ‰“acmï¼Œä½†åˆä¸çŸ¥é“é‚£è¾¹çš„æ¯”èµ›æƒ…å†µï¼Œäºæ˜¯å°±å…ˆé€‰æ‹©äº†æš‚æ—¶æ”¾ä¸‹acmï¼Œç­‰åˆ°äº†é‚£è¾¹å†è¯´ï¼Œäºæ˜¯ä¸€ä¸ªæš‘å‡æ²¡æ€ä¹ˆæ•²ä»£ç ã€‚\nåˆ°äº†çº¦å…‹æ²¡å‡ å¤©ä¾¿æ”¶åˆ°äº†å…³äºecna regional contesté€‰æ‹”èµ›çš„é‚®ä»¶ï¼Œå¯æŠŠæˆ‘æ¿€åŠ¨åäº†ï¼Œä¸å‡ºæ„å¤–çš„æ‹¿åˆ°äº†å‚èµ›åé¢ï¼Œæœ€å6ä¸ªäººé‡Œé¢3ä¸ªç”¨C++çš„æ­£å¥½å‡‘ä¸€ä¸ªé˜Ÿï¼Œæäº†ä¸€åœºè®­ç»ƒå‘ç°é˜Ÿå‹å¹¶ä¸å¼ºï¼Œé‚£ä»Šå¹´å°±å½“å»ç©ç©ç†Ÿæ‚‰æ¯”èµ›äº†ã€‚å› ä¸ºé˜Ÿå‹éƒ½ä¸ä½åœ¨å­¦æ ¡ï¼Œä¸€èµ·è®­ç»ƒä¸å¤ªæ–¹ä¾¿ï¼Œæ‰€ä»¥è¿˜æ˜¯ä»¥ä¸ªäººè®­ç»ƒä¸ºä¸»ï¼ŒæœŸé—´è‡ªå·±ä¹Ÿå¼€å§‹æ‰“cfï¼Œç åŠ›æœ‰æ‰€æ¢å¤ã€‚\næ¯”èµ›åœ¨æ¸©èå¤§å­¦ï¼Œæ•™ç»ƒå¼€è½¦å¸¦æˆ‘ä»¬è¿‡å»ï¼Œä¸‹åˆåˆ°äº†å…ˆç­¾åˆ°ç„¶åå°±ç­‰ç€çƒ­èº«èµ›ï¼Œæ»‘å¤§æ²¡æœ‰æ”¾æ°´å¾ˆå¿«å°±akäº†ï¼Œè€Œæˆ‘ä»¬æœ€å1åˆ†é’Ÿæ‰è¿‡äº†4é¢˜æ’ç¬¬10ï¼Œæ¯•ç«Ÿå¥½å¤šæ”¾æ°´çš„ï¼Œæ„Ÿè§‰çŠ¶æ€è¿˜è¡Œï¼Œç»“æŸä¹‹ååƒäº†ç‚¹ä¸»åŠæ–¹æä¾›çš„æŠ«è¨ç„¶åæˆ‘ä»¬å°±å»å®¾é¦†äº†ï¼Œæ•™ç»ƒå®šçš„å®¾é¦†ç¦»å­¦æ ¡å¾ˆè¿‘ï¼Œæ¡ä»¶ä¹Ÿç›¸å½“å¥½ï¼ˆé™¤äº†æ²¡æœ‰çƒ­æ°´æ´—æ¾¡ï¼‰æœ¬æƒ³æ—©ç‚¹ç¡çš„ï¼Œç»“æœå’Œé˜Ÿå‹èŠåˆ°12ç‚¹å¤šâ€¦â€¦ ç¬¬äºŒå¤©ä¸€æ—©åƒäº†æ—©é¥­å°±èµ¶èµ´èµ›åœºï¼Œè™½è¯´æ˜¯æ¥ç©ç©çš„ï¼Œä½†æ¯”èµ›å¼€å§‹å‰è¿˜æ˜¯ç›¸å½“ç´§å¼ çš„ï¼ŒæŒ‰ç…§ä¹‹å‰çš„è®¡åˆ’ï¼Œä¸‰ä¸ªäººåˆ†åˆ«è¯»å‰ä¸­åï¼Œæˆ‘å¯èƒ½æ˜¯æ€¥äºæƒ³å¿«é€Ÿæ‰¾åˆ°ç­¾åˆ°é¢˜ï¼Œè¯»å®Œåè€Œæ²¡ä»€ä¹ˆå°è±¡ï¼Œä»¥è‡³äºç­¾åˆ°é¢˜ä¹Ÿè§‰å¾—æ¯”è¾ƒéš¾ï¼Œè€Œé˜Ÿå‹ä¹Ÿè¯»åˆ°äº†ç­¾åˆ°é¢˜ä½†ç»™æˆ‘è§£é‡Šçš„æ—¶å€™æ²¡æŠ“ä½é‡ç‚¹ï¼Œè¯´äº†åŠå¤©æˆ‘æ‰æ˜ç™½ï¼Œå°±æ˜¯åœ¨ä¸€ä¸ªä¸å•è°ƒçš„åºåˆ—é‡Œå¼ºè¡ŒäºŒåˆ†ï¼Œçœ‹æ˜¯å¦èƒ½æ‰¾åˆ°æŸä¸ªæ•°ï¼Œç»“æœæˆ‘ç”¨äº†lower_bound()waäº†ä¸¤å‘æœ€åæ‰‹å†™äºŒåˆ†æ‰è¿‡çš„ï¼Œè€Œæ­¤æ—¶å·²ç»52åˆ†é’Ÿäº†ï¼Œå’Œé¢„è®¡çš„èŠ‚å¥ï¼ˆ1å°æ—¶åšå®Œç­¾åˆ°ï¼‰ä¸¥é‡ä¸ç¬¦ï¼Œä½†è¿˜å¥½ä¹Ÿæ²¡æ‹–å¤ªä¹…ï¼Œä¸€ä¸ªåŠå°æ—¶çš„æ—¶å€™åšå®Œäº†æ‰€æœ‰ä¸‰é“ç­¾åˆ°ã€‚\nç„¶åå‘ç°ä¸€ä¸ªå¾ˆå¤šäººè¿‡çš„dpé¢˜ï¼Œä½†è‡ªå·±dpå¾ˆå·®ï¼Œå†™äº†ä¸€ä¸ªwaäº†ä¹‹åå‘ç°æ€è·¯æœ‰é—®é¢˜ï¼Œå°±å¼€å§‹æ€€ç–‘æ˜¯ä¸æ˜¯dpï¼Œæƒ³äº†å¾ˆä¹…ä¹Ÿæ²¡ä»€ä¹ˆæƒ³æ³•å°±å»çœ‹åˆ«çš„é¢˜äº†ï¼Œçœ‹åˆ°ä¸€ä¸ªä¸­å›½å‰©ä½™å®šç†çš„æ¿å­é¢˜ç„¶è€Œæ¿å­é‡Œå¹¶æ²¡æœ‰å°ï¼Œå½“æ—¶å†…å¿ƒä¸€ä¸‹å°±å‡‰äº†ï¼Œä¹Ÿæˆä¸ºäº†è¿™æ¬¡æœ€å¤§çš„é—æ†¾ã€‚é˜Ÿå‹è¯´å¯ä»¥å°è¯•æ¨ä¸€ä¸‹ä¸è¿‡æœ€åä¹Ÿæ²¡æ¨å‡ºæ¥ï¼Œæ²¡è¿‡å¤šå°±å‘ç°å‹å¯¹æŠŠé‚£ä¸ªdpé¢˜è¿‡äº†ï¼Œç„¶åé˜Ÿå‹å°±ä¸€å†æé†’æˆ‘è¯´é‚£ä¸ªé¢˜è‚¯å®šä¸éš¾å› ä¸ºå‹é˜Ÿä¸ä¼šå›¾è®ºï¼Œåˆæƒ³äº†å¥½ä¹…çªç„¶å¼€çªå‘ç°å¤šåŠ ä¸€ä¸ªdpçŠ¶æ€å°±è¡Œäº†ï¼Œèµ¶ç´§å»å†™ç„¶è€Œåˆ¤å®šè¾¹ç•Œçš„å‡½æ•°æ²¡å†™å¥½æœ€åæ‰å‘ç°ï¼Œåœ¨è¿˜æœ‰åŠå°æ—¶ç»“æŸçš„æ—¶å€™è¿‡äº†â€¦â€¦æœ€åæˆ‘ä»¬æ’34/120ï¼Œå‹é˜Ÿæ’31ï¼Œä¸å¥½ä¹Ÿä¸åï¼Œåæ­£æ•™ç»ƒæŒºé«˜å…´çš„ã€‚ä½†æˆ‘æ·±çŸ¥è¿™ç»å¯¹ä¸æ˜¯æˆ‘ä»¬çš„æ°´å¹³ã€‚ å›å­¦æ ¡ä¹‹åä¸€åˆ‡åˆå›å½’æ­£å¸¸ï¼Œåœ¨å¯’å‡ç–¯ç‹‚æ‰åˆ†ä¹‹åå‘ç°ä¹‹å‰åœ¨åœ°å¤§çš„è®­ç»ƒéå¸¸æœ‰é—®é¢˜ï¼Œéå¸¸ä¸æ³¨é‡åŸºæœ¬åŠŸï¼Œä»¥è‡³äºç»å¸¸å¡åœ¨cé¢˜æˆ–dé¢˜ï¼Œè€Œäº‹å®ä¸Šè¿™äº›é¢˜éƒ½ä¸éœ€è¦å¤šä¹ˆé«˜çº§çš„ç®—æ³•ï¼Œäºæ˜¯è‡ªå·±å¼€å§‹ç»ƒä¸€äº›ç®€å•æˆ–ä¸­ç­‰éš¾åº¦çš„æš´åŠ›å’Œæ„é€ é¢˜ï¼Œç»ˆäºåœ¨2019æœ€åä¸€åœºæ­¢ä½äº†æ‰åˆ†åŒæ—¶ä¹Ÿä¿ä½äº†æ­£çš„å‡€åˆ†æ•°å˜åŒ–ã€‚\næœ€åå†è¯´è¯´åšé¥­å§ï¼Œå…¶å®è¿™æŒºç¥å¥‡çš„ï¼Œæ¥ä¹‹å‰å®Œå…¨ä¸ä¼šåšé¥­ï¼Œæ„Ÿè§‰è‡ªå·±æ¥äº†ä¸€ä¸‹å°±ä¼šäº†å“ˆå“ˆï¼Œæ¥çš„ç¬¬äºŒå¤©å°±å¼€å§‹æ‰¾èƒ½ä¹°èœçš„è¶…å¸‚ï¼Œè¿˜å¥½å­¦æ ¡è¥¿è¾¹æœ‰ä¸€ä¸ªäºšï¼ˆä¸­ï¼‰æ´²ï¼ˆå›½ï¼‰è¶…å¸‚ï¼Œè¿™å¯çœŸæ˜¯å¤ªæ–¹ä¾¿äº†ã€‚é£Ÿæè§£å†³ä¹‹åå°±æ˜¯æŠ€æœ¯äº†ï¼Œåœ¨è€çˆ¸å’Œç½‘ä¸Šçš„èœè°±æŒ‡å¯¼ä¹‹ä¸‹æ…¢æ…¢å½¢æˆäº†è‡ªå·±çš„ä¸€å¥—ç†è®ºï¼Œå…¶å®ä¹Ÿæ²¡ä»€ä¹ˆéº»çƒ¦ï¼Œç®€å•çš„å®¶å¸¸èœå°±è¶³å¤Ÿåº”ä»˜æ¯æ—¥é¥®é£Ÿäº†ã€‚å¯¹äºå­¦ä¼šåšèœè¿™ä»¶äº‹è‡ªå·±çœŸçš„æ˜¯å¾ˆå¼€å¿ƒçš„ï¼Œæ—¢çœé’±åˆåˆè‡ªå·±å£ï¼Œè¿™ä¹Ÿç®—æ˜¯ä¸€é¡¹é‡è¦çš„ç”Ÿæ´»æŠ€èƒ½å•Šã€‚\n2019çœŸçš„æ˜¯æ”¶è·é¢‡ä¸°çš„ä¸€å¹´ï¼Œå¸Œæœ›è‡ªå·±åœ¨2020èƒ½ç»§ç»­è¿›æ­¥ï¼Œç«‹å‡ ä¸ªflag:\ncf1800åˆ† åŒºåŸŸèµ›è¿›å‰20 æˆç»©ä¿æŒåœ¨Aä»¥ä¸Š ä¸‰é€Ÿè‡³å°‘sub15 åŠ æ²¹ï¼Œå¥¥åŠ›ç»™ï¼\n","date":1577750400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1577750400,"objectID":"93093dfcf8e9f9d5288e8c8d8c0d8c17","permalink":"https://tgc54.com/zh/post/2019summary/","publishdate":"2019-12-31T00:00:00Z","relpermalink":"/zh/post/2019summary/","section":"post","summary":"è½¬çœ¼å°±åˆ°äº†2019å¹´çš„æœ€åä¸€å¤©äº†ã€‚çœ‹åˆ°äº†å¾ˆå¤šäººçš„å›é¡¾å’Œæ€»ç»“ï¼Œåˆæƒ³åˆ°äº†ä»Šå¹´å‘ç”Ÿçš„ä¸€äº›äº‹æƒ…ï¼Œå¿ƒæƒ³æˆ‘ä¹Ÿå¯ä»¥å†™ç‚¹æµæ°´è´¦å•Šã€‚\n","tags":null,"title":"æˆ‘çš„2019","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"è¿™è·Ÿæš´åŠ›åˆæœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿ\né¢˜è§£ æˆ‘ä»¬å…ˆå°†æ‰€æœ‰çº¿æ®µçš„ä»¥pair\u0026lt;èµ·ç‚¹æˆ–ç»ˆç‚¹çš„åæ ‡,çº¿æ®µçš„åºå·\u0026gt;çš„å½¢å¼å­˜åˆ°æ•°ç»„é‡Œï¼Œç„¶åå†å°†æ•°ç»„æ’åºï¼Œç„¶åéå†æ•°ç»„ã€‚åŒæ—¶æˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸€ä¸ªâ€œå¼€æ”¾çš„çº¿æ®µâ€çš„å³ç«¯ç‚¹çš„é›†åˆã€‚å½“æˆ‘ä»¬æ·»åŠ ä¸€æ¡æ–°çš„çº¿æ®µæ—¶ï¼Œéå†é›†åˆï¼Œç„¶åæ‰¾åˆ°æ¯”æ–°çº¿æ®µæ—©ç»“æŸçš„çº¿æ®µã€‚\nè¿™çœ‹èµ·æ¥æ˜¯ä¸æ˜¯å¾ˆåƒæš´åŠ›ï¼Ÿå¦‚æœè¦æ˜¯å¤„ç†å®Œæ‰€æœ‰çº¿æ®µæ˜¯è‚¯å®šè¶…æ—¶çš„ï¼Œä½†æ˜¯å¦‚æœäº¤ç‚¹çš„ä¸ªæ•°å·²ç»å¤§äº$n-1$äº†ï¼Œé‚£ä¹ˆç­”æ¡ˆè‚¯å®šæ˜¯noï¼Œæ‰€ä»¥ç›´æ¥ç»“æŸå°±è¡Œã€‚\næœ€åè¿˜è¦æ£€æŸ¥ä¸€ä¸‹å›¾çš„è¿é€šæ€§ï¼Œç”¨dfsæˆ–å¹¶æŸ¥é›†éƒ½è¡Œã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } ","date":1576972800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576972800,"objectID":"b57dac5f8aba4a2cdb2c93beb7e3a339","permalink":"https://tgc54.com/zh/post/cf1278d/","publishdate":"2019-12-22T00:00:00Z","relpermalink":"/zh/post/cf1278d/","section":"post","summary":"è¿™è·Ÿæš´åŠ›åˆæœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿ\n","tags":["æ•°æ®ç»“æ„","å¹¶æŸ¥é›†","æ ‘","DFS"],"title":"Codeforces 1248D - Segment Tree é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"Good DFS problem.\né¢˜è§£ æˆ‘ä»¬éœ€è¦ç”¨DFSè®¡ç®—$sum_v$â€”â€”$v$çš„å­æ ‘é‡Œæ‰€æœ‰æ•°çš„å’Œï¼Œä»¥åŠ$m1_v$ å’Œ $m2_v$â€”â€”vçš„å­æ ‘é‡Œæ‰€æœ‰çš„$sum$é‡Œçš„æœ€å¤§å’Œæ¬¡å¤§å€¼(ä¸åŒ…æ‹¬$sum_v$). è®¡ç®—å®Œä¹‹åæ›´æ–°ç­”æ¡ˆã€‚å…·ä½“å®ç°å¯ä»¥çœ‹ä»£ç ï¼ŒæŒºå¥½ç†è§£çš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } ","date":1576972800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576972800,"objectID":"9c292a351ba89ab08deb0a1a522c55a5","permalink":"https://tgc54.com/zh/post/cf743d/","publishdate":"2019-12-22T00:00:00Z","relpermalink":"/zh/post/cf743d/","section":"post","summary":"Good DFS problem.\n","tags":["DFS","åŠ¨æ€è§„åˆ’"],"title":"Codeforces 743D - Chloe and pleasant prizes é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"è¶Šæ¥è¶Šèœäº†\né¢˜è§£ è´ªå¿ƒçš„ç­–ç•¥æ˜¯ï¼šéå†æ‰€æœ‰ç‚¹ï¼Œå½“æˆ‘ä»¬å‘ç°æœ‰è¢«è¶…è¿‡$k$æ¡çº¿æ®µè¦†ç›–çš„ç‚¹æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥ç§»é™¤å³ç«¯ç‚¹æœ€é å³çš„çº¿æ®µã€‚\nä¸ºäº†å®ç°æˆ‘ä»¬çš„ç­–ç•¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°ç»„$open_i$ æ¥å­˜å‚¨ä»¥ç‚¹$i$å¼€å§‹çš„çº¿æ®µï¼Œå’Œæ•°ç»„$close_i$æ¥å­˜å‚¨ä»¥ç‚¹$i$ç»“æŸçš„çº¿æ®µã€‚æˆ‘ä»¬åŒæ—¶è¿˜éœ€è¦ç»´æŠ¤è¦†ç›–å½“å‰ç‚¹çš„é›†åˆï¼Œä»¥åŠä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥å¯»æ‰¾å³ç«¯ç‚¹æœ€å³çš„çº¿æ®µã€‚\nå…·ä½“æ¥è¯´ï¼Œå°±æ˜¯å¯¹äºæ¯ä¸ªç‚¹ï¼Œæˆ‘ä»¬å…ˆå¾€é›†åˆé‡Œæ’å…¥ä»è¿™ä¸ªç‚¹å¼€å§‹çš„çº¿æ®µï¼Œç„¶åæ‰¾å‡ºåº”è¯¥åˆ é™¤çš„çº¿æ®µå¹¶åˆ é™¤ï¼Œæœ€åä»é›†åˆé‡Œç§»é™¤ä»¥è¿™ä¸ªç‚¹ç»“æŸçš„çº¿æ®µã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1576713600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576713600,"objectID":"de0478ac5e0ce58ef4aa94a973430cc1","permalink":"https://tgc54.com/zh/post/cf1249d2/","publishdate":"2019-12-19T00:00:00Z","relpermalink":"/zh/post/cf1249d2/","section":"post","summary":"è¶Šæ¥è¶Šèœäº†\n","tags":["è´ªå¿ƒ"],"title":"Codeforces 1249D2 - Too Many Segments (hard version) é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ å¾ˆæ˜æ˜¾å¸ç¯·åº”è¯¥å’Œå­¦æ ¡æŒ¨ç€ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å››ä¸ªå˜é‡æ¥è®°å½•å­¦æ ¡çš„æ¯ä¸€è¾¹æœ‰å‡ ä¸ªæˆ¿å­ï¼Œæœ€åè¾“å‡ºæœ€å¤šçš„é‚£ä¸€è¾¹å³å¯ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } ","date":1576368e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576368e3,"objectID":"81c372b990730049aef0272f07bffa28","permalink":"https://tgc54.com/zh/post/cf1271c/","publishdate":"2019-12-15T00:00:00Z","relpermalink":"/zh/post/cf1271c/","section":"post","summary":"","tags":null,"title":"Codeforces 1271C - Shawarma Tent é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"é¢˜è§£ é¦–å…ˆæˆ‘ä»¬è¦è®¡ç®—åœ¨æ¯ä¸ªåŸå ¡é€šå…³æ‰€éœ€è¦çš„æœ€å°‘å‹‡å£«çš„æ•°é‡($req_i$)ï¼Œ è¿™æ ·æˆ‘ä»¬å°±èƒ½çŸ¥é“åœ¨æ‹›å‹Ÿä¹‹åæœ‰å¤šå°‘è‡ªç”±æ”¯é…çš„å‹‡å£«($fr_i$)ã€‚$req_i$è¿™ä¹ˆè®¡ç®—$req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$ã€‚$last_i$è¡¨ç¤ºæœ€åä¸€ä¸ªå¯ä»¥æ´¾å‹‡å£«æ¥å®ˆå«åŸå ¡$i$çš„åŸå ¡ã€‚ç°åœ¨é—®é¢˜å°±è½¬åŒ–æˆäº†å¦‚ä½•åˆ†é…å‹‡å£«æ¥å®ˆå«è¿™äº›åŸå ¡ã€‚æˆ‘ä»¬ç”¨è´ªå¿ƒçš„æ€è·¯ï¼šæŒ‰ç…§åŸå ¡çš„é‡è¦ç¨‹åº¦æ¥å®ˆå«ï¼Œå¯¹äºåŸå ¡$i$ï¼Œå¦‚æœæˆ‘ä»¬èƒ½åœ¨$last_i$å‰é¢æ‰¾åˆ°æœ‰ç©ºé—²çš„å‹‡å£«é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å®ˆæŠ¤è¿™ä¸ªåŸå ¡ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } ","date":1576368e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576368e3,"objectID":"4b5209166b360466aa391478e274fcc4","permalink":"https://tgc54.com/zh/post/cf1271d/","publishdate":"2019-12-15T00:00:00Z","relpermalink":"/zh/post/cf1271d/","section":"post","summary":"","tags":["è´ªå¿ƒ","åŠ¨æ€è§„åˆ’"],"title":"Codeforces 1271D - Portals é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ¯”èµ›çš„æ—¶å€™å¤ªè ¢äº†ã€‚\né¢˜è§£ è¿™é¢˜çš„å…³é”®åœ¨äºç­”æ¡ˆçš„ç¬¬ä¸€ä¸ªæ•°è¦ä¹ˆæ˜¯æœ€å°çš„æ•°è¦ä¹ˆæ˜¯ç¬¬äºŒå°çš„æ•°ï¼Œä¸¤ç§æƒ…å†µéƒ½è¯•ä¸€ä¸‹ã€‚å¡«æŸä¸€ä½çš„æ—¶å€™ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½åŠ ä¸€ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½å‡ä¸€ï¼Œå…ˆè¯•å‡1ï¼Œå¦‚æœæ²¡æœ‰å‡1å¯ä»¥ç”¨äº†å°±è¯•åŠ 1ï¼Œå¦‚æœåŠ ä¸€ä¹Ÿæ²¡æœ‰äº†é‚£å°±å¯ä»¥åœæ­¢å»å°è¯•ä»¥å¦ä¸€ä¸ªæ•°å¼€å¤´çš„æƒ…å†µäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } ","date":1575590400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575590400,"objectID":"d127657593bb73eebf144971cf79e2a3","permalink":"https://tgc54.com/zh/post/cf1265d/","publishdate":"2019-12-06T00:00:00Z","relpermalink":"/zh/post/cf1265d/","section":"post","summary":"æ¯”èµ›çš„æ—¶å€™å¤ªè ¢äº†ã€‚\n","tags":["è´ªå¿ƒ"],"title":"Codeforces 1265D - Beautiful Sequence é¢˜è§£","type":"post"},{"authors":null,"categories":null,"content":"è§£æ³•åŠ¨ç”»\næ‰“ä¹± L2 R2 U L2 B2 F2 U R2 Dâ€™ Uâ€™ Fâ€™ R F2 D B2 D2 Bâ€™ Fâ€™ L B\nè§£æ³• yâ€™ //inspection\nFâ€™ Dâ€™ F2 U R Bâ€™ //FB\nrâ€™ Uâ€™ râ€™ U2 r U M râ€™ Uâ€™ r Mâ€™ Uâ€™ R U Râ€™ Uâ€™ R U Râ€™ //SB\nUâ€™ R U Râ€™ Uâ€™ Râ€™ F R Fâ€™ //CMLL\nMâ€™ U M2â€™ Uâ€™ M U2 Mâ€™ U M U2 Mâ€™ U2 //LSE\n46 ETM, 3.7 TPS\n","date":1575504e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575504e3,"objectID":"a1253a3af953ed8eedc26a68e30004bb","permalink":"https://tgc54.com/zh/post/pbreconstruction/","publishdate":"2019-12-05T00:00:00Z","relpermalink":"/zh/post/pbreconstruction/","section":"post","summary":"","tags":null,"title":"12.42 PB å¤ç›˜","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"è§£æ³• é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å‡ ç‚¹æ­£ç¡®åŒ¹é…çš„æ‹¬å·åºåˆ—çš„æ€§è´¨ï¼š\nå¦‚æœæˆ‘ä»¬æŠŠå·¦æ‹¬å·æ¢æˆ1ï¼ŒæŠŠå³æ‹¬å·æ¢æˆ-1çš„è¯ï¼š\nåºåˆ—çš„å’Œä¸º0\nä»»æ„å‰ç¼€å’Œä¸å°äº0\nå‰ç¼€å’Œä¸­æœ€å¤§å€¼å°±æ˜¯åµŒå¥—æœ€å¤šçš„æ‹¬å·æ•°\næ ¹æ®è¿™äº›æ€§è´¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥æ”¯æŒåŒºé—´ä¿®æ”¹å’ŒæŸ¥è¯¢æœ€å€¼çš„æ•°æ®ç»“æ„ï¼Œå¾ˆæ˜æ˜¾ï¼Œå°±æ˜¯çº¿æ®µæ ‘äº†ã€‚\næ³¨æ„ï¼šæ•´ä¸ªåºåˆ—çš„å’Œå¯ä»¥é€šè¿‡æŸ¥è¯¢æœ€åä¸€ä¸ªå…ƒç´ çš„å€¼æ¥å¾—åˆ°ï¼Œqueryå‡½æ•°å°±æ˜¯ä¸ºäº†å¹²è¿™ä¸ªçš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } ","date":1575072e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575072e3,"objectID":"1db3a6deee6eca4507f5dbb7d4292360","permalink":"https://tgc54.com/zh/post/cf1263e/","publishdate":"2019-11-30T00:00:00Z","relpermalink":"/zh/post/cf1263e/","section":"post","summary":"","tags":["æ•°æ®ç»“æ„","çº¿æ®µæ ‘"],"title":"Codeforces 1263E - Editor é¢˜è§£","type":"post"},{"authors":null,"categories":["ç®—æ³•ç¬”è®°"],"content":"è·¯å¾„è®°å½• æˆ‘ä»¬å¼€ä¸€ä¸ªvector\u0026lt;int\u0026gt; pre[N]ç”¨æ¥è®°å½•æŸä¸ªç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼Œåœ¨æ›´æ–°è·ç¦»çš„æ—¶å€™ï¼Œå¦‚æœå½“å‰è·ç¦»æ›´çŸ­å°±èˆå¼ƒæ‰ä¹‹å‰çš„è®°å½•ï¼Œå°†å½“å‰ç‚¹ä½œä¸ºè¢«æ›´æ–°ç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼›å¦‚æœå½“å‰è·ç¦»å’Œæœ€çŸ­è·ç¦»ç›¸ç­‰å°±åœ¨æ•°ç»„é‡ŒåŠ ä¸Šè¿™ä¸ªç‚¹ã€‚\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } æœ€çŸ­è·¯å¾„çš„æ•°é‡ å’Œè·¯å¾„è®°å½•ç±»ä¼¼ï¼Œå¦‚æœæ›´çŸ­å°±è®©æ•°ç›®ç­‰äº1,å¦‚æœä¸€æ ·å°±åŠ 1ã€‚\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } ","date":1573344e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1573344e3,"objectID":"8005e73597383681b447ec8df4b26e1e","permalink":"https://tgc54.com/zh/post/dijkextention/","publishdate":"2019-11-10T00:00:00Z","relpermalink":"/zh/post/dijkextention/","section":"post","summary":"","tags":["æœ€çŸ­è·¯","å›¾è®º"],"title":"Dijkstraçš„ä¸€äº›æ‰©å±•","type":"post"},{"authors":null,"categories":["æ‚é¡¹"],"content":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } ","date":1571097600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1571097600,"objectID":"8eeeff0d19f286de7a6f55006bc6d6f7","permalink":"https://tgc54.com/zh/post/debugconfig/","publishdate":"2019-10-15T00:00:00Z","relpermalink":"/zh/post/debugconfig/","section":"post","summary":"","tags":["VSCode"],"title":"VSCode C++ debug é…ç½®","type":"post"},{"authors":null,"categories":null,"content":"å‡ ä¸ªæœˆå‰çš„ç¬”è®°ï¼Œæ‰ç–å­¦æµ…ï¼Œä»…ä¾›å‚è€ƒ~\nåŸºæœ¬æ¦‚å¿µ PNç‚¹ ä»€ä¹ˆæ˜¯PNç‚¹ Pç‚¹ï¼šå‰ä¸€ä¸ªé€‰æ‰‹ï¼ˆprevious person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…è´¥ç‚¹ã€‚\nNç‚¹ï¼šä¸‹ä¸€ä¸ªé€‰æ‰‹ï¼ˆnext person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…èƒœç‚¹ã€‚\næ³¨æ„ï¼šPNç‚¹æ˜¯ç›¸å¯¹äºæŸä¸ªç‚¹çš„å±æ€§ï¼Œä¸å…ˆåæ‰‹æ— å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´å…ˆæ‰‹çš„Pç‚¹æˆ–åæ‰‹çš„Pç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºæ˜¯å…ˆæ‰‹è¿˜æ—¶åæ‰‹ï¼Œèµ°åˆ°Pç‚¹éƒ½æ˜¯å¿…è´¥çš„ã€‚\nPNç‚¹çš„å±æ€§ æ‰€æœ‰ç»ˆç»“çŠ¶æ€å‡ä¸ºPç‚¹ã€‚\nä»ä»»ä½•Nç‚¹éƒ½è‡³å°‘æœ‰ä¸€ç§æ–¹æ³•è¿›å…¥Pç‚¹ã€‚ï¼ˆå½“å‰ç©å®¶çš„å¿…èƒœç‚¹ä¸€å®šå¯ä»¥èµ°åˆ°ä¸‹ä¸€ä¸ªç©å®¶çš„å¿…è´¥ç‚¹ï¼‰\nä»Pç‚¹åªèƒ½è¿›å…¥Nç‚¹ã€‚ï¼ˆå¦‚æœèƒ½èµ°åˆ°Pç‚¹çš„è¯å°±ç›¸å½“äºèƒœè´Ÿå±€åŠ¿å˜åŒ–äº†ï¼Œè¿™æ ·å°±ä¸æ˜¯å¿…è´¥çš„äº†ï¼‰\næ³¨æ„ï¼šè¿™é‡Œè¯´çš„éƒ½æ˜¯èµ°åˆ°æœ€åçŠ¶æ€çš„ç©å®¶è·èƒœçš„æ¸¸æˆã€‚\nSGå‡½æ•° å¦‚æœæ¸¸æˆæ¡ä»¶æ¯”è¾ƒå¤æ‚ï¼Œä¸ºäº†åˆ¤æ–­æ¯ä¸ªç‚¹çš„èƒœè´ŸçŠ¶æ€ï¼Œå°±éœ€è¦å¼•å…¥SGå‡½æ•°ã€‚\nå®šä¹‰ï¼š $$sg(u)=mex{sg(v)} $$\nå…¶ä¸­vä¸ºuçš„åç»§çŠ¶æ€ï¼Œmexå‡½æ•°æ˜¯ä½œç”¨äºæ•´æ•°é›†åˆçš„å‡½æ•°ï¼Œå‡½æ•°å€¼æ˜¯ä¸å±äºè¯¥é›†åˆçš„æœ€å°è‡ªç„¶æ•°ã€‚\n$$mex(A)=min{k | k\\in\\complement_NA}$$\né‚£ä¹ˆï¼Œç»ˆæ­¢çŠ¶æ€çš„SGå€¼æ˜¾ç„¶ä¸º0ï¼Œå¹¶ä¸”SGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯PçŠ¶æ€ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯NçŠ¶æ€ã€‚ è¯æ˜åˆ™éå¸¸æ˜¾ç„¶ï¼ŒSGå€¼ä¸º0çš„çŠ¶æ€ï¼Œè¯´æ˜å®ƒçš„æ‰€æœ‰åç»§çŠ¶æ€éƒ½ä¸ä¸º0ï¼Œä¹Ÿå°±æ˜¯å®ƒåªèƒ½è½¬ç§»åˆ°é0çŠ¶æ€ï¼Œè€ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€åˆ™ä¸ä¸€æ ·ï¼Œåç»§çŠ¶æ€ä¸€å®šæœ‰0ï¼Œå¯èƒ½æœ‰å…¶ä»–éè´Ÿæ•´æ•°ã€‚é‚£ä¹ˆSGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…è´¥çŠ¶æ€çš„å®šä¹‰ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…èƒœçŠ¶æ€çš„å®šã€‚\næ±‚æ³• ä»å®šä¹‰å¯ä»¥çœ‹å‡ºsgå‡½æ•°ä½¿ç”¨çš„é€’å½’å®šä¹‰ï¼Œæ‰€ä»¥æˆ‘ä»¬æ—¢å¯ä»¥ä»sgä¸º0çš„çŠ¶æ€é€’æ¨ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨é€’å½’çš„æ–¹æ³•æ±‚ã€‚\næœ‰äº›é¢˜ç›®çš„sgå‡½æ•°çš„æœ‰è§„å¾‹çš„ï¼Œé€šè¿‡æ‰“è¡¨æˆ–è€…æ€è€ƒå¯ä»¥å‘ç°è§„å¾‹;æœ‰äº›æ˜¯æ²¡æœ‰è§„å¾‹çš„ï¼Œéœ€è¦è‡ªå·±å†™sgå‡½æ•°æ¥æ‰“è¡¨ã€‚\nä¸€èˆ¬çš„sgå‡½æ•°æ‰“è¡¨æ¨¡æ¿ï¼š æ³¨ï¼šéœ€è¦æ‰“è¡¨çš„ä¸€èˆ¬æ˜¯ç®€å•çš„å–çŸ³å­æ¸¸æˆï¼Œä¸”åœ¨å–çŸ³å­çš„æ•°é‡ä¸Šæœ‰é™åˆ¶ã€‚è¿™ç§é—®é¢˜çš„çŠ¶æ€æ–¹ä¾¿ç”¨æ•°å­—è¡¨ç¤ºï¼Œæ‰€ä»¥å®ç°ç®€å•ã€‚\nbool flag[N]; int sg[N]; void getsg(){ for1(i,N){ ms(flag,0); //æšä¸¾åç»§çŠ¶æ€ for(int j=1;j\u0026lt;=K;j++){//Kä¸ºèƒ½å–ä¸åŒä¸ªæ•°çŸ³å­çš„ç§ç±»æ•° flag[sg[i-shizi[j]]]=1; } //æ‰¾mex forn(j,N){ if(flag[j]==0){ sg[i]=j; break; } } } } æœ‰è§„å¾‹çš„sgå‡½æ•°:HDU-1847\næ‰“è¡¨å¯å‘ç°sgå‡½æ•°æ˜¯0ï¼Œ1ï¼Œ2ï¼Œ0ï¼Œ1ï¼Œ2â€¦â€¦å˜åŒ–çš„ã€‚\nç¨å¾®éš¾ä¸€ç‚¹æ‰¾è§„å¾‹ï¼šLightOJ-1296\nè§„å¾‹ï¼šå¦‚æœnæ˜¯å¥‡æ•°gx(n)=gx(n/2),å¦‚æœä¸ºå¶æ•°ï¼Œgx(x)=x/2;\néœ€è¦æ‰“è¡¨çš„é¢˜ï¼šHDU-1848\nå·´ä»€åšå¼ˆ é¢˜ç›®æè¿° åªæœ‰ä¸€å †nä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»è¿™å †çŸ³å­ä¸­å–çŸ³å­ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å®Œçš„äººè·èƒœã€‚\nåˆ†æ å½“n = m+1 çš„æ—¶å€™ï¼Œç”±äºå…ˆæ‰‹æœ€å¤šå–èµ°mä¸ªï¼Œæ— è®ºå…¶å–èµ°å¤šå°‘ä¸ªï¼Œå‰©ä¸‹çš„åæ‰‹å‡å¯ä»¥ä¸€æ¬¡å–å®Œï¼Œæ˜¾ç„¶åæ‰‹èƒœã€‚ æ ¹æ®ä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬å¯ä»¥å°†nå†™æˆ $n=k(m+1)+r$ çš„å½¢å¼ã€‚å¯¹äºå…ˆæ‰‹ç©å®¶ï¼Œæˆ‘ä»¬å¯ä»¥å–èµ°rä¸ªï¼Œç»™å¯¹æ–¹é€ æˆå‰©ä¸‹$k(m+1)$çš„æƒ…å½¢ã€‚æ­¤æ—¶æ— è®ºå¯¹æ‰‹å–èµ°å¤šå°‘ä¸ªï¼Œå‡è®¾å¯¹æ‰‹å–èµ°nä¸ªï¼Œ æˆ‘ä»¬ä¸€å®šå¯ä»¥åšåˆ°å–èµ° $m+1-n$ä¸ªï¼Œæ­¤æ—¶å‰©ä¸‹$(k-1)(m+1)$ä¸ªï¼Œé‚£ä¹ˆç•™ç»™å¯¹æ–¹åˆæ˜¯(m+1)çš„æ•´æ•°å€ï¼Œå¦‚æ­¤å°±å¯ä»¥ä¿è¯å…ˆæ‰‹å–èƒœã€‚ ç»“è®º å½“$n\\mod(m+1)!=0$æ—¶ï¼Œå…ˆæ‰‹èƒœï¼Œå¦åˆ™åæ‰‹èƒœã€‚\nå¨ä½å¤«åšå¼ˆ é¢˜ç›®æè¿° æœ‰ä¸¤å †å„è‹¥å¹²ä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †æˆ–è€…ä¸¤å †ä¸­å–åŒæ ·å¤šçš„ç‰©å“ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šç€ä¸é™ï¼Œæœ€åå–å®ŒçŸ³å­çš„äººè·èƒœã€‚\nåˆ†æ æˆ‘ä»¬ç”¨$(a_k,b_k),a_k \\leq b_k,k \\in[0,n] $ è¡¨ç¤ºä¸€ç§å±€åŠ¿ï¼Œå…ˆæ‰‹å¿…è¾“çš„å±€åŠ¿æˆ‘ä»¬ç§°ä¸ºå¥‡å¼‚å±€åŠ¿ï¼Œæ˜¾ç„¶$(0,0)$æ˜¯ä¸€ç§å¥‡å¼‚å±€åŠ¿ã€‚é‚£ä¹ˆ$(0,k),(k,k)$å¿…ç„¶æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ä¸€æ­¥åˆ°è¾¾å¥‡å¼‚å±€åŠ¿ã€‚æˆ‘ä»¬å¯ä»¥å‘ç°$(1,2)$ä¸è®ºå¦‚ä½•æ“ä½œéƒ½å°†æˆä¸ºéå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥$(1,2)$æ˜¯ä¸‹ä¸€ä¸ªå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥$(1+k,2),(1,2+k),(1+k,2+k)$ä¹Ÿéƒ½æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œä»¥æ­¤ç±»æ¨æˆ‘ä»¬å¯ä»¥å‘ç°ä¹‹åçš„å‡ ä¸ªå¥‡å¼‚å±€åŠ¿æ˜¯$(3,5),(4,7),(6,10)$ã€‚\né€šè¿‡è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°$a_0=b_0=0,a_k$ä¸ºå‰é¢æ²¡å‡ºç°è¿‡çš„æœ€å°æ­£æ•´æ•°ï¼Œ$b_k=a_k+k$ã€‚\nå¥‡å¼‚å±€åŠ¿æœ‰ä»¥ä¸‹ä¸‰æ¡æ€§è´¨\nä»»ä½•æ­£æ•´æ•°éƒ½åŒ…å«åœ¨å¥‡å¼‚å±€åŠ¿ä¸­ã€‚\nä»»ä½•æ“ä½œéƒ½ä¼šå°†å¥‡å¼‚å±€åŠ¿å˜ä¸ºéå¥‡å¼‚å±€åŠ¿ã€‚\né‡‡å–é€‚å½“çš„æ“ä½œå¯ä»¥å°†éå¥‡å¼‚å±€åŠ¿å˜ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚\näº‹å®ä¸Šï¼Œ$a_n,b_n$æ˜¯ä¸€å¯¹beattyæ•°åˆ—ã€‚\nBeattyæ•°åˆ— å–ä¸¤ä¸ªæ— ç†æ•°$\\alpha,\\beta$ä½¿å¾—$\\frac 1 \\alpha+\\frac1\\beta=1$ã€‚\nä¸€å¯¹Beattyæ•°åˆ—å°±æ˜¯$a_n=\\lfloor n\\alpha\\rfloor,b_n=\\lfloor n\\beta\\rfloor$ã€‚\nRayleighå®šç†(Beattyå®šç†) $a_n,b_n$åˆ’åˆ†æ­£æ•´æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªæ­£æ•´æ•°åªåœ¨ä¸¤ä¸ªæ•°åˆ—ä¸­å‡ºç°ä¸€æ¬¡ã€‚\næˆ‘ä»¬å†å›åˆ°è¿™ä¸ªé—®é¢˜ï¼Œ $$\\because a_n+n=\\lfloor n\\alpha\\rfloor+n=b_n=\\lfloor n\\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha \\rfloor+n= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha+n \\rfloor= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\beta = \\alpha+1$$\næ ¹æ®$\\frac 1 \\alpha+\\frac 1 {\\alpha+1}=1$è§£å¾—$\\alpha=\\frac {\\sqrt 5+1} 2=\\phi$ã€‚æˆ‘ä»¬å¯å¾—åˆ°é€šé¡¹$a_n=\\lfloor n \\phi \\rfloor,b_n=a_n+n$\nå¯¹äºä»»æ„å±€åŠ¿$(x,y),x\\leq y$æˆ‘ä»¬åªéœ€åˆ¤æ–­$\\lfloor (y-x)\\phi\\rfloor\\stackrel{?}{=}x$\nå¸¸è§çš„å‡ ç±»é—®é¢˜ ç»™å‡ºå±€åŠ¿åˆ¤æ–­æ˜¯å¦æ˜¯å¥‡å¼‚å±€åŠ¿ã€‚\nç»™å‡ºå±€åŠ¿$(x,y),x\\leq y$ï¼Œåˆ¤æ–­æ˜¯å¦å…ˆæ‰‹èµ¢ï¼Œè‹¥èµ¢ï¼Œç»™å‡ºç¬¬ä¸€æ­¥èµ°æ³•ã€‚\nä¾‹é¢˜ï¼šHDU-2177\nå…ˆæŠŠæ‰€æœ‰å¥‡å¼‚å±€åŠ¿æ±‚å‡ºæ¥ï¼Œç„¶ååˆ¤æ–­æ˜¯ä¸æ˜¯ï¼Œå¦‚æœä¸æ˜¯ï¼š\nå…ˆåˆ¤æ–­èƒ½å¦ä¸¤å †åŒæ—¶å–ï¼Œè®¾$k=y-x$ åˆ¤æ–­$x-a_k?=y-b_k(x-a_k\u0026gt;0)$å¦‚æœæˆç«‹å°±å¯ä»¥åŒæ—¶å–åˆ°$(a_k,b_k)$ã€‚ åˆ¤æ–­å–ä¸€å †çš„ã€‚å…ˆåˆ¤æ–­$x?=a_n\\land y?\u0026gt;b_n$,å¦‚æœæˆç«‹å°±å¯ä»¥å–åˆ°$(a_n,b_n)$,å¦‚æœä¸æˆç«‹é‚£ä¹ˆ$a=b_n$ï¼Œæ­¤æ—¶$y\u0026gt;a_n$ï¼Œæ‰€ä»¥å¯ä»¥å–åˆ°$(a_n,b_n)$ã€‚ Nimåšå¼ˆ é¢˜ç›®æè¿° æœ‰nå †çŸ³å­ï¼Œæ•°é‡åˆ†åˆ«ä¸º$x_1,x_2,â€¦,x_n$æ¯äººæ¯æ¬¡å¯åœ¨ä»»æ„ä¸€å †ä¸­å–èµ°ä»»æ„æ•°é‡ï¼ˆä¸å°‘äº1ï¼‰çš„çŸ³å­ã€‚\nç»“è®º Nimæ¸¸æˆä¸­å…ˆæ‰‹å¿…è´¥å½“ä¸”ä»…å½“$x_1XOR x_2XORâ€¦XORx_n=0$æ—¶\næ‰©å±• äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†Nimæ¸¸æˆè§†åšå¤šä¸ªå­æ¸¸æˆçš„åˆé›†ï¼Œæ ¹æ®Nimå®šç†ï¼Œæ€»æ¸¸æˆçš„sgå€¼ç­‰äºæ‰€æœ‰å­æ¸¸æˆçš„sgå€¼çš„å¼‚æˆ–å’Œã€‚\nè¯æ˜ å¼‚æˆ–æœ‰ä¸€æ¡æ€§è´¨,$xXORy=xXORz \\implies y=z$ï¼Œæ ¹æ®sgçš„å®šä¹‰ï¼Œå­æ¸¸æˆèµ°ä¸€æ­¥ï¼Œsgå€¼å¿…ç„¶å‘ç”Ÿæ”¹å˜ï¼Œæ ¹æ®å¼‚æˆ–çš„æ€§è´¨æ‰€ä»¥æ€»æ¸¸æˆçš„sgå€¼ä¹Ÿä¸€å®šå‘ç”Ÿæ”¹å˜ï¼Œ0ä¸€å®šä¼šå˜æˆé0ï¼Œé0ç»è¿‡æŸä¸€æ­¥å¯ä»¥å˜æˆ0ï¼Œæ‰€ä»¥å½“ä¸”ä»…å½“å’Œæ¸¸æˆçš„sgä¸º0æ—¶ï¼Œå…ˆæ‰‹å¿…è¾“ï¼Œå› ä¸ºåæ‰‹æ€»å¯ä»¥æ§åˆ¶sgå€¼å›åˆ°0ã€‚\nä¾‹é¢˜ï¼šHDU-2176\n","date":1570147200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1570147200,"objectID":"9529b289f6e38ed260b3d2e495bd5a15","permalink":"https://tgc54.com/zh/post/game_theory/","publishdate":"2019-10-04T00:00:00Z","relpermalink":"/zh/post/game_theory/","section":"post","summary":"å‡ ä¸ªæœˆå‰çš„ç¬”è®°ï¼Œæ‰ç–å­¦æµ…ï¼Œä»…ä¾›å‚è€ƒ~\n","tags":["åšå¼ˆè®º"],"title":"åšå¼ˆè®ºå…¥é—¨å­¦ä¹ ç¬”è®°","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"long longçˆ†çš„å¥½å•Šï¼ï¼\né¢˜ç›®é“¾æ¥\næˆ‘ä»¬æŠŠè¦æ±‚çš„å¼å­å±•å¼€ $$\\begin{align*}\u0026amp;f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\\\ =\u0026amp;g(1,p_1)\\cdot g(1,p_2)\\cdot \\ldots \\cdot g(1,p_n) \\\\ \u0026amp;g(2,p_1)\\cdot g(2,p_2)\\cdot \\ldots \\cdot g(2,p_n) \\\\ \u0026amp;g(3,p_1)\\cdot g(3,p_2)\\cdot \\ldots \\cdot g(3,p_n) \\\\ \u0026amp;\\vdots \\\\ \u0026amp;g(n,p_1)\\cdot g(n,p_2)\\cdot \\ldots \\cdot g(n,p_n)\\end{align*} $$\nç„¶åæ¯æ¬¡è®¡ç®—ä¸€åˆ—ï¼Œç”±äº$p$æ˜¯è´¨æ•°ï¼Œå½“ä¸”ä»…å½“$n=k\\cdot p^j$æ—¶$g(n,p)=j$ï¼Œå¦åˆ™$g(n,p)=1$ã€‚ç”±äºåŒä¸€åˆ—ä¸­$p$éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥åªè¦è®¡ç®—æŒ‡æ•°ä¹‹å’Œå°±è¡Œäº†ã€‚ç›´æ¥åˆ†æä»£ç ï¼š\nll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; n / tmpçš„ç»“æœå°±æ˜¯å¯¹äºå½“å‰çš„tmpï¼Œ$1,2,3,\\ldots,n$ä¸­æœ‰å‡ ä¸ªå¯ä»¥æ•´é™¤tmpã€‚ å¯¹äº$1,2,\\ldots,n$æ¯ä¸ªæ•°å­—éƒ½è¢«ç­›è¿‡$g(n,p)$æ¬¡ï¼Œæ‰€ä»¥ç´¯åŠ æ¯ä¸€æ¬¡çš„n / tmpå°±æ˜¯æŒ‡æ•°ä¹‹å’Œäº†ã€‚æ³¨æ„tmp *= itå¯èƒ½ä¼šçˆ†long longæ‰€ä»¥ä¹˜ä¹‹å‰è¦å…ˆæ£€æŸ¥ä¸€ä¸‹ï¼ˆåšçš„æ—¶å€™è¢«å¡äº†ï¼Œç›´æ¥è‡ªé—­ï¼‰ã€‚\nå®Œæ•´ä»£ç ï¼š\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int mod = 1e9 + 7; long long binpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % mod; a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); vector\u0026lt;int\u0026gt; pr; ll x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; if (x % 2 == 0) { while (x % 2 == 0) x /= 2; pr.pb(2); } for (int i = 3; i * i \u0026lt;= x; i += 2) { if (x % i == 0) { pr.pb(i); while (x % i == 0) x /= i; } } if (x \u0026gt; 1) pr.pb(x); ll ans = 1; for (auto it : pr) { ll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } ","date":1569888e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569888e3,"objectID":"fc861e02d7939819705ff144ca1ca98a","permalink":"https://tgc54.com/zh/post/cf1128c/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/zh/post/cf1128c/","section":"post","summary":"long longçˆ†çš„å¥½å•Šï¼ï¼\n","tags":["æ•°å­¦"],"title":"CodeForces 1128C - Primes and Multiplication é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"è¿™å“ˆå¸Œé•¿è§è¯†äº†ã€‚\nè¿™ä¸ªæ˜¯åœ¨CFé¢˜è§£çš„è¯„è®ºåŒºé‡Œçœ‹åˆ°çš„è§£æ³•ï¼Œéå¸¸éœ‡æƒŠï¼Œä¸ç¦æƒ³åˆ°äº†å­¦é•¿å’Œæˆ‘ä»¬è¯´è¿‡çš„è¯:â€œå“ˆå¸Œæ˜¯ä¸€ç§æ€æƒ³â€ã€‚è¿™æ¬¡çœŸçš„æ˜¯ä½“ä¼šåˆ°äº†ã€‚\næ€è·¯ï¼šå®šä¹‰ç»™äº†è¿™ä¹ˆå¤šï¼Œå…¶å®å°±æ˜¯æŠŠå®Œå…¨äºŒåˆ†å›¾çš„æ¦‚å¿µæ‰©å±•æˆäº†å®Œå…¨ä¸‰åˆ†å›¾ã€‚æœ‰ä¸€ç‚¹å¾ˆé‡è¦çš„æ€§è´¨ï¼Œå°±æ˜¯å¦‚æœä¸¤ä¸ªç‚¹çš„ç›´æ¥è¿æ¥çš„ç‚¹æ˜¯ä¸€æ ·çš„è¯é‚£ä¹ˆè¿™ä¸¤ä¸ªç‚¹å¿…å®šå±äºåŒä¸€ä¸ªé›†åˆï¼Œè¿™æ ·å°±å¯ä»¥ç”¨å“ˆå¸Œçš„æ–¹æ³•å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦å…·æœ‰ç›¸åŒçš„é‚»å±…: é€šè¿‡$pow_i=pow_{i-1}*p_1 \\bmod p_2$ç»™æ¯ä¸ªç‚¹ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆä¸€ä¸ªç‚¹çš„å“ˆå¸Œå€¼å°±æ˜¯è¯¥ç‚¹é‚»å±…çš„ç‚¹$pow$å€¼çš„å’Œï¼Œå¦‚æœä¸¤ä¸ªç‚¹çš„å“ˆå¸Œå€¼ä¸€æ ·ï¼Œé‚£ä¹ˆå°±å¤§æ¦‚ç‡è‚¯å®šä¸¤ä¸ªç‚¹çš„é‚»å±…æ˜¯ä¸€æ ·çš„ã€‚\nä»£ç \n#include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; ll po[N],ha[N]; const int mod=1e9+7; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; po[0]=1; for1(i,n) po[i]=po[i-1]*29; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ha[x]+=po[y]; ha[y]+=po[x]; } map\u0026lt;ll,ll\u0026gt; mp; int idx=0; for1(i,n){ if(ha[i]==0){ cout\u0026lt;\u0026lt;-1; return 0; } if(mp[ha[i]]==0) mp[ha[i]]=++idx; } if(idx==3){ for1(i,n) cout\u0026lt;\u0026lt;mp[ha[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;-1; return 0; } ","date":1569888e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569888e3,"objectID":"9e5ac5a61cdbe67f482f58685278ea3c","permalink":"https://tgc54.com/zh/post/cf1128d/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/zh/post/cf1128d/","section":"post","summary":"è¿™å“ˆå¸Œé•¿è§è¯†äº†ã€‚\n","tags":["å“ˆå¸Œ","å›¾è®º"],"title":"CodeForces1228D - Complete Tripartite é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"ä¸€å¼€å§‹åšéº»çƒ¦äº†ï¼Œå…³é”®æ˜¯å†™éº»çƒ¦äº†è¿˜æ²¡è¿‡ï¼Œå¥½æ°”å“¦ã€‚\nè¿™é¢˜åº”è¯¥æœ‰å¾ˆå¤šä¸åŒçš„æ€è·¯ã€‚æˆ‘çš„æƒ³æ³•æ˜¯è®¡ç®—ç»™å‡ºçš„æ•°ç»„ä¸­æ¯ä¸€å¯¹ç›¸é‚»çš„æ•°åœ¨ä¹‹åçš„æ’åˆ—ï¼ˆPermutationï¼‰ä¸­è·ç¦»çš„å˜åŒ–ï¼Œç„¶ååªè¦ä»¥ç¬¬ä¸€ä¸ªæ’åˆ—çš„ç­”æ¡ˆä¸ºåŸºå‡†ï¼ŒåŠ ä¸Šä¹‹åæ’åˆ—çš„è·ç¦»å˜åŒ–å°±æ˜¯åé¢æ’åˆ—çš„ç­”æ¡ˆäº†ã€‚\né‚£ä¹ˆè·ç¦»æ˜¯å¦‚ä½•å˜åŒ–çš„å‘¢ï¼Œæˆ‘ä»¬è®¾ä¸€å¯¹ç›¸é‚»çš„æ•°ä¸­æ¯”è¾ƒå°çš„æ•°æ˜¯$l$ï¼Œæ¯”è¾ƒå¤§çš„æ•°æ˜¯ $r$ï¼Œé‚£ä¹ˆä»–ä»¬åœ¨ç¬¬ä¸€ä¸ªæ’åˆ—ä¸­çš„ä½ç½®å°±æ˜¯è¿™æ ·çš„: $$1,2,\\ldots,l,\\dots,r,\\ldots,n-1,n$$ åœ¨ç¬¬ä¸€ä¸ªä¸€ç›´åˆ°ç¬¬$l-1$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$å’Œ$r$çš„ä½ç½®éƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè‡ªç„¶è·ç¦»ä¹Ÿä¸å˜ã€‚ä½†åœ¨ç¬¬$l$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$æˆäº†ç¬¬ä¸€ä¸ªæ•°ï¼š $$l,1,2,\\ldots,l-1,l+1,\\dots,r,\\ldots,n-1,n$$\n$l$ä¸$r$çš„è·ç¦»å¢åŠ äº†$l-1$ã€‚\nåœ¨ç¬¬$l+1$åˆ°$r-1$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$ä¸$r$ä¸­çš„æŸä¸€ä¸ªæ•°ä¼šåœ¨æœ€å‰é¢ï¼Œæ‰€ä»¥$l$ä¸$r$çš„è·ç¦»æ¯”æœ€å¼€å§‹å°‘1ã€‚\nåœ¨ç¬¬$r$ä¸ªæ’åˆ—ä¸­ï¼Œrè·‘åˆ°äº†æœ€å‰é¢ï¼š $$r,1,2,\\ldots,l-1,l,l+1,\\dots,r-1,r+1,\\ldots,n-1,n$$ æ³¨æ„æ­¤æ—¶lçš„ä½ç½®ä¾ç„¶æ˜¯$l+1$ï¼Œæ‰€ä»¥è·ç¦»çš„å˜åŒ–æ˜¯$(l+1-1)-(r-l)=2\\cdot l-r$\nå¦‚æœæˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„aæ¥ä¿å­˜æ‰€æœ‰æ’åˆ—ä¸­ç­”æ¡ˆçš„å˜åŒ–ï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸€å¯¹$(l,r)$,æˆ‘ä»¬åº”è¯¥åšå¦‚ä¸‹ä¸‰ä¸ªæ“ä½œï¼š\n$a_l := a_l+l-1$ $a_i:= a_i-1,i=l+1,\\ldots,r-1$ $a_r:= a_r +2\\cdot l-r$ ç”±äºå…¶ä¸­æ¶‰åŠåˆ°åŒºé—´ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å·®åˆ†çš„æ€æƒ³æ¥å®ç°ï¼Œå¹¶ä¸”ç”±äºåªä¼šæŸ¥è¯¢ä¸€æ¬¡ï¼Œæ‰€ä»¥ç”¨æœ€ç®€å•çš„æ•°ç»„å°±å¯ä»¥äº†ï¼Œå…·ä½“å®ç°è§ä»£ç :\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; ll sum[N]; int n,m; void rgadd(int l,int r,int x){ sum[l]+=x; sum[r+1]-=x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int x,last; cin\u0026gt;\u0026gt;last; ll ans=0; forn(i,m-1){ cin\u0026gt;\u0026gt;x; int mn=min(x,last),mx=max(x,last); ans+=mx-mn; last=x; if(mx==mn) continue; rgadd(mn,mn,mn-1); rgadd(mx,mx,(mn-mx+mn)); if(mx-mn\u0026gt;1) rgadd(mn+1,mx-1,-1); } for1(i,n){ ans+=sum[i]; cout\u0026lt;\u0026lt;an\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } ","date":1569888e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569888e3,"objectID":"f9bbaa4938ff82aac994b86b9683b977","permalink":"https://tgc54.com/zh/post/cf1234e/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/zh/post/cf1234e/","section":"post","summary":"ä¸€å¼€å§‹åšéº»çƒ¦äº†ï¼Œå…³é”®æ˜¯å†™éº»çƒ¦äº†è¿˜æ²¡è¿‡ï¼Œå¥½æ°”å“¦ã€‚\n","tags":["å·®åˆ†"],"title":"CodeForces1234E - Special Permutations é¢˜è§£","type":"post"},{"authors":null,"categories":["è®­ç»ƒé¢˜è§£"],"content":"A - Keywords Search HDU - 2222 é¢˜æ„ï¼š ç»™å‡ºå•è¯å’Œæ–‡ç« ï¼Œé—®å¤šå°‘ä¸ªå•è¯åœ¨æ–‡ç« ä¸­å‡ºç°è¿‡ã€‚\næ€è·¯ï¼š ACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œä¹‹å‰ä¹Ÿè¯´è¿‡ï¼Œä¸å†èµ˜è¿°ã€‚\nB - ç—…æ¯’ä¾µè¢­ HDU - 2896 é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚\næ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚\nC - Sliding Window POJ - 2823 é¢˜æ„ï¼š æ•°ç»„é•¿åº¦ä¸º$n$,é•¿åº¦ä¸º$k$çš„çª—æˆ·åœ¨æ•°ç»„ä¸Šæ»‘åŠ¨ï¼Œé—®æ¯æ¬¡æ»‘åŠ¨åçš„çª—æˆ·ä¸­çš„æœ€å¤§å’Œæœ€å°å€¼ã€‚\næ€è·¯ï¼š ç”¨çº¿æ®µæ ‘æˆ–è€…stè¡¨å¤æ‚åº¦éƒ½æ˜¯$O(nlogn)$ï¼Œå•è°ƒé˜Ÿåˆ—å¯ä»¥åšåˆ°$O(n)$ï¼Œå¦‚æœæ±‚æœ€å¤§å€¼å°±ç»´æŠ¤å•è°ƒé€’å¢åºåˆ—ï¼Œæ–¹æ³•å¦‚ä¸‹ï¼š\nä¸æ–­ä»é˜Ÿå°¾å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿå°¾å…ƒç´ å¤§äºå¾…å…¥é˜Ÿçš„æ•°ï¼Œå› ä¸ºåˆå°åˆé å‰é¢çš„æ•°è‡ªç„¶æ¯”ä¸ä¸Šåˆå¤§åˆé åçš„æ•°ã€‚ ä¸æ–­ä»é˜Ÿé¦–å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿé¦–å…ƒç´ çš„ä¸‹æ ‡åœ¨çª—æˆ·çš„èŒƒå›´ä¹‹å†…ã€‚ è¾“å‡ºé˜Ÿé¦–å…ƒç´ ï¼Œä¸ºå½“å‰çª—æˆ·çš„æœ€å¤§å€¼ã€‚ æ±‚æœ€å°å€¼æ­¥éª¤ç±»ä¼¼ï¼Œå®é™…ç»´æŠ¤çš„æ—¶å€™ä¸ºäº†å®¹æ˜“å®ç°ç¬¬äºŒæ­¥ï¼Œé˜Ÿåˆ—ä¸­å­˜çš„æ˜¯ä¸‹æ ‡ã€‚\nD - Intersections Gym - 101853C é¢˜æ„ï¼š ç»™å‡ºä¸¤è¡Œåºåˆ—ï¼Œè¿æ¥ç›¸åŒçš„æ•°ï¼Œé—®äº§ç”Ÿäº¤ç‚¹çš„ä¸ªæ•°ã€‚\næ€è·¯ï¼š å¦‚æœä¸¤ä¸ªæ•°åœ¨ä¸Šä¸‹ä¸¤è¡Œä¸­çš„ç›¸å¯¹ä½ç½®å‘ç”Ÿäº†å˜åŒ–ï¼Œè¿çº¿çš„æ—¶å€™å°±ä¼šäº§ç”Ÿä¸€ä¸ªäº¤ç‚¹ã€‚\nåœ¨è¯»å…¥ç¬¬ä¸€è¡Œçš„æ—¶å€™è®°å½•æ¯ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä½ç½®ã€‚åœ¨è¯»å…¥ç¬¬äºŒè¡Œçš„æ—¶å€™å°†å…¶æ›¿æ¢ä¸ºè¯¥æ•°åœ¨ç¬¬ä¸€è¡Œçš„å‡ºç°ä½ç½®ï¼Œé‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†æ±‚é€†åºå¯¹ï¼ˆ$a_i\u0026gt;a_j,i\u0026lt;j$ï¼‰ä¸ªæ•°çš„é—®é¢˜ã€‚\næœ‰ä¸¤ç§æ±‚æ³•ï¼šå½’å¹¶æ’åºå’Œæ ‘çŠ¶æ•°ç»„ã€‚è¿™é‡Œä»‹ç»æ ‘çŠ¶æ•°ç»„çš„åšæ³•ï¼šå°†æ‰€æœ‰çš„æ•°çš„åœ¨ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®å’Œåœ¨ç¬¬äºŒè¡Œå‡ºç°çš„ä½ç½®ä½œä¸ºæ•°å¯¹ä¿å­˜åœ¨æ•°ç»„ä¸­ï¼ŒæŒ‰ç…§ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®ä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·æ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°çš„æ—¶å€™å‰é¢æ•°å­—çš„ä¸ªæ•°å°±æ˜¯æ’å…¥è¿™ä¸ªæ•°äº§ç”Ÿæ–°çš„é€†åºå¯¹çš„ä¸ªæ•°ï¼Œå› ä¸ºæ•°ç»„æ˜¯ä»å¤§åˆ°å°æ’åºï¼Œæ­¤æ—¶å·²ç»æ’å…¥çš„æ•°éƒ½æ˜¯æ¯”å½“å‰æ•°å¤§çš„æ•°ï¼Œè€Œä½ç½®åœ¨å‰é¢çš„æ•°å°±æ˜¯ç¬¦åˆé€†åºå¯¹å®šä¹‰çš„æ•°ã€‚è€Œè¿™å°±å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„å®ç°ï¼Œè®¡ç®—å‰é¢æ•°çš„ä¸ªæ•°å°±æ˜¯ç®—å‰ç¼€å’Œï¼Œæ’å…¥å°±æ˜¯åœ¨ç¬¬äºŒæ¬¡å‡ºç°çš„ä½ç½®+1ã€‚\nE - ç»´æŠ¤åºåˆ— Gym - 237040G é¢˜æ„ï¼š ç»´æŠ¤ä¸€ä¸ªåºåˆ—ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š\næŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨ä¹˜ä¸€ä¸ªå€¼ï¼› æŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨åŠ ä¸€ä¸ªå€¼ï¼› è¯¢é—®æ•°åˆ—ä¸­çš„ä¸€æ®µæ•°çš„å’Œæ¨¡ $P$ çš„å€¼ã€‚ æ€è·¯ï¼š çº¿æ®µæ ‘æ”¹æ¿å­é¢˜ï¼Œéœ€è¦åŠ¨ç‚¹è„‘å­ï¼Œä¹˜çš„æ—¶å€™åŠ å’Œä¹˜çš„lazy tagéƒ½è¦æ›´æ–°ã€‚å› ä¸º$(val\\cdot lazy_{mul}+lazy_{add})\\cdot x=val\\cdot lazy_{mul}\\cdot x+lazy_{add}\\cdot x$ å…¶ä»–è²Œä¼¼å°±å¿˜ æ²¡ çš„ ä»€ å·® ä¹ˆ ä¸ å¥½ å¤š è¯´ äº† çš„äº†ã€‚\nF - Little Elephant and Array CodeForces - 220B è§æˆ‘çš„å¦ä¸€ç¯‡æ–‡ç« \nG - Tourists Gym - 101002I é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæ ‘ï¼Œè®¡ç®—æ‰€æœ‰ä¸¤ç«¯å…¶ä¸­ä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªå€æ•°çš„è·¯å¾„é•¿åº¦å’Œã€‚\næ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šè·¯å¾„è‡ªç„¶è¦ç”¨åˆ°LCAï¼Œå°±æ˜¯ä¸ªå€å¢æ³•æ¿å­é¢˜ã€‚\nI - äºŒç»´æ ‘çŠ¶æ•°ç»„ ï¼šå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ Gym - 237040E é¢˜æ„ï¼š è§é¢˜ç›®ã€‚\næ€è·¯ï¼š è§é¢˜ç›®ã€‚\nK - Jzzhu and Cities CodeForces - 449B é¢˜æ„ï¼š ä¸€ä¸ªå›¾ä¸­æœ‰$m$æ¡é“è·¯å’Œ$k$æ¡é€šå¾€é¦–éƒ½ï¼ˆæ ‡å·ä¸º1çš„ç‚¹ï¼‰çš„é“è·¯ã€‚é—®æœ€å¤šå¯ä»¥å»æ‰å¤šå°‘é“è·¯ä½¿å¾—æ‰€æœ‰åŸå¸‚åˆ°é¦–éƒ½çš„æœ€çŸ­è·ç¦»ä¸å˜ã€‚\næ€è·¯ï¼š æŠŠæ‰€æœ‰é“è·¯å’Œé“è·¯éƒ½æ”¾åˆ°å›¾é‡Œï¼Œdijkstraæ˜¯å¯ä»¥è®°å½•æœ€çŸ­è·¯è·¯å¾„æ¡æ•°çš„ï¼ï¼ˆå¥½åƒè€ƒè¯•è€ƒè¿‡ï¼Ÿï¼‰ï¼ŒåŸç†å°±æ˜¯å½“æ›´æ–°è·ç¦»çš„æ—¶å€™å¦‚æœå’Œå½“å‰æœ€çŸ­è·¯å¾„ä¸€æ ·é•¿å°±è·¯å¾„æ¡æ•°+1ï¼Œå¦‚æœæ›´çŸ­æ¡æ•°å°±ç½®ä¸º1ã€‚æœ€åéå†æ‰€æœ‰é“è·¯ï¼Œå¦‚æœå½“å‰é“è·¯æ¯”æœ€çŸ­è·¯é•¿é‚£ä¹ˆå°±å¯ä»¥å»æ‰ï¼Œå¦‚æœå’Œæœ€çŸ­è·¯ä¸€æ ·çš„è¯å°±è¦çœ‹æœ€çŸ­è·¯è¿˜å‰©å‡ æ¡ï¼Œå¦‚æœå¤§äº1çš„è¯å°±å¯ä»¥å»æ‰å¹¶ä¸”æŠŠæœ€çŸ­è·¯çš„æ¡æ•°-1ã€‚\nL - Alyona and the Tree CodeForces - 682C é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µè¾¹æƒç‚¹æƒæ ‘ï¼Œé—®æœ€å°‘å»æ‰å‡ ä¸ªç‚¹ä½¿å¾—ä¸å­˜åœ¨è¿™æ ·çš„ç‚¹$u$ï¼šå…¶å­æ ‘ä¸Šå­˜åœ¨æŸç‚¹$v$ï¼Œå…¶ç‚¹æƒ$a_v$å¤§äº$v$åˆ°$u$çš„è·ç¦»ã€‚\næ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šæ‰€æœ‰çš„è·ç¦»è‚¯å®šè¶…æ—¶ï¼Œä½†æ˜¯æœ‰è¿™æ ·ä¸€æ¡æ€§è´¨ï¼Œå¦‚æœè¾¹æƒéƒ½æ˜¯æ­£æ•°çš„è¯ï¼Œå¦‚æœ$\\operatorname{dist}(u,v)\u0026gt; a_u,v\\not = root$é‚£ä¹ˆ$\\operatorname{dist}(u,root)\u0026gt;a_u$ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥åªè®¡ç®—åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°±è¡Œäº†ï¼Œä½†æ˜¯è¾¹æƒå¦‚æœæœ‰è´Ÿæ•°ä¸Šè¿°æ€§è´¨å°±ä¸æˆç«‹äº†ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç¨åŠ æ”¹åŠ¨ï¼šå½“æˆ‘ä»¬dfsçš„æ—¶å€™ï¼Œå¦‚æœå½“å‰ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°äº0ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åº”è¯¥å°†è·ç¦»ç½®ä¸º0ï¼Œç„¶åæ¥ç€dfs,è¿™æ ·å°±é¿å…äº†å‰é¢çš„è´Ÿæƒè·¯å¾„äº§ç”Ÿçš„å¹²æ‰°ã€‚\n","date":1569715200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569715200,"objectID":"222815c1f63d109e46180cfefd363787","permalink":"https://tgc54.com/zh/post/cugb6/","publishdate":"2019-09-29T00:00:00Z","relpermalink":"/zh/post/cugb6/","section":"post","summary":"","tags":["CUGBACM"],"title":"CUGBACM18çº§è®­ç»ƒ#6 é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":"æ®è¯´è«é˜Ÿæ›´ç®€å•ï¼Œç„¶è€Œä¸ä¼šå•Š\né¢˜ç›®é“¾æ¥\nè€ƒè™‘ç»´æŠ¤ä¸€ä¸ªæ•°ç»„$D$ï¼Œä½¿å¾—$D_l,D_{l+1},\\dots,D_{r-1},D_r$çš„å’Œä¸ºè¯¢é—®$[l,r]$çš„ç­”æ¡ˆã€‚ç”¨çº¿æ®µæ ‘æˆ–æ ‘çŠ¶æ•°ç»„éƒ½è¡Œï¼ˆæ˜¾ç„¶æ ‘çŠ¶æ•°ç»„æ¯”è¾ƒå¥½å†™ï¼‰ã€‚ä»å·¦è¾¹å¼€å§‹éå†æ•°ç»„ï¼Œå½“ä¸‹æ ‡ä¸º$i$æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å¤„ç†å®Œæ‰€æœ‰$r=i$çš„è¯¢é—®ã€‚\nä¸‹é¢æˆ‘ä»¬ç”¨ä¸€ä¸ªæœ€ç®€å•çš„ä¾‹å­æ¥è¯´æ˜è¿™ä¸ªæ€è·¯ï¼ˆä¸‹æ ‡ä»1å¼€å§‹ï¼‰:\n$$A:3,3,3,3,3 \\D:0,0,0,0,0$$\nå½“$i=3$æ—¶ï¼Œ3è¿™ä¸ªæ•°ç¬¬ä¸€æ¬¡å‡ºç°3æ¬¡ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è®©$D_1+1$ï¼Œè¿™æ ·åªæœ‰[1,3]è¿™ä¸ªè¯¢é—®æ‰ä¼šå¾—åˆ°1ã€‚\nå½“$i=4$æ—¶ï¼ŒæŒ‰ç…§åˆšæ‰çš„æƒ³æ³•ï¼Œæˆ‘ä»¬åº”è®©$D_2+1$:\n$$A:3,3,3,3,3 \\D:1,1,0,0,0$$\nä½†è¿™æ—¶å¦‚æœæˆ‘ä»¬æœ‰$[1,4]$çš„è¯¢é—®ï¼Œé‚£ä¹ˆå°±ä¼šå¾—åˆ°2ï¼Œä½†ç­”æ¡ˆåº”è¯¥ä¸º0ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™æ—¶åº”å°†$D_1-2$ï¼š\n$$A: \\quad 3,3,3,3,3 \\D:-1,1,0,0,0$$\nè¿™æ ·å°±èƒ½æ­£ç¡®å¤„ç†$[1,4]$çš„è¯¢é—®äº†ã€‚\nç°åœ¨$i=5$äº†ï¼Œå¦‚æœå»¶ç»­åˆšæ‰çš„æ€è·¯ï¼Œç°åœ¨åº”è¯¥æ˜¯è¿™æ ·çš„:\n$$A: \\quad 3,\\enspace 3,3,3,3 \\D:-1,-1,1,0,0$$\nè¿™æ ·ä¸€æ¥ï¼Œ$[1,5]$çš„è¯¢é—®åˆä¸å¯¹äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è¯¥è®©$D_1+1$æ¥æŠµæ¶ˆç¬¬äºŒæ­¥ã€‚è¿™å°±æ˜¯è¿™ä¸ªé¢˜çš„åŸºæœ¬æ€è·¯ã€‚\nä»£ç \n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m, sqn; const int N = 1e5 + 5; struct node { int l, r, i; bool operator\u0026lt;(node a) { return r \u0026lt; a.r; } //æŒ‰ç…§è¯¢é—®çš„å³è¾¹ç•Œä»å°åˆ°å¤§æ’åº } itv[N]; int a[N], res[N], t[N]; int lowbit(int x) { return x \u0026amp; -x; } void change(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) t[i] += v; } int sum(int x) { int sum = 0; for (int i = x; i; i -= lowbit(i)) sum += t[i]; return sum; } vector\u0026lt;int\u0026gt; cnt[N];//è®°å½•æ¯ä¸ªæ•°å­—æ¯æ¬¡å‡ºç°æ—¶çš„ä¸‹æ ‡ int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for1(i, n) cin \u0026gt;\u0026gt; a[i]; forn(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; itv[i] = node{a, b, i}; } sort(itv, itv + m); int l, r; int j = 0; for1(i, n) { int x = a[i]; if (x \u0026lt;= n) { cnt[x].push_back(i);//è®°å½•ä¸‹æ ‡ int cntt = cnt[x].size();//è¿™ä¸ªæ•°ç›®å‰å‡ºç°çš„æ¬¡æ•° if (cntt \u0026gt;= x) {//å¯¹åº”å‰é¢i=3æ—¶çš„æƒ…å†µ change(cnt[x][cntt - x], 1); if (cntt \u0026gt; x)//å¯¹åº”i=4 change(cnt[x][cntt - x - 1], -2); if (cntt \u0026gt; x + 1)//å¯¹åº”i=5 change(cnt[x][cntt - x - 2], 1); } } while (j \u0026lt; m \u0026amp;\u0026amp; itv[j].r == i) { res[itv[j].i] = sum(itv[j].r) - sum(itv[j].l - 1); j++; }//å¤„ç†æ‰€æœ‰r=içš„è¯¢é—® } forn(i, m) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; } ","date":1569456e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569456e3,"objectID":"b9bded9dcef919f0b432627ac9f8b53f","permalink":"https://tgc54.com/zh/post/cf220b/","publishdate":"2019-09-26T00:00:00Z","relpermalink":"/zh/post/cf220b/","section":"post","summary":"æ®è¯´è«é˜Ÿæ›´ç®€å•ï¼Œç„¶è€Œä¸ä¼šå•Š\n","tags":["æ ‘çŠ¶æ•°ç»„","æ•°æ®ç»“æ„"],"title":"Little Elephant and Array - CodeForces220B é¢˜è§£","type":"post"},{"authors":null,"categories":["æ¯”èµ›é¢˜è§£","é¢˜è§£"],"content":"è¿˜ç®—é¡ºåˆ©çš„ä¸€åœº\né¢˜ç›®é“¾æ¥\nA - 3D Printed Statues é¢˜æ„ï¼š ä½ æœ‰1ä¸ª3Dæ‰“å°æœºï¼Œæ‰“å°æœºæ¯å¤©å¯ä»¥æ‰“å°å‡º1ä¸ªæ‰“å°æœºæˆ–è€…1ä¸ªé›•å¡‘ï¼Œä½ éœ€è¦æ‰“å°å‡ºnä¸ªé›•å¡‘ï¼Œé—®æœ€å°‘éœ€è¦å‡ å¤©ã€‚\næ€è·¯ï¼š ä¸éš¾æƒ³å‡ºï¼Œåªç”¨ä¸€å¤©æ‰“å°é›•å¡‘å°±å¤Ÿäº†ï¼Œå› ä¸ºå¦‚æœè¦éœ€è¦æ›´å¤šçš„å¤©æ•°ï¼Œä¸å¦‚å…ˆæ‰“å°æ‰“å°æœºç„¶åå†æ‰“å°é›•å¡‘ï¼Œæ‰€ä»¥æ€è·¯å°±æ˜¯ä¸€å¼€å§‹ç–¯ç‹‚æ‰“å°æ‰“å°æœºç›´åˆ°æ‰“å°ä¸ªæ•°å¤§äºç­‰äºnï¼Œç„¶åå¤©æ•°åŠ ä¸€ã€‚\nB - Digital display é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ—¶é—´ï¼Œç”¨7æ®µæ˜¾ç¤ºçš„æ–¹å¼è¾“å‡ºï¼ˆæ ¼å¼çœ‹é¢˜ç›®å°±è¡Œï¼‰\næ€è·¯ï¼š å½“æ—¶å†™éº»çƒ¦äº†ï¼Œå…¶å®å¯ä»¥æŠŠç«¯ç‚¹å’Œä¸­é—´çš„çº¿åˆèµ·æ¥å†™æˆä¸€ä¸ªå‡½æ•°çš„ï¼Œè¿™æ ·å°±åªç”¨å†™ç”»æ¨ªç€å’Œç«–ç€çš„çº¿çš„å‡½æ•°ï¼Œç”¨äºŒç»´æ•°ç»„å­˜æ•´ä¸ªå›¾æ¡ˆï¼Œæ ¹æ®æ•°å­—å’Œç¬¬å‡ ä½æ•°ç¡®å®šæ¨ªçº¿å’Œç«–çº¿çš„èµ·ç‚¹åæ ‡ï¼Œè°ƒç”¨å¯¹åº”çš„ç”»çº¿å‡½æ•°å°±è¡Œäº†ã€‚æœ€å‘çš„æ˜¯è¿™ä¸ªojæ²¡æœ‰æ ¼å¼é”™è¯¯ï¼Œå½“æ—¶å°‘äº†ä¸€ä¸ªç©ºè¡Œå´ä»¥ä¸ºæ˜¯åˆ«çš„é”™ï¼Œwaäº†å¥½å‡ å‘â€¦â€¦è¿™ä¸ªé¢˜è€½è¯¯äº†è´¼é•¿æ—¶é—´ã€‚\nC - Eight Queens é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ£‹ç›˜ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åˆæ³•çš„å…«çš‡åæ”¾æ³•ã€‚\næ€è·¯ï¼š éå†æ£‹ç›˜ï¼Œç¢°åˆ°çš‡åå°±è¿›è¡Œåˆ¤æ–­å…¶4ä¸ªæ–¹å‘ä¸Šæœ‰æ²¡æœ‰åˆ«çš„çš‡åã€‚ä½†æ˜¯é¢˜ç›®é‡Œæœ‰ä¸€ç‚¹æ²¡è¯´å°±æ˜¯çš‡åçš„æ•°é‡å¯èƒ½ä¸ä¸º8ï¼Œè¿˜å¥½waäº†ä¸€æ¬¡å°±æƒ³åˆ°è¿™ä¸ªäº†ï¼Œä¸ç„¶å¯èƒ½è¦è‡ªé—­â€¦â€¦\nD - Eko é¢˜æ„ï¼š ç»™å‡º$N$æ£µæ ‘çš„é«˜åº¦ï¼Œä½ å¯ä»¥é€‰æ‹©æŸä¸€ä¸ªé«˜åº¦ï¼Œç„¶åæŠŠæ‰€æœ‰åœ¨æ­¤é«˜åº¦ä¹‹ä¸Šçš„æœ¨å¤´éƒ½ç æ‰ï¼Œå¯¹äºç»™å‡ºçš„$M$å•ä½çš„æ ‘æœ¨ï¼Œæ‰¾å‡ºè‡³å°‘èƒ½è·å¾—è¿™äº›æ•°é‡çš„æœ€é«˜é«˜åº¦ã€‚\næ€è·¯ï¼š å› ä¸ºéšç€é«˜åº¦ä»ä½åˆ°é«˜ï¼Œç æ‰çš„æ ‘æœ¨çš„æ•°é‡å•è°ƒé€’å¢ï¼Œæ‰€ä»¥å¯ä»¥ç”¨äºŒåˆ†æœç´¢ã€‚æ¨èä¸€ç§äºŒåˆ†çš„å†™æ³•ï¼Œå¾ˆå¥½è®°ï¼Œå¯ä»¥å¯¹ä»˜å„ç§ç±»å‹çš„äºŒåˆ†ã€‚\nä»£ç \n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i,n) for(int i=0;i\u0026lt;int(n);++i) #define for1(i,n) for(int i=1;i\u0026lt;=int(n);++i) #define fore(i,a,b) for(int i=int(a);i\u0026lt;=b;++i) #define ms(a,x) memset(a,x,sizeof(a)); typedef long long ll; using namespace std; const int N=1e6+5; ll a[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ll r=0; forn(i,n) { cin\u0026gt;\u0026gt;a[i]; r=max(a[i],r); } ll l=0; while(l\u0026lt;=r){ ll tot=0; ll mid=(l+r)/2; forn(i,n){ if(a[i]\u0026gt;mid) tot+=a[i]-mid; } if(tot\u0026gt;=m) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r; return 0; } E - Election é¢˜æ„ï¼š æœ‰$N$ä¸ªäººæŠ•ç¥¨ï¼Œå·²ç»çŸ¥é“ç¬¬ä¸€ä¸ªäººæœ‰$V_1$ç¥¨ï¼Œç¬¬äºŒä¸ªäººæœ‰$V_2$ç¥¨ï¼Œå·²çŸ¥æ¯ä¸ªäººæŠ•ç¥¨éƒ½æ˜¯éšæœºçš„ï¼Œåˆ¤æ–­æ˜¯ä»¥ä¸‹å“ªä¸‰ç§æƒ…å†µï¼š1ã€ç¬¬ä¸€ä¸ªäººçš„èƒœå‡ºçš„æ¦‚ç‡è¶…è¿‡$W%$, 2ã€ç¬¬ä¸€ä¸ªäººå¿…è¾“ï¼Œ3ã€å‰©ä¸‹çš„æƒ…å†µã€‚\næ€è·¯ï¼š æ’åˆ—ç»„åˆçš„é—®é¢˜ï¼Œä¸€ç›´è¢«å¡åˆ°ç»“æŸï¼Œåˆ°ç¬¬äºŒå¤©æ‰å‘ç°æ˜¯ç®—ç»„åˆæ•°çš„æ—¶å€™çˆ†äº†å› ä¸ºç”¨äº†æœ€ä¸ºå¼±æ™ºçš„ç®—æ³•ã€‚ç®—$C_m^n$æ—¶åº”ä¹˜ä¸€ä¸ªé™¤ä¸€ä¸ªï¼Œåˆ†å­çš„éƒ¨åˆ†åº”ä»$m-n+1$å¼€å§‹ä¹˜ï¼Œåˆ†æ¯çš„éƒ¨åˆ†åº”ä»$1$å¼€å§‹é™¤ï¼Œå¦‚æœæœ€ç»ˆç»“æœåœ¨long longä¹‹å†…çš„è¯è¿™æ ·ç®—å°±ä¸ä¼šçˆ†ã€‚è¿˜å¥½æœ€å¤šåªæœ‰50ä¸ªäººæŠ•ç¥¨ï¼Œæœ€å¤šåªæœ‰$2^{50}$ç§æƒ…å†µã€‚\nä»£ç \n#include \u0026lt;iostream\u0026gt; typedef long long ll; ll calc(int a, int b) { if (a - b \u0026lt; b) b = a - b; ll ans = 1; for(int i=1,i\u0026lt;=b;i++) ans = ans*(a -b+ i)/i; return ans; } using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, v1, v2, w; int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; w; if (n - v2 \u0026lt;= v2) cout \u0026lt;\u0026lt; \u0026#34;RECOUNT!\\n\u0026#34;; else { ll ans = 0; int lef = n - v1 - v2; for (int i = 0; i \u0026lt;= lef; i++) { if (v1 + i \u0026gt; v2 + lef - i) { ans += calc(lef, i); } } if (ans * 100.0 / (1ll \u0026lt;\u0026lt; lef) \u0026gt; w) cout \u0026lt;\u0026lt; \u0026#34;GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;PATIENCE, EVERYONE!\\n\u0026#34;; } } return 0; ","date":1569456e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569456e3,"objectID":"ca68e2fdf2ef411e82a185136ccf1a65","permalink":"https://tgc54.com/zh/post/york2tutr/","publishdate":"2019-09-26T00:00:00Z","relpermalink":"/zh/post/york2tutr/","section":"post","summary":"è¿˜ç®—é¡ºåˆ©çš„ä¸€åœº\n","tags":null,"title":"York University programming contest 2 é¢˜è§£","type":"post"},{"authors":null,"categories":["é¢˜è§£"],"content":" ç»è¿‡é•¿æ—¶é—´æ€è€ƒå¹¶è§£å†³è°ƒé—®é¢˜çš„æ„Ÿè§‰å¤ªå¥½äº† â€”â€”xls\né¢˜ç›®é“¾æ¥\nç½‘ä¸Šçš„é¢˜è§£æ¯”è¾ƒå°‘è€Œä¸”éƒ½è®²çš„æ¯”è¾ƒè·³è·ƒï¼Œä¸çŸ¥é“æ˜¯ä»–ä»¬å¤ªèªæ˜è¿˜æ˜¯æˆ‘å¤ªç¬¨äº†ã€‚äºæ˜¯æœ¬ç€åˆ¨æ ¹é—®åº•çš„ç²¾ç¥æˆ‘è¯¦ç»†æ¨å¯¼äº†ä¸‹è¿‡ç¨‹ã€‚å¦‚æœæƒ³éº»çƒ¦äº†æ¬¢è¿æŒ‡æ­£ã€‚\né¦–å…ˆï¼Œfareyæ•°åˆ—çš„åˆ†æ¯æ„æˆçš„æ•°åˆ—ä¸€å®šæ˜¯å¯¹ç§°çš„ï¼Œå› ä¸ºå¦‚æœåˆ†å­ä¸åˆ†æ¯äº’è´¨ï¼Œé‚£ä¹ˆåˆ†æ¯ä¸åˆ†å­çš„å·®ä¹Ÿä¸€å®šä¸åˆ†æ¯äº’è´¨ï¼Œè¿™ä¸ªå¯ä»¥ç”¨åè¯æ³•è¯æ˜ï¼šè®¾åˆ†æ¯æ˜¯$m$ï¼Œåˆ†å­æ˜¯$n$ï¼Œå¦‚æœ$m$ä¸$n$ä¸äº’è´¨ï¼Œé‚£ä¹ˆå¯ä»¥å†™æˆ$m=k \\cdot p,n=j \\cdot p$é‚£ä¹ˆ$m-n=(k-j)\\cdot p$ä¸$m$ä¹Ÿä¸äº’è´¨ï¼Œæ‰€ä»¥$ \\dfrac{n}{m}$ä¸$\\dfrac{m-n}{m}$è¦ä¹ˆéƒ½åœ¨æ•°åˆ—é‡Œè¦ä¹ˆéƒ½ä¸åœ¨æ•°åˆ—é‡Œã€‚\nå…¶æ¬¡ï¼Œè®¾å½“å‰çš„orderæ˜¯$k$,é‚£ä¹ˆå½“orderå¢åŠ åˆ°$k+1$æ—¶ï¼Œå°†ä¼šæœ‰$\\varphi(k+1)$ä¸ªæ•°è¢«æ’å…¥ï¼Œè¿™ä¸ªé“ç†å¾ˆç®€å•ï¼šå¦‚æœä¸æ˜¯äº’è´¨çš„è¯å°±è¢«çº¦æ‰äº†ã€‚\nä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹æ’å…¥çš„è¿™äº›æ•°å¯¹farey sumsæœ‰ä»€ä¹ˆå½±å“ï¼š\nè®¾$\\dfrac{n}{m}$æ’åˆ°äº†$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$ä¹‹ä¸­ï¼Œæˆ‘çœ‹åˆ°çš„é¢˜è§£éƒ½ç›´æ¥ç»™å‡ºäº†ç»“è®º$m=a+b$è¿™ä¸ªç»“è®ºçœ‹èµ·æ¥å¾ˆç¥å¥‡ï¼ˆäº‹å®ä¸Šè¿˜æœ‰$n=c+d$ï¼‰ï¼Œä½†æˆ‘æ€ä¹ˆä¹Ÿæƒ³ä¸å‡ºæ¥è¿™ä¸ªæ˜¯æ€ä¹ˆå¾—åˆ°çš„ï¼Œäºæ˜¯æˆ‘ä¸Šäº†ç»´åŸºç™¾ç§‘å¾—åˆ°äº†æ€è·¯ï¼š\né¦–å…ˆè¦å…ˆè¯æ˜$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$å¦‚æœåœ¨orderä¸º$\\max(a,b)$ä¸­æ˜¯ç›¸é‚»çš„ä¸¤é¡¹ï¼ˆå‡è®¾$\\dfrac{c}{a}$åœ¨åï¼Œå†™å®Œæ‰å‘ç°åé¢è¯æ˜æŠŠä¸¤ä¸ªå¼„åäº†ï¼Œæ‡’çš„æ”¹äº†â€¦â€¦ï¼‰é‚£ä¹ˆæœ‰$\\dfrac{c}{a}-\\dfrac{d}{b}=\\dfrac{1}{a\\cdot b}$å³$b\\cdot c-a\\cdot b=1$ï¼Œè¿™ä¸ªç»´åŸºä¸Šä¹Ÿæ²¡ç»™å‡ºè¯æ˜ï¼Œä¸è¿‡æ¯”è¾ƒå¥½æƒ³ï¼Œä¾ç„¶æ˜¯åè¯æ³•ï¼šå¦‚æœä¸¤ä¸ªæ•°ä¹‹é—´è¿˜æœ‰å…¶ä»–çš„æ•°$\\dfrac{n}{m}$ï¼Œé‚£ä¹ˆ$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b},\\dfrac{d}{b}-\\dfrac{n}{m}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œå¦‚æœ$a\u0026lt; b$ æˆ‘ä»¬å°±çœ‹å‰é¢é‚£ä¸ªä¸ç­‰å¼$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œé€šåˆ†å¾—$\\dfrac{a\\cdot n-c\\cdot m}{a\\cdot m}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œå› ä¸º$a\\cdot n-c\\cdot m\\ge 1$æ‰€ä»¥$a\\cdot m\u0026gt;a \\cdot b$ï¼Œä½†å› ä¸ºorderä¸º$b$æ‰€ä»¥mä¸èƒ½å¤§äº$b$ï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚$a\\ge b$çš„æƒ…å†µä¸å‰é¢åŒç†ã€‚\næœ‰äº†è¿™ä¸ªæˆ‘ä»¬å°±å¯ä»¥è½»æ¾è¯æ˜å½“$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$ä¹‹é—´æœ‰æ–°çš„æ•°$\\dfrac{n}{m}$æ’å…¥æ—¶é‚£ä¹ˆæœ‰$a\\cdot n-c\\cdot m=d\\cdot m-b\\cdot n$ç§»é¡¹å¾—$n(a+b)=m(c+d)$ï¼Œæœ€ç»ˆå¾—åˆ°$\\dfrac{n}{m}=\\dfrac{c+d}{a+b}$\næ˜ç™½äº†è¿™å…³é”®çš„ä¸€æ­¥ä¹‹åï¼ŒåŸæ¥farey sumsä¸­å’Œ$\\dfrac{a}{b}+\\dfrac{b}{a}$ï¼ˆæ•°åˆ—ä¸­å¯¹ç§°çš„ä¸¤é¡¹ï¼‰å°±å˜æˆäº†$\\dfrac{a}{a+b}+\\dfrac{a+b}{b}+\\dfrac{b}{a+b}+\\dfrac{a+b}{a}=3+\\dfrac{a}{b}+\\dfrac{b}{a}$ï¼Œæ‰€ä»¥æ¯æ’å…¥ä¸¤é¡¹ï¼Œfarey sumså°±å¢åŠ 3ï¼Œä¸€å…±æ’å…¥äº†$\\varphi(k+1)$é¡¹ï¼Œé‚£ä¹ˆfarey sumså°±å¢åŠ äº†$\\dfrac{3\\cdot\\varphi(k+1)}{2}$ï¼Œåˆå› ä¸ºorderä»0å˜æˆ1çš„æ—¶å€™åªå¢åŠ äº†1,æ¯”$\\dfrac{3}{2}$å°‘äº†$\\dfrac{1}{2}$ï¼Œæ‰€ä»¥æœ€ç»ˆç­”æ¡ˆåº”ä¸º$\\sum_{i=1}^{n}{\\dfrac{3\\cdot \\varphi(i)}{2}}-\\dfrac{1}{2}$\nä»£ç \n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) using namespace std; const int N = 10005; int phi[N], phisum[N]; void phi_table(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) if (!phi[i]) for (int j = i; j \u0026lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; phi_table(10000); for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i]; for1(i, n) { int p, x; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (3 * phisum[p] - 1) \u0026lt;\u0026lt; \u0026#34;/2\\n\u0026#34;; } return 0; } ","date":1569369600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569369600,"objectID":"2e7c7a32eca3d5ac1c1521b581053b32","permalink":"https://tgc54.com/zh/post/kattis_fareysums/","publishdate":"2019-09-25T00:00:00Z","relpermalink":"/zh/post/kattis_fareysums/","section":"post","summary":" ç»è¿‡é•¿æ—¶é—´æ€è€ƒå¹¶è§£å†³è°ƒé—®é¢˜çš„æ„Ÿè§‰å¤ªå¥½äº† â€”â€”xls\n","tags":["æ•°å­¦","æ¬§æ‹‰å‡½æ•°"],"title":"Kattis - Farey Sumsé¢˜è§£","type":"post"},{"authors":null,"categories":["è®­ç»ƒé¢˜è§£"],"content":"B - Godfather Gym - 101649G é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæœ‰nä¸ªç‚¹çš„æ ‘ï¼Œé—®å»æ‰å“ªä¸ªç‚¹åå‰©ä¸‹çš„æ ‘ä¸­æœ€å¤§çš„èŠ‚ç‚¹æ•°æœ€å°ï¼ˆå¦‚æœæœ‰å¤šä¸ªæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºè¾“å‡ºï¼‰ã€‚\næ€è·¯ï¼š ä¸€å¼€å§‹æ²¡çœ‹è§â€œä¿è¯æ˜¯ä¸€æ£µæ ‘â€æƒ³å¤æ‚äº†ï¼Œå…ˆè·‘ä¸€édfsåºï¼Œè¿™æ ·å°±èƒ½çŸ¥é“æ¯ä¸ªç‚¹é™¤äº†çˆ¶èŠ‚ç‚¹ä¹‹å¤–æ‰€æœ‰çš„å­æ ‘çš„å¤§å°äº†ï¼Œçˆ¶èŠ‚ç‚¹å¯¹åº”çš„â€œå­æ ‘â€çš„å¤§å°å°±æ˜¯nå‡å»æ‰€æœ‰å­æ ‘çš„å¤§å°ä¹‹å’Œã€‚éå†æ‰€æœ‰ç‚¹ï¼Œæ‰¾å‡ºæ‰€æœ‰â€œå­æ ‘â€ä¸­æœ€å¤§çš„é‚£ä¸ªï¼Œå°†å…¶å¤§å°å’Œç¼–å·ä½œä¸ºæ•°å¯¹åŠ å…¥æ•°ç»„ä¸­ï¼Œç„¶åå¯¹æ‰€æœ‰ç‚¹æ’åºï¼Œè¾“å‡ºæœ€å°çš„é‚£å‡ ä¸ªå°±è¡Œäº†ã€‚\nE - Wow! Such Doge! HDU - 4847 é¢˜æ„ï¼š ç»™å‡ºä¸€ç¯‡æ–‡ç« ï¼Œé—®å…¶ä¸­å‡ºç°è¿‡å¤šå°‘ä¸ª\u0026#34;doge\u0026#34;ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ã€‚\næ€è·¯ï¼š å…ˆéå†æ–‡ç« ï¼Œå°†æ‰€æœ‰å¤§å†™ä¹‹æ¯è½¬ä¸ºå°å†™ï¼Œç„¶åå†ç”¨findæˆ–è€…æš´åŠ›æŸ¥æ‰¾\u0026#34;doge\u0026#34;å³å¯ã€‚\nG - Theme Section HDU - 4763 é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²næ‰¾å‡ºä¸€ä¸ªæœ€é•¿çš„å­ä¸²ï¼ˆthemeï¼‰ï¼Œä½¿å…¶å‡ºç°åœ¨å¼€å¤´ä¸­é—´å’Œç»“å°¾ï¼ˆä¸å…è®¸é‡å ï¼‰\næ€è·¯ï¼š ä¸€å¼€å§‹è¢«æ ·ä¾‹è¯¯å¯¼äº†ï¼Œä»¥ä¸ºthemeé‡Œé¢åªèƒ½æœ‰ä¸€ç§å­—ç¬¦ï¼Œwaäº†å‡ å‘æ„Ÿè§‰ä¸å¯¹ï¼Œæ‰€ä»¥åº”è¯¥å…ˆè·‘å‰ç¼€å‡½æ•°ï¼Œç„¶åä»ä»ç¬¬äºŒä½éå†åˆ°å€’æ•°ç¬¬äºŒä½ï¼Œå¦‚æœæŸä¸€ä½å‰ç¼€å‡½æ•°å¤§äºå…¶åˆ°ç¬¬ä¸€ä½è·ç¦»çš„ä¸€åŠï¼Œåˆ™å–ä¸€åŠï¼Œæ‰¾å‡ºå…¶ä¸­çš„æœ€å¤§å€¼ï¼Œè¿™æ ·å°±å¾—åˆ°äº†å‡ºç°åœ¨ä¸­é—´çš„themeçš„æœ€å¤§é•¿åº¦ã€‚ç„¶åå†åˆ¤æ–­æœ€åä¸€ä½çš„å‰ç¼€é•¿åº¦æ˜¯å¦å¤§äºæ•´ä¸ªå­—ç¬¦ä¸²é•¿åº¦çš„ä¸‰åˆ†ä¹‹ä¸€ï¼Œå¦‚æœå¤§äºåˆ™å–ä¸‰åˆ†ä¹‹ä¸€ï¼Œè¿™æ ·å°±æ˜¯å‡ºç°åœ¨åé¢çš„themeçš„é•¿åº¦ï¼Œè¾“å‡ºä¸­é—´å’Œåé¢ä¸­æ¯”è¾ƒå°çš„ä¸€ä¸ªå³å¯ã€‚\nI - Path HDU - 6582 ä¸ä¼šç½‘ç»œæµï¼Œæœ‰ç©ºå†è¡¥ã€‚\n","date":1569110400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569110400,"objectID":"dc2df786082cd5357fa1fe68095698ef","permalink":"https://tgc54.com/zh/post/cugb4tutr/","publishdate":"2019-09-22T00:00:00Z","relpermalink":"/zh/post/cugb4tutr/","section":"post","summary":"","tags":["CUGBACM"],"title":"CUGBACM18çº§è®­ç»ƒ#4 é¢˜è§£","type":"post"},{"authors":null,"categories":["è®­ç»ƒé¢˜è§£"],"content":"1.HDU1686 é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªä¸² $S_1,S_2$ï¼Œé—®$S_1$åœ¨$S_2$ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚\næ€è·¯ï¼š kmpæ¿å­é¢˜ï¼Œæ³¨æ„è¦ç”¨scanfã€‚\n2.HDU2594 é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²$S_1,S_2$ï¼Œæ±‚æœ€é•¿çš„æ—¢æ˜¯$S_1$å‰ç¼€åˆæ˜¯$S_2$åç¼€çš„å­—ç¬¦ä¸²ã€‚\næ€è·¯ï¼š å¾ˆæ˜æ˜¾å°±æ˜¯æŠŠä¸¤ä¸ªä¸²æ‹¼èµ·æ¥ç„¶åæ±‚å‰ç¼€å‡½æ•°ï¼Œä¸è¿‡è¦æ³¨æ„çš„æ˜¯æ‹¼èµ·æ¥çš„ä¸²çš„å‰ç¼€å‡½æ•°æœ‰å¯èƒ½è¶…è¿‡ç»™å‡ºçš„ä¸²çš„é•¿åº¦ï¼Œè§£å†³åŠæ³•å°±æ˜¯åœ¨ä¸¤ä¸ªä¸²ä¸­é—´åŠ ä¸€ä¸ªç¬¦å·ã€‚\n3.HDU6629 é¢˜æ„ï¼š ç»™å‡ºå­—ç¬¦ä¸²$S$é—®ç”¨æš´åŠ›ç®—æ³•æ±‚$S$çš„Zå‡½æ•°ï¼ˆä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œå…¶ä¸­ç¬¬iä¸ªå…ƒç´ ä¸ºæ»¡è¶³ä»ä½ç½®iå¼€å§‹ä¸”ä¸ºså‰ç¼€çš„å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚ï¼‰éœ€è¦çš„æ¯”è¾ƒæ¬¡æ•°ã€‚\næ€è·¯ï¼š æ±‚æ¯ä¸€ä¸ªä½ç½®çš„æ¯”è¾ƒæ¬¡æ•°éƒ½ç­‰äºè¿™ä¸ªä½ç½®çš„zå‡½æ•°+1ï¼Œå› ä¸ºè¦å¾€åé¢å¤šæ¯”è¾ƒä¸€æ¬¡å‘ç°ä¸åŒ¹é…äº†æ‰ä¼šç»ˆæ­¢ï¼ˆå¦‚æœæ¯”è¾ƒåˆ°å­—ç¬¦ä¸²æœ«å°¾äº†å³i+z[i]\u0026gt;=nå°±ä¸ç”¨åŠ 1ï¼‰ï¼Œæ±‚å’Œå°±æ˜¯ç­”æ¡ˆã€‚\n4.Codeforces 1200E é¢˜æ„ï¼š ç»™äº†ä½ nä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åæŒ‰ç…§å¦‚ä¸‹æ–¹å¼åˆå¹¶å¾—åˆ°æ–°ä¸²$Sâ€™$:\nå¦‚æœ$Sâ€™$ä¸ºç©ºä¸²ï¼Œåˆ™ç›´æ¥åŠ å…¥$Sâ€™$ã€‚ å¦åˆ™ï¼Œæ¯æ¬¡æ¯”è¾ƒ$Sâ€™$çš„åç¼€ä¸å‰ç¼€ï¼Œå–å¤±é…ä½ç½®ä¹‹åçš„åç¼€åŠ å…¥$Sâ€™$ä¸­ æ±‚sâ€²\næ€è·¯ï¼š è®¾ç­”æ¡ˆä¸²çš„é•¿åº¦ä¸º$L_{ans}$,éœ€è¦åˆå¹¶çš„æ–°ä¸²çš„é•¿åº¦ä¸º$L$,å°†â€œæ–°ä¸²+#+ç­”æ¡ˆä¸²åé¢é•¿$\\min(L_{ans},L)$çš„å­ä¸²â€ä½œä¸ºæ•´ä½“è·‘å‰ç¼€å‡½æ•°ï¼Œè®¾æ•´ä¸ªä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ä¸º$len$,å°†æ–°ä¸²ä¸‹æ ‡ä¸º$len,len+1, \\cdots,L-1$çš„å­ä¸²åŠ åˆ°ç­”æ¡ˆä¸²ä¹‹åã€‚\n5.HDU3613 é¢˜æ„ï¼š ç»™å‡ºä¸€å­—ç¬¦ä¸²ï¼Œå…¶ä¸­æ¯ä¸€ç§å­—ç¬¦å¯¹åº”ä¸€ä¸ªä»·å€¼ï¼Œå°†å­—ç¬¦ä¸²åˆ‡æˆä¸¤æ®µï¼Œè®¡ç®—ä¸¤æ®µçš„ä»·å€¼å’Œï¼Œæ–¹æ³•å¦‚ä¸‹ï¼šå¦‚æœè¿™ä¸€æ®µæ˜¯å›æ–‡ä¸²ï¼Œä»·å€¼å°±æ˜¯æ¯ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„ä»·å€¼çš„å’Œï¼Œå¦åˆ™è¯¥ä¸²ä»·å€¼ä¸º0ã€‚æ±‚ä¸¤æ®µä»·å€¼ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚\næ€è·¯ï¼š å…ˆè·‘ä¸€éå¤§å¯é©¬æ‹‰è½¦ç®—æ³•ï¼Œç„¶åéå†æ±‚å‡ºä¸²çš„ä»·å€¼å‰ç¼€å’Œï¼Œç„¶åæšä¸¾åˆ†å‰²ç‚¹ï¼Œæ‰¾åˆ°ä¸¤ä¸ªä¸²çš„ä¸­å¿ƒï¼Œåˆ¤æ–­ä¸­å¿ƒçš„å›æ–‡ä¸²æ˜¯ä¸æ˜¯æ•´ä¸ªä¸²ï¼Œå¦‚æœæ˜¯å°±åˆ©ç”¨ä¹‹å‰ç®—çš„å‰ç¼€å’ŒåŠ é‚£ä¸ªä¸²çš„ä»·å€¼ï¼Œåœ¨æšä¸¾ä¸­ä¸æ–­æ›´æ–°ç­”æ¡ˆå³å¯ã€‚\n6. HDU2222 é¢˜æ„ï¼šç»™å‡ºnä¸ªå•è¯å’Œä¸€ä¸ªé•¿ä¸²ï¼Œé—®æœ‰å‡ ä¸ªå•è¯åœ¨é•¿ä¸²ä¸­å‡ºç°è¿‡ã€‚\næ€è·¯ï¼šACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œå¥½åƒæ²¡ä»€ä¹ˆå¥½è¯´çš„â€¦â€¦\n7.HDU2896 é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚\næ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚\n","date":1569024e3,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569024e3,"objectID":"499bf48a79ce8b2ce6abbaad0ac42aa5","permalink":"https://tgc54.com/zh/post/cugbacm3tutr/","publishdate":"2019-09-21T00:00:00Z","relpermalink":"/zh/post/cugbacm3tutr/","section":"post","summary":"","tags":["CUGBACM"],"title":"CUGBACM18çº§è®­ç»ƒ#3 é¢˜è§£","type":"post"},{"authors":null,"categories":["æ¯”èµ›é¢˜è§£","é¢˜è§£"],"content":"è¿™æ˜¯ä¸€åœºå…³äºèº«æ®‹å¿—åšçš„æ¯”èµ›ã€‚é‚£å¤©æ™šä¸Šåˆ‡èœæ—¶åˆ‡ç€æ‰‹äº†ï¼Œå»äº†åŒ»é™¢ï¼Œæ²¡æƒ³åˆ°æŒ‚ä¸ªæ€¥è¯Šè¿˜è¦ç­‰è¿™ä¹ˆä¹…ï¼Œå¿ƒæƒ³æ™šä¸Šçš„æ¯”èµ›è‚¯å®šæ³¡æ±¤äº†ï¼Œç­‰å¾…ä¹‹ä½™æƒ³èµ·è‡ªå·±åŒ…é‡Œè¿˜æœ‰iPadå’Œè“ç‰™é”®ç›˜ï¼Œè™½ç„¶æ¯”èµ›å·²ç»å¼€å§‹åŠå°æ—¶äº†ï¼Œè€Œä¸”è‡ªå·±åªæœ‰9æ ¹æŒ‡å¤´èƒ½ç”¨ï¼Œå°±å½“ç©ç©å§ï¼Œäºæ˜¯æˆ‘è¿ä¸Šé”®ç›˜ï¼Œæ‰“å¼€koderï¼Œåœ¨iPadä¸Šæ‰“èµ·äº†æ¯”èµ›ï¼Œæ²¡æƒ³åˆ°æœ€åå‡ºäº†ä¸‰ä¸ªé¢˜ï¼Œæ’åç¬¬ä¸‰ï¼Œæ‰‹æŒ‡å’Œæ¯”èµ›éƒ½ä¿ä½äº†â€¦â€¦\né¢˜ç›®é“¾æ¥\nA. Cold-puter Science é¢˜æ„ï¼š ç»™å‡º$n$ä¸ªæ•°é—®æœ‰å‡ ä¸ªæ•°å°äº0ã€‚\næ€è·¯ï¼š è¿™å°±ä¸ç”¨è¯´äº†å§ï¼ŒåŸºæœ¬ä¸Šæ˜¯æˆ‘è§è¿‡çš„æœ€æ°´çš„ç­¾åˆ°é¢˜äº†ã€‚\nB. Are You Listening? é¢˜æ„ï¼š ç»™å‡ºè‡ªå·±çš„åæ ‡$cx,cy$ä»¥åŠ$n$ä¸ªæ•Œæ”¾ç›‘å¬ç‚¹çš„åæ ‡å’Œç›‘å¬åŠå¾„$x,y,r$ï¼Œå¯¹æ–¹æœ€å°‘éœ€è¦3ä¸ªç‚¹æ¢æµ‹åˆ°ä½ æ‰èƒ½ç¡®å®šä½ çš„ä½ç½®ï¼Œé—®è‡ªå·±å¹¿æ’­çš„æœ€å¤§åŠå¾„æ˜¯å¤šå°‘ï¼ˆç­”æ¡ˆå¯èƒ½æ˜¯0ï¼Œå‘ä¸‹å–æ•´ï¼‰ã€‚\næ€è·¯ï¼š è®¾ç›‘å¬ç‚¹çš„ä¸ä½ çš„è·ç¦»æ˜¯$d$ï¼ŒåŠå¾„æ˜¯$r$ï¼Œé‚£ä¹ˆ$d-r$å°±æ˜¯ä¸è¢«æ£€æµ‹åˆ°çš„æœ€å¤§å¹¿æ’­åŠå¾„ã€‚äºæ˜¯æ¯è¯»å…¥ä¸€ç»„ç›‘å¬ç‚¹çš„æ•°æ®å°±è®¡ç®—å‡º$d-r$å¹¶å­˜å…¥æ•°ç»„ä¸­ï¼Œæœ€åå¯¹æ•°ç»„æ’åºï¼Œå¦‚æœç¬¬ä¸‰ä¸ªæ•°å°äº0å°±è¾“å‡º0å¦åˆ™è¾“å‡ºå‘ä¸‹å–æ•´åçš„æ•°ã€‚\nC. Chewbacca é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæœ‰$N$ä¸ªèŠ‚ç‚¹çš„æ»¡æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰$K$ä¸ªå­èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„éœ€è¦ä»ä¸Šå¾€ä¸‹ã€ä»å·¦å¾€å³æ’åˆ—ï¼Œç»™å‡º$Q$ä¸ªè¯¢é—®ï¼Œé—®æ ‘ä¸Šä¸¤ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚\næ€è·¯ï¼š å½“æ—¶æƒ³åˆ°æ˜¯æ±‚LCAäº†ï¼Œä½†å› ä¸ºæ²¡å­¦è¿‡è€Œä¸”æ’åˆ°æˆ‘äº†å°±æ²¡åšï¼Œå…¶å®è¿™é¢˜å¾ˆç®€å•ï¼Œå› ä¸ºé¢˜ç›®å¾ˆç‰¹æ®Šï¼šæ˜¯ä¸€æ£µæ»¡æ ‘å¹¶ä¸”çˆ¶äº²ä¸å„¿å­ä¹‹é—´çš„è·ç¦»æ˜¯1ï¼Œæ‰€ä»¥å¯èƒ½é‡‡ç”¨æ¯”è¾ƒæš´åŠ›çš„ç®—æ³•ï¼Œç»è¿‡å®éªŒå¯ä»¥å‘ç°ï¼šå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„åºå·æ˜¯$n$ï¼Œé‚£ä¹ˆ$(n+K-2)/K$å°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„åæ ‡ï¼Œç”±æ­¤æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä¸æ–­é™¤å¾—åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æ·±åº¦(å…¶å®å¥½åƒä¹Ÿå¯ä»¥ç›´æ¥æ±‚$\\lceil \\log_Kn \\rceil$)ï¼Œå…ˆä½¿æ·±åº¦æ¯”è¾ƒå¤§çš„èŠ‚ç‚¹è·³è½¬åˆ°æ·±åº¦æ¯”è¾ƒå°çš„èŠ‚ç‚¹çš„æ·±åº¦ï¼Œç„¶åä»¤ä¸¤ä¸ªç‚¹åŒæ—¶å‘ä¸Šè·³è½¬ç›´åˆ°é‡åˆã€‚\nD. Bike Gears é¢˜æ„ï¼š ç»™å‡ºè‡ªè¡Œè½¦æ‰€æœ‰å‰å˜é€Ÿè½®å’Œåå˜é€Ÿè½®çš„é½¿æ•°ï¼Œå®šä¹‰ä¸€ç»„é½¿è½®ç»„åˆçš„gearå€¼ä¸ºå‰é½¿è½®æ•°é™¤ä»¥åé½¿è½®æ•°ï¼Œè¦æ±‚æŒ‰ç…§gearå€¼ä»å°åˆ°å¤§è¾“å‡ºæ‰€æœ‰é½¿è½®çš„ç»„åˆã€‚\næ€è·¯ï¼š ç”±äºé½¿è½®æ•°å¯å¤§è‡³$10^9$ï¼Œå³ä½¿æ˜¯ç”¨long doubleæ¥å­˜gearå€¼ä¹Ÿä¼šå‡ºç°ç²¾åº¦é—®é¢˜ã€‚æ‰€ä»¥åªèƒ½å­˜gearçš„æœ€ç®€åˆ†æ•°ï¼Œåœ¨æ’åºçš„æ—¶å€™ç”¨é€šåˆ†æ¥æ¯”è¾ƒï¼Œæ³¨æ„è™½ç„¶å•ä¸ªé½¿è½®çš„å€¼æ²¡æœ‰è¶…è¿‡intä½†é€šåˆ†çš„æ—¶å€™ç›¸ä¹˜å°±å¯èƒ½çˆ†ï¼Œæ‰€ä»¥è¦ç”¨long longæ¥å­˜å‚¨ã€‚è¿˜æœ‰ä¸€ç‚¹æ¯”è¾ƒå‘çš„å°±æ˜¯é¢˜ç›®é‡Œæ²¡è¯´å¦‚æœä¸¤ç»„é½¿è½®çš„gearç›¸åŒæ€ä¹ˆåŠï¼Œåªèƒ½ä»æ ·ä¾‹é‡Œæ¥æ¨æ–­æ˜¯å…ˆè¾“å‡ºå°çš„ã€‚ solution: As the number of sprockets can be as large as $10^9$, even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first.\n","date":1568505600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1568505600,"objectID":"1534edf685d5bd35b600174d86d59f30","permalink":"https://tgc54.com/zh/post/yorku1totr/","publishdate":"2019-09-15T00:00:00Z","relpermalink":"/zh/post/yorku1totr/","section":"post","summary":"è¿™æ˜¯ä¸€åœºå…³äºèº«æ®‹å¿—åšçš„æ¯”èµ›ã€‚é‚£å¤©æ™šä¸Šåˆ‡èœæ—¶åˆ‡ç€æ‰‹äº†ï¼Œå»äº†åŒ»é™¢ï¼Œæ²¡æƒ³åˆ°æŒ‚ä¸ªæ€¥è¯Šè¿˜è¦ç­‰è¿™ä¹ˆä¹…ï¼Œå¿ƒæƒ³æ™šä¸Šçš„æ¯”èµ›è‚¯å®šæ³¡æ±¤äº†ï¼Œç­‰å¾…ä¹‹ä½™æƒ³èµ·è‡ªå·±åŒ…é‡Œè¿˜æœ‰iPadå’Œè“ç‰™é”®ç›˜ï¼Œè™½ç„¶æ¯”èµ›å·²ç»å¼€å§‹åŠå°æ—¶äº†ï¼Œè€Œä¸”è‡ªå·±åªæœ‰9æ ¹æŒ‡å¤´èƒ½ç”¨ï¼Œå°±å½“ç©ç©å§ï¼Œäºæ˜¯æˆ‘è¿ä¸Šé”®ç›˜ï¼Œæ‰“å¼€koderï¼Œåœ¨iPadä¸Šæ‰“èµ·äº†æ¯”èµ›ï¼Œæ²¡æƒ³åˆ°æœ€åå‡ºäº†ä¸‰ä¸ªé¢˜ï¼Œæ’åç¬¬ä¸‰ï¼Œæ‰‹æŒ‡å’Œæ¯”èµ›éƒ½ä¿ä½äº†â€¦â€¦\n","tags":null,"title":"York Univeristy programming contest ç¬¬ä¸€åœºé¢˜è§£","type":"post"},{"authors":null,"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546300800,"objectID":"9a6cb9348361050ffbcc0117246adb56","permalink":"https://tgc54.com/zh/tag/","publishdate":"2019-01-01T00:00:00Z","relpermalink":"/zh/tag/","section":"","summary":"Tags","tags":null,"title":"Tags","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1461715200,"objectID":"132307db5be65259d13c54046ba169ea","permalink":"https://tgc54.com/zh/project/cf-plot/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/zh/project/cf-plot/","section":"project","summary":"ç”»cfåˆ†æ•°æ›²çº¿å›¾","tags":null,"title":"cf-plot","type":"project"}]