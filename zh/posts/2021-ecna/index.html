<!doctype html><html lang=zh><head><title>2021 ECNA区域赛总结与题解 ::
Thallium54</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="差不多最后一年了，明年队友估计就都毕业了，看看能不能找到其他人吧，或者solo也行？
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://tgc54.com/zh/posts/2021-ecna/><link rel=stylesheet href=https://tgc54.com/assets/style.css><link rel=stylesheet href=https://tgc54.com/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://tgc54.com/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://tgc54.com/img/favicon.png><link href=https://tgc54.com/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="2021 ECNA区域赛总结与题解"><meta name=twitter:description content="差不多最后一年了，明年队友估计就都毕业了，看看能不能找到其他人吧，或者solo也行？"><meta property="og:title" content="2021 ECNA区域赛总结与题解"><meta property="og:description" content="差不多最后一年了，明年队友估计就都毕业了，看看能不能找到其他人吧，或者solo也行？"><meta property="og:type" content="article"><meta property="og:url" content="https://tgc54.com/zh/posts/2021-ecna/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-26T21:07:17-05:00"><meta property="article:modified_time" content="2022-02-26T21:07:17-05:00"><meta property="og:site_name" content="Thallium54"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><div class=container><header class=header><span class=header__inner><a href=/zh class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Thallium54</span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/zh/posts>博文</a></li><li><a href=/zh/categories>分类</a></li><li><a href=/zh/tags>标签</a></li><li><a href=https://wiki.tgc54.com>Wiki</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/zh/posts>博文</a></li><li><a href=/zh/categories>分类</a></li><li><a href=/zh/tags>标签</a></li><li><a href=https://wiki.tgc54.com>Wiki</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-half-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><path d="M12 3v18"/><path d="M12 14l7-7"/><path d="M12 19l8.5-8.5"/><path d="M12 9l4.5-4.5"/></svg></span><span class=lang-toggle><div class="dropdown menu__sub-inner"><div class=link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-world" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><line x1="3.6" y1="9" x2="20.4" y2="9"/><line x1="3.6" y1="15" x2="20.4" y2="15"/><path d="M11.5 3a17 17 0 000 18"/><path d="M12.5 3a17 17 0 010 18"/></svg></div><ul class=menu__sub-inner-more><li><a href=https://tgc54.com/zh/posts/2021-ecna/>简体中文</a></li></ul></div></span></span></span></header><div class=content><div class=post><h1 class=post-title>2021 ECNA区域赛总结与题解</h1><div class=post-meta><span class=post-date>2022-02-26</span></div><div class=post-content><p>差不多最后一年了，明年队友估计就都毕业了，看看能不能找到其他人吧，或者solo也行？</p><h2 id=总结>总结
<a href=#%e6%80%bb%e7%bb%93 class=h-anchor aria-hidden=true>#</a></h2><p>今年由于疫情依然不能去温莎线下比赛，但相比去年三人三机今天变成了更像线下的三人一机，不过是在各自学校比赛，但令人不能理解是的居然一点监控措施都没有，全凭自己自觉和教练监督。。。。可以理解为摆烂吧😂。我们队算是做到了遵循规则，除了多接了一个显示器用来看代码（自己电脑没法连机房的打印机），以及我还是用的自己的键盘（用40%配列太久了改不回来了）。</p><p><a href=https://ecna21.kattis.com/standings>排名</a>有点出乎意料，考虑到队友忙于实习从不训练、我上了大三之后课程难度增加，只能靠每周cf维持一点做题量，这个排名已经很满意了，毕竟如果按NAC晋级规则按学校排名是第6，校排名要是第5的话总排名要第6，完全想peach😂。</p><p>整场比赛还是比较流畅的，基本没有卡太长时间，A题作为比较简单的题卡了有点久，最后还是靠猜结论过的，F计算几何某队友到最后也没搞出来，不过没占用太多正常时间。时间再稍微多一点也许能搞搞I或者K，不过到最后也比有点累了，昨晚也只睡了5个半小时。</p><h2 id=题目>题目
<a href=#%e9%a2%98%e7%9b%ae class=h-anchor aria-hidden=true>#</a></h2><p>题目整体难度适中？比去年难一点，（读了的题）以思维题为主。除了J题摆烂出了最大子矩形原题，题目质量还可以？</p><h3 id=a>A
<a href=#a class=h-anchor aria-hidden=true>#</a></h3><p>一开始wa是因为忘了考虑相加的转移。考虑加的话要遍历一遍整个dp数组，时间复杂度会变成$O(n^2)$，但其实也能过因为时间给了15s。。。（我tm写博客的时候才发现）。但貌似只要遍历前面一些数就行了，因为数大的时候乘肯定比加划算。</p><div class=collapsable-code><input id=645789231 type=checkbox checked>
<label for=645789231><span class=collapsable-code__language>cpp</span>
<span class=collapsable-code__title>代码</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-cpp><code>

#include &lt;bits/stdc&#43;&#43;.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; dp(n &#43; 1, 1e9);
    dp[1] = 1;
    for (int i = 2; i &lt;= n; i&#43;&#43;) {
        dp[i] = i;

        for (int j = 1; j &lt;= min(i / 2 &#43; 1, 1000); j&#43;&#43;)
            dp[i] = min(dp[i], dp[j] &#43; dp[i - j]);

        string s = to_string(i);
        for (int j = 1; j &lt; (int)size(s); j&#43;&#43;) {
            string s1 = s.substr(0, j), s2 = s.substr(j);
            if (s2[0] == &#39;0&#39;) continue;
            dp[i] = min(dp[i], dp[stoi(s1)] &#43; dp[stoi(s2)]);
        }

        for (int f = 2; f * f &lt;= i; f&#43;&#43;) {
            if (i % f == 0) { dp[i] = min(dp[i], dp[f] &#43; dp[i / f]); }
        }
    }
    cout &lt;&lt; dp[n] &lt;&lt; endl;
}
</code></pre></div><h3 id=b>B
<a href=#b class=h-anchor aria-hidden=true>#</a></h3><p>赛时无脑敲了个lca，但其实稍微再想想就有更简单的做法：dfs时维护到根节点的距离以及最短的两条到叶子的路径的举例即可。</p><div class=collapsable-code><input id=869245731 type=checkbox checked>
<label for=869245731><span class=collapsable-code__language>cpp</span>
<span class=collapsable-code__title>代码</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-cpp><code>
#include &lt;bits/stdc&#43;&#43;.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; g(n);
    vector&lt;int&gt; a(n);
    for (auto &amp;x : a)
        cin &gt;&gt; x;
    vector&lt;int&gt; indeg(n), sum(n), color(n);
    for (int i = 0; i &lt; m; i&#43;&#43;) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        u--, v--;
        g[u].push_back(v);
        indeg[v]&#43;&#43;;
    }
    int c = 0;
    int ans = 1e9;
    auto dfs = [&amp;](auto &amp;slf, int u, int s) -&gt; int {
        sum[u] = s &#43; a[u];
        color[u] = c;
        int mn0 = 1e9, mn1 = 1e9;
        for (auto v : g[u]) {
            auto res = slf(slf, v, s &#43; a[u]);
            if (res &lt; mn1) mn1 = res;
            if (mn1 &lt; mn0) swap(mn0, mn1);
        }
        ans = min(ans, mn0 &#43; mn1 &#43; sum[u]);
        return (mn0 == 1e9 ? 0 : mn0) &#43; a[u];
    };
    for (int i = 0; i &lt; n; i&#43;&#43;) {
        if (indeg[i] == 0) {
            dfs(dfs, i, 0);
            c&#43;&#43;;
        }
    }
    for (int i = 0; i &lt; n; i&#43;&#43;) {
        for (int j = i &#43; 1; j &lt; n; j&#43;&#43;) {
            if (g[i].empty() &amp;&amp; g[j].empty()) {
                if (color[i] != color[j]) {
                    ans = min(ans, sum[i] &#43; sum[j]);
                }
            }
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre></div><h3 id=g>G
<a href=#g class=h-anchor aria-hidden=true>#</a></h3><p>签到题，枚举所有前缀以及交换顺序即可</p><div class=collapsable-code><input id=618542973 type=checkbox checked>
<label for=618542973><span class=collapsable-code__language>cpp</span>
<span class=collapsable-code__title>代码</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-cpp><code>
#include &lt;bits/stdc&#43;&#43;.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string a, b, c;
    char op, _;
    cin &gt;&gt; a &gt;&gt; op &gt;&gt; b &gt;&gt; _ &gt;&gt; c;
    auto check = [&amp;](string a_, string b_, string c_) {
        __int128 a = stoll(a_), b=stoll(b_), c = stoll(c_);
        if (op==&#39;&#43;&#39;) return a&#43;b==c;
        else return a*b==c;
    };
    for (int i=1; i&lt;(int)size(a); i&#43;&#43;) {
        for (int j=1; j&lt;(int)size(b); j&#43;&#43;) {
            for (int k=1; k&lt;(int)size(c); k&#43;&#43;) {
                string a1=a.substr(0, i), a2=a.substr(0&#43;i);
                string b1=b.substr(0, j), b2=b.substr(0&#43;j);
                string c1=c.substr(0, k), c2=c.substr(0&#43;k);
                vector&lt;string&gt; s = {a1, b1, c1};
                sort(begin(s), end(s));
                do {
                    if (check(s[0]&#43;a2, s[1]&#43;b2, s[2]&#43;c2)) {
                        cout &lt;&lt; s[0]&#43;a2 &lt;&lt; &#39; &#39; &lt;&lt; op &lt;&lt; &#39; &#39; &lt;&lt;  s[1]&#43;b2 &lt;&lt; &#34; = &#34; &lt;&lt; s[2]&#43;c2;
                        exit(0);
                    }
                } while (next_permutation(begin(s), end(s)));
            }
        }
    }
}
</code></pre></div><h3 id=j>J
<a href=#j class=h-anchor aria-hidden=true>#</a></h3><p>经典最大子矩阵，单调栈搞搞即可。其实我赛时已经基本忘了怎么做了，只记得是是单调栈，想了半天才想出来正解，这下应该以后忘不了了233</p><div class=collapsable-code><input id=874256913 type=checkbox checked>
<label for=874256913><span class=collapsable-code__language>cpp</span>
<span class=collapsable-code__title>代码</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-cpp><code>
#include &lt;bits/stdc&#43;&#43;.h&gt;
using namespace std;
using ll = long long; //}}}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; &#43;&#43;i) {
        cin &gt;&gt; a[i];
    }
    stack&lt;pair&lt;int, int&gt;&gt; stk;
    ll ans = 0;
    int s = 1e9, e = 0;

    auto update = [&amp;](ll cur, int curs, int cure) {
        if (cur &gt; ans || (cur == ans &amp;&amp; curs &lt; s)) {
            ans = cur;
            s = curs;
            e = cure;
        }
    };
    for (int i = 0; i &lt; n; i&#43;&#43;) {
        int prev = i;
        while (!stk.empty() &amp;&amp; stk.top().first &gt;= a[i]) {
            prev = stk.top().second;
            ll cur = ll(i - prev) * stk.top().first;
            update(cur, prev, i - 1);
            stk.pop();
        }
        ll cur = ll(i - prev &#43; 1) * a[i];
        update(cur, prev, i);
        stk.push({a[i], prev});
    }
    while (!stk.empty()) {
        auto [x, i] = stk.top();
        stk.pop();
        ll cur = ll(n - i) * x;
        update(cur, i, n - 1);
    }
    cout &lt;&lt; s &#43; 1 &lt;&lt; &#39; &#39; &lt;&lt; e &#43; 1 &lt;&lt; &#39; &#39; &lt;&lt; ans &lt;&lt; endl;
}
</code></pre></div><h3 id=l>L
<a href=#l class=h-anchor aria-hidden=true>#</a></h3><p>枚举四个角然后排序分层搞一搞，队友写的</p><div class=collapsable-code><input id=157329846 type=checkbox checked>
<label for=157329846><span class=collapsable-code__language>python</span>
<span class=collapsable-code__title>代码</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-python><code>
import collections
import itertools
import sys
ints = lambda: list(map(int, sys.stdin.readline().split()))
grid = []
gy, gx = ints()
for y in range(gy):
  grid.append(ints())
statues = []
for row in grid:
  for cell in row:
    if ~cell:
      statues.append(cell)
statues.sort()

def levels(grid):
  ret1 = collections.defaultdict(set)
  ret2 = collections.defaultdict(set)
  for y in range(gy):
    for x in range(gx):
      cell = grid[y][x]
      if ~cell:
        ret1[y&#43;x].add(cell)
        ret2[y-x].add(cell)
  return ret1, ret2

ret1, ret2 = levels(grid)

keys1 = sorted(ret1.keys())
keys2 = sorted(ret2.keys())

import math
moved = math.inf

for keys, ret in (keys1, ret1), (reversed(keys1), ret1), (keys2, ret2), (reversed(keys2), ret2):
  this = len(statues)
  it = iter(statues)
  for key in keys:
    st = set()
    for _ in range(len(ret[key])):
      st.add(next(it))
    this -= len(st &amp; ret[key])
  moved = min(moved, this)

print(moved)
```
</code></pre></div><h3 id=m>M
<a href=#m class=h-anchor aria-hidden=true>#</a></h3><p>最短路考虑用bfs，把所有字符串放入一个trie就可以很容易知道哪些方向可以走了，所以状态就是[x][y][trie中的节点的位置][上一步的方向]。除了状态复杂点其他就是正常bfs的套路，注意如果当前在单词结尾的位置，下一步即可以回到trie的根，又可以继续顺着trie走。</p><div class=collapsable-code><input id=234758169 type=checkbox checked>
<label for=234758169><span class=collapsable-code__language>cpp</span>
<span class=collapsable-code__title>代码</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-cpp><code>
#include &lt;bits/stdc&#43;&#43;.h&gt;
using namespace std;

struct Trie {
    struct node {
        map&lt;char, int&gt; ch;
        bool term;
    };
    vector&lt;node&gt; t;
    Trie() { new_node(); }
    int new_node() {
        t.emplace_back();
        return t.size() - 1;
    }
    void insert(const string &amp;s) {
        int p = 0;
        for (auto ch : s) {
            if (!t[p].ch.count(ch)) { t[p].ch[ch] = new_node(); }
            p = t[p].ch[ch];
        }
        t[p].term = true;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    vector s(n, vector&lt;char&gt;(m));
    for (auto &amp;v : s)
        for (auto &amp;c : v)
            cin &gt;&gt; c;
    Trie tr;
    for (int i = 0; i &lt; k; i&#43;&#43;) {
        string ss;
        cin &gt;&gt; ss;
        tr.insert(ss);
    }
    vector dis(n, vector(m, vector(size(tr.t), vector(3, -1))));
    queue&lt;array&lt;int, 4&gt;&gt; q;
    for (int i = 0; i &lt; m; i&#43;&#43;) {
        if (tr.t[0].ch.count(s[0][i])) {
            int st = tr.t[0].ch[s[0][i]];
            dis[0][i][st][0] = 1;
            q.push({0, i, st, 0});
        }
    }

    const vector&lt;pair&lt;int, int&gt;&gt; dir{{1, 0}, {0, -1}, {0, 1}};
    while (!q.empty()) {
        auto [x, y, st, prev] = q.front();
        int olddis = dis[x][y][st][prev];
        q.pop();
        for (int ii = 0; ii &lt; (int)size(dir); ii&#43;&#43;) {
            auto [dx, dy] = dir[ii];
            if ((prev == 1 &amp;&amp; dy == 1) || (prev == 2 &amp;&amp; dy == -1))
                continue;
            unsigned nx = x &#43; dx, ny = y &#43; dy;
            if (nx &lt; n &amp;&amp; ny &lt; m) {
                auto go = [&amp;](int st) {
                    if (tr.t[st].ch.count(s[nx][ny])) {
                        int nst = tr.t[st].ch[s[nx][ny]];
                        if (dis[nx][ny][nst][ii] == -1) {
                            dis[nx][ny][nst][ii] = olddis &#43; 1;
                            q.push({(int)nx, (int)ny, nst, ii});
                        }
                    }
                };
                go(st);
                if (tr.t[st].term) {
                    st = 0;
                    go(st);
                }
            }
        }
    }
    int ans = 1e9;
    for (int i = 0; i &lt; m; i&#43;&#43;) {
        for (int d = 0; d &lt; 3; d&#43;&#43;) {
            for (int st = 0; st &lt; (int)size(tr.t); st&#43;&#43;) {
                if (tr.t[st].term &amp;&amp; dis[n - 1][i][st][d] != -1) {
                    ans = min(ans, dis[n - 1][i][st][d]);
                }
            }
        }
    }
    if (ans == 1e9) {
        cout &lt;&lt; &#34;impossible\n&#34;;
    } else
        cout &lt;&lt; ans &lt;&lt; endl;
}
```
</code></pre></div></div></div></div><footer class=footer><div class=footer__inner><a href=/zh class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Thallium54</span></a><div class=copyright><span>© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a>, moded by me</span></div></div></footer><script src=https://tgc54.com/assets/main.js></script>
<script src=https://tgc54.com/assets/prism.js></script></div></body></html>