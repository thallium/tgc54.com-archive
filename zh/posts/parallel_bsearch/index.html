<!doctype html><html lang=zh><head><title>整体二分学习笔记 ::
Thallium54</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="整体二分在国外称为parallel binary search，是一种用于同时解决大量二分搜索的离线算法。
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://tgc54.com/zh/posts/parallel_bsearch/><link rel=stylesheet href=https://tgc54.com/assets/style.css><link rel=stylesheet href=https://tgc54.com/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://tgc54.com/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://tgc54.com/img/favicon.png><link href=https://tgc54.com/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://tgc54.com/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="整体二分学习笔记"><meta name=twitter:description content="整体二分在国外称为parallel binary search，是一种用于同时解决大量二分搜索的离线算法。"><meta property="og:title" content="整体二分学习笔记"><meta property="og:description" content="整体二分在国外称为parallel binary search，是一种用于同时解决大量二分搜索的离线算法。"><meta property="og:type" content="article"><meta property="og:url" content="https://tgc54.com/zh/posts/parallel_bsearch/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-05T12:36:59-04:00"><meta property="article:modified_time" content="2021-06-05T12:36:59-04:00"><meta property="og:site_name" content="Thallium54"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><div class=container><header class=header><span class=header__inner><a href=/zh class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Thallium54</span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/zh/posts>博文</a></li><li><a href=/zh/categories>分类</a></li><li><a href=/zh/tags>标签</a></li><li><a href=https://wiki.tgc54.com>Wiki</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/zh/posts>博文</a></li><li><a href=/zh/categories>分类</a></li><li><a href=/zh/tags>标签</a></li><li><a href=https://wiki.tgc54.com>Wiki</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-circle-half-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><path d="M12 3v18"/><path d="M12 14l7-7"/><path d="M12 19l8.5-8.5"/><path d="M12 9l4.5-4.5"/></svg></span><span class=lang-toggle><div class="dropdown menu__sub-inner"><div class=link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-world" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><line x1="3.6" y1="9" x2="20.4" y2="9"/><line x1="3.6" y1="15" x2="20.4" y2="15"/><path d="M11.5 3a17 17 0 000 18"/><path d="M12.5 3a17 17 0 010 18"/></svg></div><ul class=menu__sub-inner-more><li><a href=https://tgc54.com/zh/posts/parallel_bsearch/>简体中文</a></li></ul></div></span></span></span></header><div class=content><div class=post><h1 class=post-title>整体二分学习笔记</h1><div class=post-meta><span class=post-date>2021-06-05</span></div><span class=post-tags><a href=https://tgc54.com/zh/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/>#整体二分</a>&nbsp;
<a href=https://tgc54.com/zh/tags/%E7%A6%BB%E7%BA%BF%E6%8A%80%E5%B7%A7/>#离线技巧</a>&nbsp;
<a href=https://tgc54.com/zh/tags/%E4%BA%8C%E5%88%86/>#二分</a>&nbsp;</span><div class=post-content><p>整体二分在国外称为parallel binary search，是一种用于同时解决大量二分搜索的<strong>离线算法</strong>。</p><h2 id=适用问题的描述>适用问题的描述
<a href=#%e9%80%82%e7%94%a8%e9%97%ae%e9%a2%98%e7%9a%84%e6%8f%8f%e8%bf%b0 class=h-anchor aria-hidden=true>#</a></h2><p>整体二分适用于多次询问的问题，且一次询问代价很大（通常是因为无法预处理），如果对每个询问单独跑一次二分就会有大量的检查结果被浪费，整体二分旨在将一次检查的结果用于多个询问，或者说是将询问归类，一起处理归类在一起询问。</p><h2 id=思路>思路
<a href=#%e6%80%9d%e8%b7%af class=h-anchor aria-hidden=true>#</a></h2><ol><li>假设当前有一些询问的答案在某个区间中，我们将区间一分为二</li><li>应用某一些修改，这些修改是可以帮助我们判断答案在在哪一半区间的修改</li><li>判断这些询问是否达到目标，将询问分为达到目标和没达到目标两个集合，同时可能会修改没达到目标的询问的目标（这一步要具体问题具体分析）</li><li>撤销步骤2中的修改</li><li>分别递归左右两个区间</li></ol><h2 id=例题>例题
<a href=#%e4%be%8b%e9%a2%98 class=h-anchor aria-hidden=true>#</a></h2><h3 id=多次询问数组第k小>多次询问数组第k小
<a href=#%e5%a4%9a%e6%ac%a1%e8%af%a2%e9%97%ae%e6%95%b0%e7%bb%84%e7%ac%ack%e5%b0%8f class=h-anchor aria-hidden=true>#</a></h3><p>正常的思路是对于每个询问二分一次。但我们也可以所有询问一起二分，根据左半部分的数的个数判断每个询问应该分到哪个集合中。</p><p>核心代码如下(简洁起见没用离散化, <code>query[i]</code>是第i个询问的k值，<code>sum(l, r)</code>是在[l, r]区间中的数的个数)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>solve</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> id) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (l<span style=color:#f92672>==</span>r <span style=color:#f92672>||</span> id.empty()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> i : id) ans[i]<span style=color:#f92672>=</span>l;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> less, more;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid<span style=color:#f92672>=</span>(l<span style=color:#f92672>+</span>r)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> i : id) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (query[i]<span style=color:#f92672>&lt;=</span>sum(l, mid)) less.push_back(i);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            query[i]<span style=color:#f92672>-=</span>sum(l, mid);
</span></span><span style=display:flex><span>            more.push_back(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    solve(l, mid, less);
</span></span><span style=display:flex><span>    solve(mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, r, more);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=静态数组区间第k小>静态数组区间第k小
<a href=#%e9%9d%99%e6%80%81%e6%95%b0%e7%bb%84%e5%8c%ba%e9%97%b4%e7%ac%ack%e5%b0%8f class=h-anchor aria-hidden=true>#</a></h3><p><a href=https://www.luogu.com.cn/problem/P3834>题目链接</a></p><p>这题的一般做法是在可持久化线段树（主席树）上二分，并且可以在线回答询问。整体二分思路有相似也有不同，假设目前询问的区间是$[ql, qr]$,答案在$[l, r]$中，令$mid=(l+r)/2$，此时我们新建一个和原数组一样长的辅助数组，将整个数组中在$[l, mid]$中的数在辅助数组中各自的位置上+1，然后查询位置在$[ql, qr]$中的数的个数（也就是辅助数组中$[ql, qr]$的区间和），与k做比较并由此判断再往哪个区间继续二分。</p><p>这里要注意要是每次构建辅助数组的时候都扫过整个数组，时间会爆炸，所以我们可以像划分询问那样划分数组，这样添加的数都是在$[l, r]$中的数。</p><p><strong>关于划分的写法：</strong></p><p>常见的写法是用两个数组存左边和右边的询问，但其实可以直接利用<code>std::partition</code>或者<code>std::stable_partition</code>直接在原数组上划分，内存和时间上都更优（时间少10%左右，内存少30%左右），而且个人感觉写起来更简洁一些？后面所有题都有partition的写法，部分有数组的写法，选择自己喜欢的即可。</p><p>using namespace std;</p><p>#define all(x) (x).begin(),(x).end()</p><p>constexpr int M=3e5;
namespace fenwick {
int n;
int t[M];</p><pre><code>using T=int;
</code></pre><p>void update(int i, T x) {
while (i &lt; n) {
t[i] += x;
i |= (i + 1);
}
}</p><p>template &lt;typename U> U query(int i) {
U res{};
for (; i >= 0; i = (i & (i + 1)) - 1)
res += t[i];
return res;
}</p><p>template &lt;typename U>
U query(int l, int r) { return query&lt;U>(r) - (l ? query&lt;U>(l - 1) : U{}); }
};
struct Num{
int x, i;
};</p><p>struct Query {
int l, r, k, id;
};
int main() {
cin.tie(nullptr)->sync_with_stdio(false);
int n, q;
cin>>n>>q;
vector&lt;Num> a(n);
vector&lt;int> comp(n), aa(n);
for (int i=0; i&lt;n; i++) {
cin>>aa[i];
comp[i]=aa[i];
}
sort(all(comp));
comp.erase(unique(all(comp)), comp.end());
for (int i=0; i&lt;n; i++) a[i]={static_cast&lt;int>(lower_bound(all(comp), aa[i])-comp.begin()), i}; // 离散化
vector&lt;Query> Q(q);
for (int i=0; i&lt;q; i++) {
auto& [l, r, k, id]=Q[i];
cin>>l>>r>>k;
id=i;
l&ndash;, r&ndash;;
}
fenwick::n=n;
vector&lt;int> ans(q);
// abegin 和 aend 是原数组中值在[l, r]中的数的区间， qbegin 和 qend是答案在[l, r]中的询问的区间
auto solve=[&](auto& solve, int l, int r, auto abegin, auto aend, auto qbegin, auto qend) {
if (l==r || qbegin==qend) {
for (auto it=qbegin; it!=qend; ++it) ans[it->id]=l;
return;
}
int mid=(l+r)/2;
auto amid=partition(abegin, aend, [&](Num& x){ // 划分原数组，并更新树状数组
if (x.x&lt;=mid) {
fenwick::update(x.i, 1);
return true;
}
return false;
});
auto qmid=partition(qbegin, qend, [&](Query& q) { // 划分询问
int t=fenwick::query&lt;int>(q.l, q.r);
if (q.k&lt;=t) return true;
else {
q.k-=t;
return false;
}
});
for (auto it=abegin; it!=amid; ++it) fenwick::update(it->i, -1); // 撤销之前的操作以清空树状数组
solve(solve, l, mid, abegin, amid, qbegin, qmid);
solve(solve, mid+1, r, amid, aend, qmid, qend);
};
solve(solve, 0, (int)comp.size(), a.begin(), a.end(), Q.begin(), Q.end());
for (auto x : ans) cout&lt;&lt;comp[x]&lt;&lt;'\n';
}</p><h3 id=动态区间第k小>动态区间第k小
<a href=#%e5%8a%a8%e6%80%81%e5%8c%ba%e9%97%b4%e7%ac%ack%e5%b0%8f class=h-anchor aria-hidden=true>#</a></h3><p><a href=https://www.luogu.com.cn/problem/P2617>题目链接</a></p><p>修改无非就是把原来的数删掉（在辅助数组中减1），再加上修改之后的数，和上一题大同小异。区别是由于有了时间顺序，不能像上一题先修改再询问了，要把修改和询问放在一个数组（其实上一题也能放在一个数组里，只是为了方便理解分成了两个数组），而且要用<code>std::stable_partition</code>以保证相对时间顺序不变。</p><p>using namespace std;</p><p>#define all(x) (x).begin(), (x).end()</p><p>constexpr int M = 3e5;
int N;
int t[M];</p><p>using T = int;
void update(int i, T x) {
while (i &lt; N) {
t[i] += x;
i |= (i + 1);
}
}</p><p>template &lt;typename U> U query(int i) {
U res{};
for (; i >= 0; i = (i & (i + 1)) - 1)
res += t[i];
return res;
}</p><p>template &lt;typename U> U query(int l, int r) {
return query&lt;U>(r) - (l ? query&lt;U>(l - 1) : U{});
}</p><p>struct op {
int type;
// if type==0, add j to position i, a[i]=k
// if type==1, query k-th smallest element in [i, j], id is the index of the query
int i, j, k, id;
};
int main() {
cin.tie(nullptr)->sync_with_stdio(false);
int n, q;
cin >> n >> q;
vector&lt;op> ops;
vector&lt;int> comp, a(n);
for (int i = 0; i &lt; n; i++) {
cin >> a[i];
comp.push_back(a[i]);
ops.push_back({0, i, 1, a[i], -1});
}
int qcnt = 0;
for (int i = 0; i &lt; q; i++) {
char ch;
cin >> ch;
if (ch == 'Q') {
int l, r, k;
cin >> l >> r >> k;
ops.push_back({1, l - 1, r - 1, k, qcnt++});
} else {
int x, y;
cin >> x >> y;
x&ndash;;
ops.push_back({0, x, -1, a[x], -1});
comp.push_back(y);
a[x] = y;
ops.push_back({0, x, 1, y, -1});
}
}
// 离散化
sort(all(comp));
comp.erase(unique(all(comp)), comp.end());
for (auto &[type, i, j, k, id] : ops) {
if (type == 0) k = lower_bound(all(comp), k) - comp.begin();
}
N = n;
vector&lt;int> ans(qcnt);
auto solve = [&](auto &solve, int l, int r, auto begin, auto end) {
if (l == r || begin == end) {
for (auto it = begin; it != end; ++it)
if (it->type == 1) ans[it->id] = l;
return;
}
int mid = (l + r) / 2;
// 因为要保证相对顺序不变所以要用stable_partition
auto qmid = stable_partition(begin, end, [&](op &q) {
auto &[type, i, j, k, id] = q;
if (type == 1) {
int cnt = query&lt;int>(i, j);
if (cnt >= k) return true;
else {
k -= cnt;
return false;
}
} else {
if (k &lt;= mid) {
update(i, j);
return true;
} else
return false;
}
});
for (auto it = begin; it != qmid; ++it)
if (it->type == 0) update(it->i, -it->j);
solve(solve, l, mid, begin, qmid);
solve(solve, mid + 1, r, qmid, end);
};
solve(solve, 0, (int)comp.size(), ops.begin(), ops.end());
for (auto x : ans)
cout &lt;&lt; comp[x] &lt;&lt; '\n';
}</p><p>using namespace std;
#define all(x) (x).begin(), (x).end()</p><p>constexpr int M = 3e5;
int N;
int t[M];</p><p>using T = int;
void update(int i, T x) {
while (i &lt; N) {
t[i] += x;
i |= (i + 1);
}
}</p><p>template &lt;typename U> U query(int i) {
U res{};
for (; i >= 0; i = (i & (i + 1)) - 1)
res += t[i];
return res;
}</p><p>template &lt;typename U> U query(int l, int r) {
return query&lt;U>(r) - (l ? query&lt;U>(l - 1) : U{});
}</p><p>struct op {
int type;
// if type==0, add j to position i, a[i]=k
// if type==1, query k-th smallest element in [i, j], id is the index
int i, j, k, id;
};
int main() {
cin.tie(nullptr)->sync_with_stdio(false);
int n, q;
cin >> n >> q;
vector&lt;op> ops;
vector&lt;int> comp, a(n);
for (int i = 0; i &lt; n; i++) {
cin >> a[i];
comp.push_back(a[i]);
ops.push_back({0, i, 1, a[i], -1});
}
int qcnt = 0;
for (int i = 0; i &lt; q; i++) {
char ch;
cin >> ch;
if (ch == 'Q') {
int l, r, k;
cin >> l >> r >> k;
ops.push_back({1, l - 1, r - 1, k, qcnt++});
} else {
int x, y;
cin >> x >> y;
x&ndash;;
ops.push_back({0, x, -1, a[x], -1});
comp.push_back(y);
a[x] = y;
ops.push_back({0, x, 1, y, -1});
}
}
sort(all(comp));
comp.erase(unique(all(comp)), comp.end());
for (auto &[type, i, j, k, id] : ops) {
if (type == 0) k = lower_bound(all(comp), k) - comp.begin();
}
N = n;
vector&lt;int> ans(qcnt);
auto solve = [&](auto &solve, int l, int r, vector&lt;op> &ops) {
if (l == r || ops.empty()) {
for (auto &q : ops) {
if (q.type == 1) ans[q.id] = l;
}
return;
}
int mid = (l + r) / 2;
vector&lt;op> left, right;
for (auto &q : ops) {
auto &[type, i, j, k, id] = q;
if (type == 1) {
int cnt = query&lt;int>(i, j);
if (cnt >= k) left.push_back(q);
else {
k -= cnt;
right.push_back(q);
}
} else {
if (k &lt;= mid) {
update(i, j);
left.push_back(q);
} else
right.push_back(q);
}
}
for (auto &q : left)
if (q.type == 0) update(q.i, -q.j);
vector&lt;op>().swap(ops);
solve(solve, l, mid, left);
solve(solve, mid + 1, r, right);
};
solve(solve, 0, (int)comp.size(), ops);
for (auto x : ans)
cout &lt;&lt; comp[x] &lt;&lt; '\n';
}</p><h3 id=zjoi2013k大数查询>[ZJOI2013]K大数查询
<a href=#zjoi2013k%e5%a4%a7%e6%95%b0%e6%9f%a5%e8%af%a2 class=h-anchor aria-hidden=true>#</a></h3><p><a href=https://www.luogu.com.cn/problem/P3332>题目链接</a></p><p>$[l, r]$中每个集合加入一个数就相当于在辅助数组中$[l, r]$的位置上加1,所以我们需要一个可以区间加的数据结构，最简单的就是树状数组啦。其他和上一题没区别。</p><p>using namespace std;
#define all(x) (x).begin(), (x).end()</p><p>template &lt;typename T> struct fenwick_rg {
int n;
vector&lt;T> sum1, sum2;
fenwick_rg(int n_) : n(n_), sum1(n+1), sum2(n+1) {}</p><pre><code>void update(int p, T x) {
    p&amp;#43;&amp;#43;;
    for (int i = p; i &amp;lt;= n; i &amp;#43;= i &amp;amp; -i)
        sum1[i] &amp;#43;= x, sum2[i] &amp;#43;= x * p;
}
void update(int l, int r, T x) { update(l, x), update(r &amp;#43; 1, -x); }

T query(int p) {
    p&amp;#43;&amp;#43;;
    T res{};
    for (int i = p; i; i -= i &amp;amp; -i)
        res &amp;#43;= (p &amp;#43; 1) * sum1[i] - sum2[i];
    return res;
}

T query(int l, int r) { return query(r) - query(l - 1); }
</code></pre><p>};</p><p>struct op {
int type;
// if type==0, add k to [l, r]
// if type==1, query k-th smallest element in [l, r], id is the index
int l, r;
long long k;
int id;
op(int t, int _l, int _r, long long _k, int _id)
: type(t), l(_l), r(_r), k(_k), id(_id) {}
};
int main() {
cin.tie(nullptr)->sync_with_stdio(false);
int n, q;
cin >> n >> q;
vector&lt;op> ops;
vector&lt;int> comp;
int qcnt = 0;
for (int i = 0; i &lt; q; i++) {
int op;
int l, r, k;
cin >> op>>l>>r>>k;;
if (op == 2) {
ops.push_back({1, l - 1, r - 1, k, qcnt++});
} else {
ops.push_back({0, l-1, r-1, k, -1});
comp.push_back(k);
}
}
sort(all(comp));
comp.erase(unique(all(comp)), comp.end());
for (auto &[type, i, j, k, id] : ops) {
if (type == 0) k = lower_bound(all(comp), k) - comp.begin();
}
fenwick_rg&lt;long long> tr(n);
vector&lt;int> ans(qcnt);
auto solve = [&](auto &solve, int l, int r, auto ql, auto qr) {
if (l == r || ql == qr) {
for (auto it = ql; it != qr; ++it)
if (it->type == 1) ans[it->id] = l;
return;
}
int mid = (l + r) / 2;
auto qmid = stable_partition(ql, qr, [&](op &q) {
auto &[type, l, r, k, id] = q;
if (type == 1) {
long long cnt = tr.query(l, r);
if (cnt >= k) return false;
k -= cnt;
return true;
} else {
if (k > mid) {
tr.update(l, r, 1);
return false;
} else return true;
}
});
for (auto it = qmid; it != qr; ++it)
if (it->type == 0) tr.update(it->l, it->r, -1);
solve(solve, l, mid, ql, qmid);
solve(solve, mid + 1, r, qmid, qr);
};
solve(solve, 0, (int)comp.size(), ops.begin(), ops.end());
for (auto x : ans)
cout &lt;&lt; comp[x] &lt;&lt; '\n';
}</p><h3 id=meteors>Meteors
<a href=#meteors class=h-anchor aria-hidden=true>#</a></h3><p><a href=https://loj.ac/p/2169>题目链接</a></p><p>思路:</p><ul><li><p>假设当前有一些询问的答案在某个修改区间中，我们将修改区间从中间分开</p></li><li><p>应用左半部分的修改</p></li><li><p>判断这些询问是否达到目标，将询问分为达到目标和没达到目标两个集合，同时将左半部分修改的贡献从没达到目标的询问中减去</p></li><li><p>撤销左半部分的修改</p></li><li><p>递归两个修改区间</p></li></ul><p>// 修改的范围是[low, high], 答案在[low, high]中的询问存在members里
auto solve = [&](auto & solve, int low, int high, vector&lt;int> &members) {
if (members.empty() && low == high) { // 区间长度为1,或者没有符合条件的询问
for (auto x : members) // 记录答案
ans[x] = low;
return;
}</p><pre><code>int mid = (low &amp;#43; high) / 2;
for (int i = low; i &amp;lt;= mid; i&amp;#43;&amp;#43;) {
    apply_modification(i, 1); // 应用左半部分的修改
}
vector&amp;lt;int&amp;gt; left, right;
for (const auto &amp;amp;m : members) {
    ll has = 0;
    for (const auto &amp;amp;sec : own[m]) {
        has &amp;#43;= fenwick::query&amp;lt;ll&amp;gt;(sec);
        if (has &amp;gt;= need[m]) break;
    }
    if (has &amp;gt;= need[m]) { // 询问的条件被满足，说明该询问 的答案在左半区间
        left.push_back(m);
    } else { // 反之，答案在右半区间
        need[m] -= has; // 减去左半部分修改的贡献
        right.push_back(m); 
    }
}
for (int i = low; i &amp;lt;= mid; i&amp;#43;&amp;#43;) {
    apply_modification(i, -1); // 撤销修改
}
solve(solve, low, mid, left);
vector&amp;lt;int&amp;gt;().swap(left); // 清空数组，优化内存使用
solve(solve, mid &amp;#43; 1, high, right);
vector&amp;lt;int&amp;gt;().swap(right);
</code></pre><p>};</p><p>using namespace std;
#define all(x) (x).begin(),(x).end()
using ll = long long;
using pii = pair&lt;int, int>;</p><p>constexpr int M=3e5;
namespace fenwick { // 此题时间很严，需要用静态数组实现的树状数组
int n;
ll t[M];</p><pre><code>using T=ll;
</code></pre><p>void update(int i, T x) {
while (i &lt; n) {
t[i] += x;
i |= (i + 1);
}
}</p><p>void update(int l, int r, T x) {
update(l, x);
if (r+1&lt;n) update(r+1, -x);
}</p><p>template &lt;typename U> U query(int i) {
U res{};
for (; i >= 0; i = (i & (i + 1)) - 1)
res += t[i];
return res;
}</p><p>};
int main() {
cin.tie(nullptr)->sync_with_stdio(false);
int n, m;
cin>>n>>m;
vector&lt;vector&lt;int>> own(n);
for (int i=0; i&lt;m; i++) {
int x;
cin>>x;
own[x-1].push_back(i);
}
vector&lt;ll> need(n);
for (auto& x : need) cin>>x;
int q;
cin>>q;
vector&lt;int> l(q), r(q), val(q);
for (int i=0; i&lt;q; i++) {
cin>>l[i]>>r[i]>>val[i];
l[i]&ndash;, r[i]&ndash;;
}
fenwick::n=m;
vector&lt;int> members(n);
iota(all(members), 0);
auto apply_modification=[&](int q, int flag) {
int v=val[q]*flag;
if (l[q]&lt;=r[q]) fenwick::update(l[q], r[q], v);
else {
fenwick::update(l[q], m-1, v);
fenwick::update(0, r[q], v);
}
};
vector&lt;int> ans(n, -1);
auto solve=[&](auto& solve, int low, int high, auto begin, auto end) {
if (begin==end || low==high) {
for (auto i=begin; i!=end; i++) ans[*i]=low;
return;
}
int mid=(low+high)/2;
for (int i=low; i&lt;=mid; i++) {
apply_modification(i, 1);
}
auto m=partition(begin, end, [&](int m) {
ll has=0;
for (const auto& sec : own[m]) {
has+=fenwick::query&lt;ll>(sec);
if (has>=need[m]) break;
}
if (has>=need[m]) {
return true;
} else {
need[m]-=has;
return false;
}
});
for (int i=low; i&lt;=mid; i++) {
apply_modification(i, -1);
}
solve(solve, low, mid, begin, m);
solve(solve, mid+1, high, m, end);
};
solve(solve, 0, q, members.begin(), members.end());
for (auto x : ans) {
if (x!=q) cout&lt;&lt;x+1&lt;&lt;'\n';
else cout&lt;&lt;"NIE\n";
}
}</p><h3 id=agc002d-stamp-rally>AGC002D Stamp Rally
<a href=#agc002d-stamp-rally class=h-anchor aria-hidden=true>#</a></h3><p><a href=https://atcoder.jp/contests/agc002/tasks/agc002_d>题目链接</a></p><p>这题思路其实不难，假设当前答案在$[l, r]$内，令$mid=(l+r)/2$，将编号从0到mid的边放入并查集中然后判断连通块大小即可，但问题是这题的目标修改不了，没法像前面的题一样减掉前面的贡献，而每次加边如果都从0到mid的话时间会爆炸，所以要尽可能利用并查集之前的信息，所以我们将递归改成用队列实现，这样区间的顺序就变成了从小到大，就可以很好的利用之前的信息，只有区间到头了的时候才会清空并查集。如果把区间想象成一棵线段树的话，前面的递归可以看成dfs,队列就是bfs,由于树高是$\log(n)$的，所以时间是$O(n\log(n))$的。</p><p>#define all(x) (x).begin(),(x).end()
using namespace std;
using ll = long long;
using pii = pair&lt;int, int>;</p><p>struct Q {
int x, y, z, id;
};
struct UF {
int n;
vector&lt;int> pa; // parent or size, positive number means parent, negative number means size
explicit UF(int _n) : n(_n), pa(n, -1) {}</p><pre><code>int find(int x) {
    assert(0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; n);
    return pa[x] &amp;lt; 0 ? x : pa[x]=find(pa[x]);
}

bool same(int x, int y) {
    return find(x)==find(y);
}

bool join(int x, int y) {
    assert(0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; n);
    assert(0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; n);
    x=find(x), y=find(y);
    if (x==y) return false;
    if (-pa[x] &amp;lt; -pa[y]) swap(x, y); // size of x is smaller than size of y
    pa[x]&amp;#43;=pa[y];
    pa[y]=x;
    return true;
}

int size(int x) {
    assert(0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; n);
    return -pa[find(x)];
}
</code></pre><p>};</p><p>int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, m;
cin>>n>>m;
vector&lt;pair&lt;int, int>> edges(m);
for (auto& [x, y] : edges) {
cin>>x>>y;
x&ndash;, y&ndash;;
}
int q;
cin>>q;
vector&lt;int> ans(q);
vector&lt;Q> queries(q);
for (int i=0; i&lt;q; i++) {
auto& [x, y, z, id] = queries[i];
cin>>x>>y>>z;
x&ndash;, y&ndash;;
id=i;
}
UF uf(n);
queue&lt;tuple&lt;int, int, int, int>> que;
que.emplace(0, m-1, 0, q);
int cur=0; // cur用来记录当前哪些边被加进了并查集里
while (!que.empty()) {
auto [l, r, ql, qr]=que.front();
que.pop();
if (l==r || ql==qr) {
for (auto it=ql; it!=qr; ++it) {
ans[queries[it].id]=l;
}
continue;
}
int mid=(l+r)/2;
if (cur>mid) uf=UF(n), cur=0;
for (; cur&lt;=mid; cur++) {
uf.join(edges[cur].first, edges[cur].second);
}
auto qmid=partition(queries.begin()+ql, queries.begin()+qr, [&](Q& qu) {
auto& [x, y, z, _]=qu;
int sz;
if (uf.same(x, y)) sz=uf.size(x);
else sz=uf.size(x)+uf.size(y);
if (sz>=z) return true;
else return false;
})-queries.begin();
que.emplace(l, mid, ql, qmid);
que.emplace(mid+1, r, qmid, qr);
}
for (auto x : ans) cout&lt;&lt;x+1&lt;&lt;'\n';
}</p><h2 id=ctsc2008-network-网络管理>CTSC2008 Network 网络管理
<a href=#ctsc2008-network-%e7%bd%91%e7%bb%9c%e7%ae%a1%e7%90%86 class=h-anchor aria-hidden=true>#</a></h2><p>我提交的地方是个私有题库，暂时没找到公开的提交的地方。其实基本上就是动态区间第k大，只不过区间变成了树上路径，用树剖分解成多个区间就行了。</p><p>struct Heavy_light {
vector&lt;vector&lt;int>> g;
vector&lt;int> fa, dep, heavy, head, pos, posr; // initialize heavy with -1
int cnt=0;
fenwick&lt;int> tr;
Heavy_light(int n) : g(n), fa(n), dep(n), heavy(n, -1), head(n), pos(n), posr(n), tr(n) {}
void add_edge(int u, int v) {
g[u].push_back(v);
g[v].push_back(u);
}
int dfs(int u) {
int size = 1;
int mx = 0;
for (int v : g[u]) {
if (v != fa[u]) {
fa[v] = u, dep[v] = dep[u] + 1;
int csize = dfs(v);
size += csize;
if (csize > mx) mx = csize, heavy[u] = v;
}
}
return size;
}
void dfs2(int u, int h) {
head[u] = h, pos[u] = cnt++; //1-based index, could change to 0 based but less useful
if (heavy[u] != -1) dfs2(heavy[u], h);
for (int v : g[u]) {
if (v != fa[u] && v != heavy[u])
dfs2(v, v);
}
posr[u] = cnt;
}
int pathsum(int u, int v) {
int res = 0;
while (head[u] != head[v]) {
if (dep[head[u]] &lt; dep[head[v]]) swap(u, v);
res += tr.query(pos[head[u]], pos[u]);
u = fa[head[u]];
}
if (pos[u] > pos[v]) swap(u, v);
res += tr.query(pos[u], pos[v]);
return res;
}
void add(int u, int x) {
tr.add(pos[u], x);
}
};</p><p>struct Q {
int type;
int i, j, k, id;
};</p><p>int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, q;
cin>>n>>q;
vector&lt;int> t(n);
for (auto& x : t) cin>>x;
Heavy_light tr(n);
for (int i=1; i&lt;n; i++) {
int u, v;
cin>>u>>v;
u&ndash;, v&ndash;;
tr.add_edge(u, v);
}
vector&lt;Q> qs;
int qc=0;
for (int i=0; i&lt;n; i++) {
qs.push_back({0, i, 1, t[i], -1});
}
for (int i=0; i&lt;q; i++) {
int k, a, b;
cin>>k>>a>>b;
if (k==0) {
a&ndash;;
qs.push_back({0, a, -1, t[a], -1});
t[a]=b;
qs.push_back({0, a, 1, b, -1});
} else {
qs.push_back({1, a-1, b-1, k, qc++});
}
}
vector&lt;int> ans(qc);
tr.dfs(0);
tr.dfs2(0, 0);
auto solve=[&](auto& slf, int l, int r, auto begin, auto end) {
if (l==r || begin==end) {
for (auto it = begin; it!=end; ++it) {
if (it->type==1) ans[it->id]=l;
}
return;
}
int mid=(l+r+1)/2;
auto qmid = stable_partition(begin, end, [&](Q& q) {
auto& [type, i, j, k, id] = q;
if (type==1) {
int cnt=tr.pathsum(i, j);
if (cnt >= k) return false;
k-=cnt;
return true;
} else {
if (k>=mid) {
tr.add(i, j);
return false;
} else
return true;
}
});
for (auto it = qmid; it!=end; ++it)
if (it->type == 0)
tr.add(it->i, -it->j);
slf(slf, l, mid-1, begin, qmid);
slf(slf, mid, r, qmid, end);
};
solve(solve, 0, 1e6, qs.begin(), qs.end());
for (auto x : ans) {
if (x==0) cout&lt;&lt;"invalid request!\n";
else cout&lt;&lt;x&lt;&lt;'\n';
}
}</p></div></div></div><footer class=footer><div class=footer__inner><a href=/zh class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Thallium54</span></a><div class=copyright><span>© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a>, moded by me</span></div></div></footer><script src=https://tgc54.com/assets/main.js></script>
<script src=https://tgc54.com/assets/prism.js></script></div></body></html>