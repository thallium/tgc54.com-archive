<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CUGBACM | Thallium54</title><link>https://tgc54.com/zh/tag/cugbacm/</link><atom:link href="https://tgc54.com/zh/tag/cugbacm/index.xml" rel="self" type="application/rss+xml"/><description>CUGBACM</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><lastBuildDate>Sun, 29 Sep 2019 00:00:00 +0000</lastBuildDate><image><url>https://tgc54.com/media/icon_hu423b19687c85b10febae54029c442fbf_4135_512x512_fill_lanczos_center_3.png</url><title>CUGBACM</title><link>https://tgc54.com/zh/tag/cugbacm/</link></image><item><title>CUGBACM18级训练#6 题解</title><link>https://tgc54.com/zh/post/cugb6/</link><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><guid>https://tgc54.com/zh/post/cugb6/</guid><description>&lt;h1 id="a---keywords-search-hdu---2222">A - Keywords Search HDU - 2222&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 给出单词和文章，问多少个单词在文章中出现过。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> AC自动机板子题，之前也说过，不再赘述。&lt;/p>
&lt;h1 id="b---病毒侵袭-hdu---2896">B - 病毒侵袭 HDU - 2896&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。&lt;/p>
&lt;h1 id="c---sliding-window-poj---2823">C - Sliding Window POJ - 2823&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 数组长度为$n$,长度为$k$的窗户在数组上滑动，问每次滑动后的窗户中的最大和最小值。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 用线段树或者st表复杂度都是$O(nlogn)$，单调队列可以做到$O(n)$，如果求最大值就维护单调递增序列，方法如下：&lt;/p>
&lt;ol>
&lt;li>不断从队尾出列，直到队尾元素大于待入队的数，因为又小又靠前面的数自然比不上又大又靠后的数。&lt;/li>
&lt;li>不断从队首出列，直到队首元素的下标在窗户的范围之内。&lt;/li>
&lt;li>输出队首元素，为当前窗户的最大值。&lt;/li>
&lt;/ol>
&lt;p>求最小值步骤类似，实际维护的时候为了容易实现第二步，队列中存的是下标。&lt;/p>
&lt;h1 id="d---intersections-gym---101853c">D - Intersections Gym - 101853C&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 给出两行序列，连接相同的数，问产生交点的个数。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 如果两个数在上下两行中的相对位置发生了变化，连线的时候就会产生一个交点。&lt;/p>
&lt;p>在读入第一行的时候记录每个数在数组中的位置。在读入第二行的时候将其替换为该数在第一行的出现位置，那么问题就变成了求逆序对（$a_i&amp;gt;a_j,i&amp;lt;j$）个数的问题。&lt;/p>
&lt;p>有两种求法：归并排序和树状数组。这里介绍树状数组的做法：将所有的数的在第一行出现的位置和在第二行出现的位置作为数对保存在数组中，按照第一行出现的位置从大到小排序，这样每次插入一个数的时候前面数字的个数就是插入这个数产生新的逆序对的个数，因为数组是从大到小排序，此时已经插入的数都是比当前数大的数，而位置在前面的数就是符合逆序对定义的数。而这就可以用树状数组实现，计算前面数的个数就是算前缀和，插入就是在第二次出现的位置+1。&lt;/p>
&lt;h1 id="e---维护序列-gym---237040g">E - 维护序列 Gym - 237040G&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 维护一个序列，支持以下操作：&lt;/p>
&lt;ul>
&lt;li>把数列中的一段数全部乘一个值；&lt;/li>
&lt;li>把数列中的一段数全部加一个值；&lt;/li>
&lt;li>询问数列中的一段数的和模 $P$ 的值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>思路：&lt;/strong> 线段树改板子题，需要动点脑子，乘的时候加和乘的lazy tag都要更新。因为$(val\cdot lazy_{mul}+lazy_{add})\cdot x=val\cdot lazy_{mul}\cdot x+lazy_{add}\cdot x$ 其他貌似就&lt;del>忘&lt;/del> 没 &lt;del>的&lt;/del> 什 &lt;del>差&lt;/del> 么 &lt;del>不&lt;/del> 好 &lt;del>多&lt;/del> 说 &lt;del>了&lt;/del> 的了。&lt;/p>
&lt;h1 id="f---little-elephant-and-array-codeforces---220b">F - Little Elephant and Array CodeForces - 220B&lt;/h1>
&lt;p>&lt;a href="https://thallium.github.io/%E9%A2%98%E8%A7%A3/tutorial/2019/09/26/cf220B/" target="_blank" rel="noopener">见我的另一篇文章&lt;/a>&lt;/p>
&lt;h1 id="g---tourists-gym---101002i">G - Tourists Gym - 101002I&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 给出一棵树，计算所有两端其中一个是另一个倍数的路径长度和。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 计算树上路径自然要用到LCA，就是个倍增法板子题。&lt;/p>
&lt;h1 id="i---二维树状数组-单点修改区间查询-gym---237040e">I - 二维树状数组 ：单点修改，区间查询 Gym - 237040E&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 见题目。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 见题目。&lt;/p>
&lt;h1 id="k---jzzhu-and-cities-codeforces---449b">K - Jzzhu and Cities CodeForces - 449B&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 一个图中有$m$条道路和$k$条通往首都（标号为1的点）的铁路。问最多可以去掉多少铁路使得所有城市到首都的最短距离不变。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 把所有道路和铁路都放到图里，dijkstra是可以记录最短路路径条数的！（好像考试考过？），原理就是当更新距离的时候如果和当前最短路径一样长就路径条数+1，如果更短条数就置为1。最后遍历所有铁路，如果当前铁路比最短路长那么就可以去掉，如果和最短路一样的话就要看最短路还剩几条，如果大于1的话就可以去掉并且把最短路的条数-1。&lt;/p>
&lt;h1 id="l---alyona-and-the-tree-codeforces---682c">L - Alyona and the Tree CodeForces - 682C&lt;/h1>
&lt;p>&lt;strong>题意：&lt;/strong> 给出一棵边权点权树，问最少去掉几个点使得不存在这样的点$u$：其子树上存在某点$v$，其点权$a_v$大于$v$到$u$的距离。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 计算树上所有的距离肯定超时，但是有这样一条性质，如果边权都是正数的话，如果$\operatorname{dist}(u,v)&amp;gt; a_u,v\not = root$那么$\operatorname{dist}(u,root)&amp;gt;a_u$，也就是说我们可以只计算到根节点的距离就行了，但是边权如果有负数上述性质就不成立了，但是我们可以稍加改动：当我们dfs的时候，如果当前点到根节点的距离小于0，那么我们就应该将距离置为0，然后接着dfs,这样就避免了前面的负权路径产生的干扰。&lt;/p></description></item><item><title>CUGBACM18级训练#4 题解</title><link>https://tgc54.com/zh/post/cugb4tutr/</link><pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate><guid>https://tgc54.com/zh/post/cugb4tutr/</guid><description>&lt;h2 id="b---godfather-gym---101649g">B - Godfather Gym - 101649G&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出一个有n个点的树，问去掉哪个点后剩下的树中最大的节点数最小（如果有多个按从小到大的顺序输出）。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 一开始没看见“保证是一棵树”想复杂了，先跑一遍dfs序，这样就能知道每个点除了父节点之外所有的子树的大小了，父节点对应的“子树”的大小就是n减去所有子树的大小之和。遍历所有点，找出所有“子树”中最大的那个，将其大小和编号作为数对加入数组中，然后对所有点排序，输出最小的那几个就行了。&lt;/p>
&lt;h2 id="e---wow-such-doge-hdu---4847">E - Wow! Such Doge! HDU - 4847&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出一篇文章，问其中出现过多少个&amp;quot;doge&amp;quot;（不区分大小写）。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 先遍历文章，将所有大写之母转为小写，然后再用find或者暴力查找&amp;quot;doge&amp;quot;即可。&lt;/p>
&lt;h2 id="g---theme-section-hdu---4763">G - Theme Section HDU - 4763&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出一个字符串n找出一个最长的子串（theme），使其出现在开头中间和结尾（不允许重叠）&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 一开始被样例误导了，以为theme里面只能有一种字符，wa了几发感觉不对，所以应该先跑前缀函数，然后从从第二位遍历到倒数第二位，如果某一位前缀函数大于其到第一位距离的一半，则取一半，找出其中的最大值，这样就得到了出现在中间的theme的最大长度。然后再判断最后一位的前缀长度是否大于整个字符串长度的三分之一，如果大于则取三分之一，这样就是出现在后面的theme的长度，输出中间和后面中比较小的一个即可。&lt;/p>
&lt;h2 id="i---path-hdu---6582">I - Path HDU - 6582&lt;/h2>
&lt;p>不会网络流，有空再补。&lt;/p></description></item><item><title>CUGBACM18级训练#3 题解</title><link>https://tgc54.com/zh/post/cugbacm3tutr/</link><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><guid>https://tgc54.com/zh/post/cugbacm3tutr/</guid><description>&lt;h2 id="1hdu1686">1.HDU1686&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出两个串 $S_1,S_2$，问$S_1$在$S_2$中出现的次数。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> kmp板子题，注意要用scanf。&lt;/p>
&lt;hr>
&lt;h2 id="2hdu2594">2.HDU2594&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出两个字符串$S_1,S_2$，求最长的既是$S_1$前缀又是$S_2$后缀的字符串。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 很明显就是把两个串拼起来然后求前缀函数，不过要注意的是拼起来的串的前缀函数有可能超过给出的串的长度，解决办法就是在两个串中间加一个符号。&lt;/p>
&lt;hr>
&lt;h2 id="3hdu6629">3.HDU6629&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出字符串$S$问用暴力算法求$S$的Z函数（一个长度为n的数组，其中第i个元素为满足从位置i开始且为s前缀的字符串的最大长度。）需要的比较次数。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 求每一个位置的比较次数都等于这个位置的z函数+1，因为要往后面多比较一次发现不匹配了才会终止（如果比较到字符串末尾了即i+z[i]&amp;gt;=n就不用加1），求和就是答案。&lt;/p>
&lt;hr>
&lt;h2 id="4codeforces-1200e">4.Codeforces 1200E&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给了你n个字符串，然后按照如下方式合并得到新串$S&amp;rsquo;$:&lt;/p>
&lt;ol>
&lt;li>如果$S&amp;rsquo;$为空串，则直接加入$S&amp;rsquo;$。&lt;/li>
&lt;li>否则，每次比较$S&amp;rsquo;$的后缀与前缀，取失配位置之后的后缀加入$S&amp;rsquo;$中&lt;/li>
&lt;/ol>
&lt;p>求s′&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 设答案串的长度为$L_{ans}$,需要合并的新串的长度为$L$,将“新串+#+答案串后面长$\min(L_{ans},L)$的子串”作为整体跑前缀函数，设整个串的最长公共前后缀的长度为$len$,将新串下标为$len,len+1, \cdots,L-1$的子串加到答案串之后。&lt;/p>
&lt;hr>
&lt;h2 id="5hdu3613">5.HDU3613&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出一字符串，其中每一种字符对应一个价值，将字符串切成两段，计算两段的价值和，方法如下：如果这一段是回文串，价值就是每一个字符对应的价值的和，否则该串价值为0。求两段价值之和的最大值。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 先跑一遍&lt;del>大可&lt;/del>马拉车算法，然后遍历求出串的价值前缀和，然后枚举分割点，找到两个串的中心，判断中心的回文串是不是整个串，如果是就利用之前算的前缀和加那个串的价值，在枚举中不断更新答案即可。&lt;/p>
&lt;hr>
&lt;h2 id="6-hdu2222">6. HDU2222&lt;/h2>
&lt;p>题意：给出n个单词和一个长串，问有几个单词在长串中出现过。&lt;/p>
&lt;p>思路：AC自动机板子题，好像没什么好说的……&lt;/p>
&lt;hr>
&lt;h2 id="7hdu2896">7.HDU2896&lt;/h2>
&lt;p>&lt;strong>题意：&lt;/strong> 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。&lt;/p>
&lt;p>&lt;strong>思路：&lt;/strong> 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。&lt;/p></description></item></channel></rss>